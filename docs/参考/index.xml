<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>参考 on Spring AI 1.0.0</title>
    <link>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/</link>
    <description>Recent content in 参考 on Spring AI 1.0.0</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>提示</title>
      <link>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E6%8F%90%E7%A4%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E6%8F%90%E7%A4%BA/</guid>
      <description>&lt;h1 id=&#34;提示&#34;&gt;&#xA;  提示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%90%e7%a4%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;提示是引导 AI 模型生成特定输出的输入。这些提示的设计和措辞会显著影响模型的响应。&lt;/p&gt;&#xA;&lt;p&gt;在 Spring AI 中与 AI 模型交互的最低级别，处理 Spring AI 中的提示有点类似于管理 Spring MVC 中的“视图”。这涉及创建包含动态内容占位符的大量文本。然后，这些占位符会根据用户请求或应用程序中的其他代码进行替换。另一个类比是包含特定表达式占位符的 SQL 语句。&lt;/p&gt;&#xA;&lt;p&gt;随着 Spring AI 的发展，它将引入更高级别的抽象，以便与 AI 模型进行交互。本节中描述的基础类在角色和功能方面可以类比为 JDBC。例如， &lt;code&gt;ChatModel&lt;/code&gt; 类类似于 JDK 中的核心 &lt;code&gt;ChatClient&lt;/code&gt; 库。&lt;code&gt;ChatClient&lt;/code&gt; 类可以类比为 &lt;code&gt;JdbcClient&lt;/code&gt; ，它构建于 &lt;code&gt;ChatModel&lt;/code&gt; 之上，并通过 &lt;code&gt;Advisor&lt;/code&gt; 提供更高级的构造。&#xA;考虑过去与模型的交互，用额外的上下文文档扩充提示，并引入代理行为。&lt;/p&gt;&#xA;&lt;p&gt;在人工智能领域，提示符的结构一直在不断发展。最初，提示符只是简单的字符串。随着时间的推移，它们逐渐包含特定输入的占位符，例如“USER:”，而人工智能模型可以识别这些占位符。OpenAI 通过在人工智能模型处理多个消息字符串之前，将它们分类到不同的角色中，为提示符引入了更丰富的结构。&lt;/p&gt;&#xA;&lt;h2 id=&#34;api-概述&#34;&gt;&#xA;  API 概述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api-%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;迅速的&#34;&gt;&#xA;  迅速的&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%85%e9%80%9f%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;通常使用 &lt;code&gt;ChatModel&lt;/code&gt; 的 &lt;code&gt;call()&lt;/code&gt; 方法，该方法接受一个 &lt;code&gt;Prompt&lt;/code&gt; 实例并返回一个 &lt;code&gt;ChatResponse&lt;/code&gt; 。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Prompt&lt;/code&gt; 类充当一系列有序的 &lt;code&gt;Message&lt;/code&gt; 对象和一个 &lt;code&gt;ChatOptions&lt;/code&gt; 请求的容器。每条 &lt;code&gt;Message&lt;/code&gt; 在提示中都体现着独特的角色，其内容和意图各不相同。这些角色可以涵盖各种元素，从用户查询到 AI 生成的响应，再到相关的背景信息。这种安排使得与 AI 模型进行复杂而细致的交互成为可能，因为提示由多条消息构成，每条消息在对话中都被赋予了特定的角色。&lt;/p&gt;</description>
    </item>
    <item>
      <title>结构化输出转换器</title>
      <link>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E7%BB%93%E6%9E%84%E5%8C%96%E8%BE%93%E5%87%BA%E8%BD%AC%E6%8D%A2%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E7%BB%93%E6%9E%84%E5%8C%96%E8%BE%93%E5%87%BA%E8%BD%AC%E6%8D%A2%E5%99%A8/</guid>
      <description>&lt;h1 id=&#34;结构化输出转换器&#34;&gt;&#xA;  结构化输出转换器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%84%e5%8c%96%e8%be%93%e5%87%ba%e8%bd%ac%e6%8d%a2%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;LLM 生成结构化输出的能力对于依赖可靠解析输出值的下游应用程序至关重要。开发人员希望快速将 AI 模型的结果转换为可传递给其他应用程序函数和方法的数据类型，例如 JSON、XML 或 Java 类。&lt;/p&gt;&#xA;&lt;p&gt;Spring AI &lt;code&gt;Structured Output Converters&lt;/code&gt; 有助于将 LLM 输出转换为结构化格式。如下图所示，此方法围绕 LLM 文本补全端点运行：&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  &lt;img src=&#34;../../images/structured-output-architecture.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;使用通用补全 API 从大型语言模型 (LLM) 生成结构化输出需要仔细处理输入和输出。结构化输出转换器在 LLM 调用前后起着至关重要的作用，确保实现所需的输出结构。&lt;/p&gt;&#xA;&lt;p&gt;在 LLM 调用之前，转换器会将格式指令附加到提示中，为模型提供生成所需输出结构的明确指导。这些指令充当蓝图，塑造模型的响应以符合指定的格式。&lt;/p&gt;&#xA;&lt;p&gt;LLM 调用后，转换器会获取模型的输出文本，并将其转换为结构化类型的实例。此转换过程包括解析原始文本输出并将其映射到相应的结构化数据表示形式，例如 JSON、XML 或特定于域的数据结构。&lt;/p&gt;&#xA;&lt;h2 id=&#34;结构化输出-api&#34;&gt;&#xA;  结构化输出 API&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%84%e5%8c%96%e8%be%93%e5%87%ba-api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;StructuredOutputConverter&lt;/code&gt; 接口允许您获取结构化输出，例如将基于文本的 AI 模型输出映射到 Java 类或值数组。接口定义如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StructuredOutputConverter&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Converter&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String, T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, FormatProvider {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它结合了 Spring [&#xA;  &lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html&#34;&gt;Converter&amp;lt;String、T&amp;gt;&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html&#34;&gt;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html&lt;/a&gt;) 接口和 &lt;code&gt;FormatProvider&lt;/code&gt; 接口&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FormatProvider&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;String &lt;span style=&#34;color:#a6e22e&#34;&gt;getFormat&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下图显示了使用结构化输出 API 时的数据流。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  &lt;img src=&#34;../../images/structured-output-api.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;FormatProvider&lt;/code&gt; 为 AI 模型提供特定的格式指南，使其能够生成文本输出，并使用 &lt;code&gt;Converter&lt;/code&gt; 将其转换为指定的目标类型 &lt;code&gt;T&lt;/code&gt; 以下是此类格式指令的示例：&lt;/p&gt;</description>
    </item>
    <item>
      <title>多模态 API</title>
      <link>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E5%A4%9A%E6%A8%A1%E6%80%81-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E5%A4%9A%E6%A8%A1%E6%80%81-api/</guid>
      <description>&lt;h1 id=&#34;多模态-api&#34;&gt;&#xA;  多模态 API&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e6%a8%a1%e6%80%81-api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;人类能够同时处理多种数据输入模式的知识。我们的学习方式和经验都是多模态的。我们拥有的不仅仅是视觉、听觉和文本。&lt;/p&gt;&#xA;&lt;p&gt;与这些原则相反，机器学习通常专注于为处理单一模态而定制的专用模型。例如，我们开发了用于文本转语音或语音转文本等任务的音频模型，以及用于对象检测和分类等任务的计算机视觉模型。&lt;/p&gt;&#xA;&lt;p&gt;然而，新一波多模态大型语言模型开始涌现。例如，OpenAI 的 GPT-4o、谷歌的 Vertex AI Gemini 1.5、Anthropic 的 Claude3，以及开源产品 Llama3.2、LLaVA 和 BakLLaVA，它们能够接受多种输入，包括文本、图像、音频和视频，并通过集成这些输入来生成文本响应。&lt;/p&gt;&#xA;&lt;h2 id=&#34;spring-ai-多模态&#34;&gt;&#xA;  Spring AI 多模态&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-ai-%e5%a4%9a%e6%a8%a1%e6%80%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;多模态性是指模型同时理解和处理来自各种来源的信息的能力，包括文本、图像、音频和其他数据格式。&lt;/p&gt;&#xA;&lt;p&gt;Spring AI Message API 提供了支持多模式 LLM 所需的所有抽象。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  &lt;img src=&#34;../../images/spring-ai-message-api.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;UserMessage 的 &lt;code&gt;content&lt;/code&gt; 字段主要用于文本输入，而可选的 &lt;code&gt;media&lt;/code&gt; 字段允许添加一个或多个不同模态的附加内容，例如图像、音频和视频。&lt;code&gt;MimeType&lt;/code&gt; 指定模态类型。根据所使用的 LLM， &lt;code&gt;Media&lt;/code&gt; 数据字段可以是作为 &lt;code&gt;Resource&lt;/code&gt; 对象的原始媒体内容 &lt;code&gt;MimeType&lt;/code&gt; 也可以是指向该内容的 &lt;code&gt;URI&lt;/code&gt; 。&lt;/p&gt;&#xA;&lt;p&gt;例如，我们可以将下面的图片（ &lt;code&gt;multimodal.test.png&lt;/code&gt; ）作为输入，并要求 LLM 解释它所看到的内容。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  &lt;img src=&#34;../../images/multimodal.test.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;对于大多数多模式 LLM，Spring AI 代码看起来像这样：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; imageResource &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ClassPathResource(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/multimodal.test.png&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; userMessage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; UserMessage(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Explain what do you see in this picture?&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// content&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Media(MimeTypeUtils.&lt;span style=&#34;color:#a6e22e&#34;&gt;IMAGE_PNG&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;imageResource&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// media&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ChatResponse response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chatModel.&lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Prompt(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;userMessage&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者使用流畅的 [&#xA;  &lt;a href=&#34;chatclient.html&#34;&gt;ChatClient&lt;/a&gt;](chatclient.html) API：&lt;/p&gt;</description>
    </item>
    <item>
      <title>聊天记忆</title>
      <link>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BF%86/</guid>
      <description>&lt;h1 id=&#34;聊天记忆&#34;&gt;&#xA;  聊天记忆&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8a%e5%a4%a9%e8%ae%b0%e5%bf%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;大型语言模型 (LLM) 是无状态的，这意味着它们不会保留先前交互的信息。当您希望在多个交互之间维护上下文或状态时，这可能会造成限制。为了解决这个问题，Spring AI 提供了聊天记忆功能，允许您使用 LLM 跨多个交互存储和检索信息。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;ChatMemory&lt;/code&gt; 抽象允许您实现各种类型的内存以支持不同的用例。消息的底层存储由 &lt;code&gt;ChatMemory&lt;/code&gt;Repository 处理，其唯一职责是存储和检索消息。由 &lt;code&gt;ChatMemory&lt;/code&gt; 实现决定保留哪些消息以及何时删除它们。策略示例包括保留最后 N 条消息、将消息保留一段时间或将消息保留到一定的令牌限制。&lt;/p&gt;&#xA;&lt;p&gt;在选择记忆类型之前，必须了解聊天记忆和聊天历史之间的区别。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;聊天记忆 。大型语言模型保留并用于在整个对话过程中保持语境感知的信息。&lt;/li&gt;&#xA;&lt;li&gt;聊天记录 。整个对话历史记录，包括用户和模型之间交换的所有消息。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;ChatMemory&lt;/code&gt; 抽象旨在管理聊天内存 。它允许您存储和检索与当前对话上下文相关的消息。但是，它并非存储聊天历史记录的最佳选择。如果您需要维护所有交换消息的完整记录，则应考虑使用其他方法，例如依赖 Spring Data 来高效地存储和检索完整的聊天历史记录。&lt;/p&gt;&#xA;&lt;h2 id=&#34;快速入门&#34;&gt;&#xA;  快速入门&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Spring AI 会自动配置一个 &lt;code&gt;ChatMemory&lt;/code&gt; bean，您可以在应用程序中直接使用它。默认情况下，它使用内存存储库 ( InMemory&lt;code&gt;ChatMemory&lt;/code&gt;Repository ) 来存储消息，并使用 MessageWindow&lt;code&gt;ChatMemory&lt;/code&gt; 实现来管理对话历史记录。如果已配置其他存储库（例如 Cassandra、JDBC 或 Neo4j），Spring AI 将改用该存储库。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Autowired&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ChatMemory chatMemory;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下部分将进一步描述 Spring AI 中可用的不同内存类型和存储库。&lt;/p&gt;&#xA;&lt;h2 id=&#34;内存类型&#34;&gt;&#xA;  内存类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;ChatMemory&lt;/code&gt; 抽象允许您实现各种类型的内存，以适应不同的用例。内存类型的选择会显著影响应用程序的性能和行为。本节介绍 Spring AI 提供的内置内存类型及其特性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;消息窗口聊天记忆&#34;&gt;&#xA;  消息窗口聊天记忆&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b6%88%e6%81%af%e7%aa%97%e5%8f%a3%e8%81%8a%e5%a4%a9%e8%ae%b0%e5%bf%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;MessageWindowChatMemory&lt;/code&gt; 会维护一个消息窗口，其大小不超过指定的最大限制。当消息数量超过上限时，较旧的消息会被删除，但系统消息会被保留。默认窗口大小为 20 条消息。&lt;/p&gt;</description>
    </item>
    <item>
      <title>工具调用</title>
      <link>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8/</guid>
      <description>&lt;h1 id=&#34;工具调用&#34;&gt;&#xA;  工具调用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7%e8%b0%83%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;工具调用 （也称为函数调用 ）是 AI 应用程序中的一种常见模式，允许模型与一组 API 或工具进行交互，从而增强其功能。&lt;/p&gt;&#xA;&lt;p&gt;工具主要用于：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信息检索 。此类工具可用于从外部来源（例如数据库、Web 服务、文件系统或 Web 搜索引擎）检索信息。其目标是增强模型的知识，使其能够回答原本无法回答的问题。因此，它们可用于检索增强生成 (RAG) 场景。例如，可以使用工具检索给定位置的当前天气、检索最新新闻文章或查询数据库中的特定记录。&lt;/li&gt;&#xA;&lt;li&gt;采取行动 。此类别中的工具可用于在软件系统中采取行动，例如发送电子邮件、在数据库中创建新记录、提交表单或触发工作流。其目标是自动化原本需要人工干预或明确编程的任务。例如，可以使用工具为与聊天机器人交互的客户预订航班、在网页上填写表单，或在代码生成场景中基于自动化测试 (TDD) 实现 Java 类。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;尽管我们通常将工具调用称为模型功能，但实际上工具调用逻辑是由客户端应用程序提供的。模型只能请求工具调用并提供输入参数，而应用程序负责根据输入参数执行工具调用并返回结果。模型永远无法访问任何作为工具提供的 API，这是一个至关重要的安全考虑因素。&lt;/p&gt;&#xA;&lt;p&gt;Spring AI 提供了便捷的 API 来定义工具、解析来自模型的工具调用请求以及执行工具调用。以下部分概述了 Spring AI 中的工具调用功能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;快速入门&#34;&gt;&#xA;  快速入门&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;让我们看看如何在 Spring AI 中开始使用工具调用。我们将实现两个简单的工具：一个用于信息检索，一个用于执行操作。信息检索工具将用于获取用户时区的当前日期和时间。操作工具将用于设置指定时间的闹钟。&lt;/p&gt;&#xA;&lt;h2 id=&#34;信息检索&#34;&gt;&#xA;  信息检索&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%a1%e6%81%af%e6%a3%80%e7%b4%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;AI 模型无法访问实时信息。任何假设模型能够感知当前日期或天气预报等信息的问题都无法由模型回答。不过，我们可以提供一个工具来检索这些信息，并让模型在需要访问实时信息时调用此工具。&lt;/p&gt;&#xA;&lt;p&gt;让我们在 &lt;code&gt;DateTimeTools&lt;/code&gt; 类中实现一个工具，用于获取用户时区的当前日期和时间。该工具不接受任何参数。Spring 框架中的 &lt;code&gt;LocaleContextHolder&lt;/code&gt; 可以提供用户的时区信息。该工具将被定义为一个带有 &lt;code&gt;@Tool&lt;/code&gt; 注解的方法。为了帮助模型理解是否以及何时调用此工具，我们将提供该工具功能的详细描述。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.time.LocalDateTime;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.ai.tool.annotation.Tool;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.context.i18n.LocaleContextHolder;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DateTimeTools&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Tool&lt;/span&gt;(description &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Get the current date and time in the user&amp;#39;s timezone&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String &lt;span style=&#34;color:#a6e22e&#34;&gt;getCurrentDateTime&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; LocalDateTime.&lt;span style=&#34;color:#a6e22e&#34;&gt;now&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;atZone&lt;/span&gt;(LocaleContextHolder.&lt;span style=&#34;color:#a6e22e&#34;&gt;getTimeZone&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;toZoneId&lt;/span&gt;()).&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，让我们将该工具提供给模型。在本例中，我们将使用 &lt;code&gt;ChatClient&lt;/code&gt; 与模型交互。我们将通过 &lt;code&gt;tools()&lt;/code&gt; 方法传递一个 &lt;code&gt;DateTimeTools&lt;/code&gt; 实例，将该工具提供给模型。当模型需要获取当前日期和时间时，它会请求调用该工具。在内部， &lt;code&gt;ChatClient&lt;/code&gt; 将调用该工具并将结果返回给模型，然后模型将使用工具调用结果生成对原始问题的最终响应。&lt;/p&gt;</description>
    </item>
    <item>
      <title>评估测试</title>
      <link>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E8%AF%84%E4%BC%B0%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E8%AF%84%E4%BC%B0%E6%B5%8B%E8%AF%95/</guid>
      <description>&lt;h1 id=&#34;评估测试&#34;&gt;&#xA;  评估测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%84%e4%bc%b0%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;测试人工智能应用程序需要评估生成的内容，以确保人工智能模型没有产生幻觉反应。&lt;/p&gt;&#xA;&lt;p&gt;评估响应结果的一种方法是使用 AI 模型本身进行评估。选择最佳的 AI 模型进行评估，该模型可能与生成响应结果的模型不同。&lt;/p&gt;&#xA;&lt;p&gt;Spring AI 用于评估响应的接口是 &lt;code&gt;Evaluator&lt;/code&gt; ，定义如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@FunctionalInterface&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Evaluator&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    EvaluationResponse &lt;span style=&#34;color:#a6e22e&#34;&gt;evaluate&lt;/span&gt;(EvaluationRequest evaluationRequest);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;评估的输入是 &lt;code&gt;EvaluationRequest&lt;/code&gt; 定义为&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EvaluationRequest&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String userText;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Content&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; dataList;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String responseContent;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EvaluationRequest&lt;/span&gt;(String userText, List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Content&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; dataList, String responseContent) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;userText&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; userText;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dataList&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dataList;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;responseContent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; responseContent;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;userText ：来自用户的原始输入，以 String 形式&lt;/li&gt;&#xA;&lt;li&gt;dataList ：上下文数据，例如来自检索增强生成的数据，附加到原始输入。&lt;/li&gt;&#xA;&lt;li&gt;responseContent ：AI 模型的响应内容（ String&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;相关性评估器&#34;&gt;&#xA;  相关性评估器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%b8%e5%85%b3%e6%80%a7%e8%af%84%e4%bc%b0%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;`Relevancy&lt;code&gt;Evaluator``` 是 &lt;/code&gt;Evaluator`` 接口的一个实现，旨在评估 AI 生成的响应与所提供上下文的相关性。此评估器通过确定 AI 模型的响应是否与用户输入（就检索到的上下文而言）相关，来帮助评估 RAG 流程的质量。&lt;/p&gt;</description>
    </item>
    <item>
      <title>可观察性</title>
      <link>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E5%8F%AF%E8%A7%82%E5%AF%9F%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E5%8F%AF%E8%A7%82%E5%AF%9F%E6%80%A7/</guid>
      <description>&lt;h1 id=&#34;可观察性&#34;&gt;&#xA;  可观察性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e8%a7%82%e5%af%9f%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Spring AI 以 Spring 生态系统中的可观察性功能为基础，提供对 AI 相关操作的洞察。Spring AI 为其核心组件提供了指标和跟踪功能： &lt;code&gt;ChatClient&lt;/code&gt; （包括 &lt;code&gt;Advisor&lt;/code&gt; ）、&#xA;&lt;code&gt;ChatModel&lt;/code&gt; 、 &lt;code&gt;EmbeddingModel&lt;/code&gt; 、 &lt;code&gt;ImageModel&lt;/code&gt; 和 &lt;code&gt;VectorStore&lt;/code&gt; 。&lt;/p&gt;&#xA;&lt;h2 id=&#34;聊天客户端&#34;&gt;&#xA;  聊天客户端&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8a%e5%a4%a9%e5%ae%a2%e6%88%b7%e7%ab%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;当 ChatClient 的 &lt;code&gt;call()&lt;/code&gt; 或 &lt;code&gt;stream()&lt;/code&gt; 操作被调用时， &lt;code&gt;spring.ai.chat.client&lt;/code&gt; 观测值会被记录下来。它们会测量执行调用所花费的时间，并传播相关的跟踪信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;提示内容&#34;&gt;&#xA;  提示内容&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%90%e7%a4%ba%e5%86%85%e5%ae%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;ChatClient&lt;/code&gt; 提示内容通常很大，并且可能包含敏感信息。因此，默认情况下不会导出该内容。&lt;/p&gt;&#xA;&lt;p&gt;Spring AI 支持记录提示内容，以帮助调试和排除故障。&lt;/p&gt;&#xA;&lt;h2 id=&#34;输入数据已弃用&#34;&gt;&#xA;  输入数据（已弃用）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%93%e5%85%a5%e6%95%b0%e6%8d%ae%e5%b7%b2%e5%bc%83%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;ChatClient&lt;/code&gt; 输入数据通常很大，并且可能包含敏感信息。因此，默认情况下不会导出这些数据。&lt;/p&gt;&#xA;&lt;p&gt;Spring AI 支持记录输入数据以帮助调试和故障排除。&lt;/p&gt;&#xA;&lt;h2 id=&#34;聊天客户顾问&#34;&gt;&#xA;  聊天客户顾问&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8a%e5%a4%a9%e5%ae%a2%e6%88%b7%e9%a1%be%e9%97%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;spring.ai.advisor&lt;/code&gt; 观测值会在 advisor 执行时进行记录。它们会测量 advisor 执行的时间（包括内部 advisor 执行的时间），并传播相关的跟踪信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;聊天模型&#34;&gt;&#xA;  聊天模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8a%e5%a4%a9%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;gen_ai.client.operation&lt;/code&gt; 观察值在调用 ChatModel 的 &lt;code&gt;call&lt;/code&gt; 或 &lt;code&gt;stream&lt;/code&gt; 方法时记录。它们测量方法完成所花费的时间并传播相关的跟踪信息。&lt;/p&gt;</description>
    </item>
    <item>
      <title>开发时服务</title>
      <link>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E5%BC%80%E5%8F%91%E6%97%B6%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/%E5%8F%82%E8%80%83/%E5%BC%80%E5%8F%91%E6%97%B6%E6%9C%8D%E5%8A%A1/</guid>
      <description>&lt;h1 id=&#34;开发时服务&#34;&gt;&#xA;  开发时服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%8f%91%e6%97%b6%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Spring AI 提供了 Spring Boot 自动配置，用于建立与通过 Docker Compose 运行的模型服务或向量存储的连接。要启用此功能，请将以下依赖项添加到项目的 Maven &lt;code&gt;pom.xml&lt;/code&gt; 文件中：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.ai&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-ai-spring-boot-docker-compose&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者到你的 Gradle &lt;code&gt;build.gradle&lt;/code&gt; 构建文件。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dependencies &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    implementation &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;org.springframework.ai:spring-ai-spring-boot-docker-compose&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;服务连接&#34;&gt;&#xA;  服务连接&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e8%bf%9e%e6%8e%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;spring-ai-spring-boot-docker-compose&lt;/code&gt; 模块中提供了以下服务连接工厂：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
