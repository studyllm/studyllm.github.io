<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Spring AI 1.0.0</title>
    <link>https://studyllm.github.io/docs/</link>
    <description>Recent content in Docs on Spring AI 1.0.0</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://studyllm.github.io/docs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>开始</title>
      <link>https://studyllm.github.io/docs/getting-started-%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/getting-started-%E5%BC%80%E5%A7%8B/</guid>
      <description>&lt;h1 id=&#34;开始&#34;&gt;&#xA;  开始&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%a7%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;本节提供了如何开始使用 Spring AI 的起点。&#xA;您应该根据需要按照以下每个部分中的步骤进行作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;spring-初始化&#34;&gt;&#xA;  Spring 初始化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;前往 [&#xA;  &lt;a href=&#34;https://start.spring.io/&#34;&gt;start.spring.io&lt;/a&gt;](https://&#xA;  &lt;a href=&#34;https://start.spring.io/&#34;&gt;start.spring.io&lt;/a&gt;/) 并选择要在新应用程序中使用的 AI 模型和矢量存储。&lt;/p&gt;&#xA;&lt;h2 id=&#34;构件存储库&#34;&gt;&#xA;  构件存储库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%84%e4%bb%b6%e5%ad%98%e5%82%a8%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;里程碑---使用-maven-central&#34;&gt;&#xA;  里程碑 - 使用 Maven Central&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%87%8c%e7%a8%8b%e7%a2%91---%e4%bd%bf%e7%94%a8-maven-central&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;从 1.0.0-M6 开始，Maven Central 中提供了版本。无需更改您的构建文件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;快照---添加快照存储库&#34;&gt;&#xA;  快照 - 添加快照存储库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%ab%e7%85%a7---%e6%b7%bb%e5%8a%a0%e5%bf%ab%e7%85%a7%e5%ad%98%e5%82%a8%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;要使用 Snapshot（以及 1.0.0-M6 之前的里程碑）版本，您需要在构建文件中添加以下快照存储库。&#xA;将以下存储库定义添加到您的 Maven 或 Gradle 构建文件中：&#xA;注意： 将 Maven 与 Spring AI 快照一起使用时，请注意您的 Maven 镜像配置。如果您在 &lt;code&gt;settings.xml&lt;/code&gt; 中配置了镜像，如下所示：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;mirror&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;id&amp;gt;&lt;/span&gt;my-mirror&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;mirrorOf&amp;gt;&lt;/span&gt;*&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/mirrorOf&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;url&amp;gt;&lt;/span&gt;https://my-company-repository.com/maven&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/mirror&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通配符 &lt;code&gt;*&lt;/code&gt; 会将所有存储库请求重定向到您的镜像，从而阻止访问 Spring 快照存储库。要解决此问题，请修改 &lt;code&gt;mirrorOf&lt;/code&gt; 配置以排除 Spring 存储库：&lt;/p&gt;</description>
    </item>
    <item>
      <title>提示</title>
      <link>https://studyllm.github.io/docs/prompts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/prompts/</guid>
      <description>&lt;h1 id=&#34;提示&#34;&gt;&#xA;  提示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%90%e7%a4%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;提示是指导 AI 模型生成特定输出的输入。这些提示的设计和措辞会显著影响模型的响应。&#xA;在 Spring AI 中与 AI 模型交互的最低级别上，在 Spring AI 中处理提示有点类似于在 Spring MVC 中管理“视图”。这涉及使用动态内容的占位符创建大量文本。然后，根据用户请求或应用程序中的其他代码替换这些占位符。另一个类比是包含某些表达式的占位符的 SQL 语句。&#xA;随着 Spring AI 的发展，它将引入更高级别的抽象来与 AI 模型交互。本节中描述的基础类在角色和功能方面可以比作 JDBC。例如，&lt;code&gt;ChatModel&lt;/code&gt; 类类似于 JDK 中的核心 JDBC 库。&lt;code&gt;ChatClient&lt;/code&gt; 类可以比作 &lt;code&gt;JdbcClient&lt;/code&gt;，它构建在 &lt;code&gt;ChatModel&lt;/code&gt; 之上，并通过 &lt;code&gt;Advisor&lt;/code&gt; 提供更高级的构造&#xA;要考虑过去与模型的交互，请使用额外的上下文文档来增强提示，并引入代理行为。&#xA;随着时间的推移，提示的结构在 AI 领域内不断发展。最初，提示是简单的字符串。随着时间的推移，它们逐渐包括特定输入的占位符，例如 AI 模型可以识别的“USER：”。OpenAI 通过在 AI 模型处理之前将多个消息字符串分类为不同的角色，为提示引入了更多结构。&lt;/p&gt;&#xA;&lt;h2 id=&#34;api-概述&#34;&gt;&#xA;  API 概述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api-%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;提示-1&#34;&gt;&#xA;  提示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%90%e7%a4%ba-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;通常使用 &lt;code&gt;ChatModel&lt;/code&gt; 的 &lt;code&gt;call（）&lt;/code&gt; 方法，该方法采用 &lt;code&gt;Prompt&lt;/code&gt; 实例并返回 &lt;code&gt;ChatResponse&lt;/code&gt;。&#xA;&lt;code&gt;Prompt&lt;/code&gt; 类充当一系列有组织的 &lt;code&gt;Message&lt;/code&gt; 对象和请求 &lt;code&gt;ChatOptions&lt;/code&gt; 的容器。每条 &lt;code&gt;Message&lt;/code&gt; 在提示中都包含一个独特的角色，其内容和意图不同。这些角色可以包含各种元素，从用户查询到 AI 生成的对相关背景信息的响应。这种安排支持与 AI 模型进行复杂而详细的交互，因为提示是由多条消息构建的，每条消息都分配了在对话中扮演的特定角色。&#xA;下面是 Prompt 类的截断版本，为简洁起见，省略了构造函数和实用程序方法：&lt;/p&gt;</description>
    </item>
    <item>
      <title>结构化输出转换器</title>
      <link>https://studyllm.github.io/docs/structured-output/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/structured-output/</guid>
      <description>&lt;h1 id=&#34;结构化输出转换器&#34;&gt;&#xA;  结构化输出转换器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%84%e5%8c%96%e8%be%93%e5%87%ba%e8%bd%ac%e6%8d%a2%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;LLM 生成结构化输出的能力对于依赖可靠解析输出值的下游应用程序非常重要。开发人员希望将 AI 模型的结果快速转换为数据类型，例如 JSON、XML 或 Java 类，这些数据类型可以传递给其他应用程序函数和方法。&#xA;Spring &lt;code&gt;AI 结构化输出转换器&lt;/code&gt;有助于将 LLM 输出转换为结构化格式。如下图所示，此方法围绕 LLM 文本完成端点运行：&#xA;使用通用完成 API 从大型语言模型 （LLM） 生成结构化输出需要仔细处理输入和输出。结构化输出转换器在 LLM 调用之前和之后起着至关重要的作用，确保实现所需的输出结构。&#xA;在 LLM 调用之前，转换器会将格式说明附加到提示符中，为模型生成所需的输出结构提供明确的指导。这些指令充当蓝图，调整模型的响应以符合指定的格式。&#xA;在 LLM 调用之后，转换器获取模型的输出文本并将其转换为结构化类型的实例。此转换过程包括解析原始文本输出并将其映射到相应的结构化数据表示形式，例如 JSON、XML 或特定于域的数据结构。&lt;/p&gt;&#xA;&lt;h2 id=&#34;结构化输出-api&#34;&gt;&#xA;  结构化输出 API&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%84%e5%8c%96%e8%be%93%e5%87%ba-api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;StructuredOutputConverter&lt;/code&gt; 接口允许您获取结构化输出，例如将输出映射到基于文本的 AI 模型输出中的 Java 类或值数组。接口定义为：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StructuredOutputConverter&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Converter&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String, T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, FormatProvider {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它结合了 Spring [&#xA;  &lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html&#34;&gt;Converter&amp;lt;String、T&amp;gt;&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html&#34;&gt;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html&lt;/a&gt;) 接口和 &lt;code&gt;FormatProvider&lt;/code&gt; 接口&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FormatProvider&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;String &lt;span style=&#34;color:#a6e22e&#34;&gt;getFormat&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下图显示了使用结构化输出 API 时的数据流。&#xA;&#xA;  &lt;img src=&#34;../images/structured-output-api.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;code&gt;FormatProvider&lt;/code&gt; 为 AI 模型提供特定的格式设置准则，使其能够生成文本输出，这些输出可以使用 &lt;code&gt;Converter&lt;/code&gt; 转换为指定的目标类型 &lt;code&gt;T&lt;/code&gt;。以下是此类格式设置说明的示例：&#xA;格式说明通常使用 [&#xA;  &lt;a href=&#34;prompt.html#_prompttemplate&#34;&gt;PromptTemplate&lt;/a&gt;](prompt.html#_prompttemplate) 附加到用户输入的末尾，如下所示：&lt;/p&gt;</description>
    </item>
    <item>
      <title>多模态 API</title>
      <link>https://studyllm.github.io/docs/multimodality/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/multimodality/</guid>
      <description>&lt;h1 id=&#34;多模态-api&#34;&gt;&#xA;  多模态 API&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e6%a8%a1%e6%80%81-api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;人类跨多种数据输入模式同时处理知识。我们的学习方式、我们的体验都是多模式的。我们不仅有视觉，只有音频和文本。&#xA;与这些原则相反，机器学习通常专注于为处理单一模态而量身定制的专用模型。例如，我们为文本转语音或语音转文本等任务开发了音频模型，并为对象检测和分类等任务开发了计算机视觉模型。&#xA;然而，新一波多模态大型语言模型开始出现。示例包括 OpenAI 的 GPT-4o、Google 的 Vertex AI Gemini 1.5、Anthropic 的 Claude3 以及开源产品 Llama3.2、LLaVA 和 BakLLaVA 能够接受多个输入，包括文本图像、音频和视频，并通过集成这些输入来生成文本响应。&lt;/p&gt;&#xA;&lt;h2 id=&#34;spring-ai-多模态&#34;&gt;&#xA;  Spring AI 多模态&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-ai-%e5%a4%9a%e6%a8%a1%e6%80%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;多模态是指模型同时理解和处理来自各种来源的信息（包括文本、图像、音频和其他数据格式）的能力。&#xA;Spring AI 消息 API 提供了支持多模态 LLM 的所有必要抽象。&#xA;&#xA;  &lt;img src=&#34;../images/spring-ai-message-api.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;code&gt;U&lt;/code&gt;s&lt;code&gt;e&lt;/code&gt;r&lt;code&gt;M&lt;/code&gt;e&lt;code&gt;s&lt;/code&gt;s&lt;code&gt;a&lt;/code&gt;g&lt;code&gt;e&lt;/code&gt; &lt;code&gt; &lt;/code&gt;的&lt;code&gt; `````c&lt;/code&gt;o&lt;code&gt;n&lt;/code&gt;t&lt;code&gt;e&lt;/code&gt;n&lt;code&gt;t````` &lt;/code&gt;字&lt;code&gt;段&lt;/code&gt;主&lt;code&gt;要&lt;/code&gt;用&lt;code&gt;于&lt;/code&gt;文&lt;code&gt;本&lt;/code&gt;输&lt;code&gt;入&lt;/code&gt;，&lt;code&gt;而&lt;/code&gt;可&lt;code&gt;选&lt;/code&gt;的&lt;code&gt; ````````m&lt;/code&gt;e&lt;code&gt;d&lt;/code&gt;i&lt;code&gt;a```````` &lt;/code&gt;字&lt;code&gt;段&lt;/code&gt;允&lt;code&gt;许&lt;/code&gt;添&lt;code&gt;加&lt;/code&gt;一&lt;code&gt;个&lt;/code&gt;或&lt;code&gt;多&lt;/code&gt;个&lt;code&gt;不&lt;/code&gt;同&lt;code&gt;形&lt;/code&gt;式&lt;code&gt;的&lt;/code&gt;其&lt;code&gt;他&lt;/code&gt;内&lt;code&gt;容&lt;/code&gt;，&lt;code&gt;例&lt;/code&gt;如&lt;code&gt;图&lt;/code&gt;像&lt;code&gt;、&lt;/code&gt;音&lt;code&gt;频&lt;/code&gt;和&lt;code&gt;视&lt;/code&gt;频&lt;code&gt;。````````M&lt;/code&gt;i&lt;code&gt;m&lt;/code&gt;e&lt;code&gt;T&lt;/code&gt;y&lt;code&gt;p&lt;/code&gt;e```````` &lt;code&gt;指&lt;/code&gt;定&lt;code&gt;模&lt;/code&gt;态&lt;code&gt;类&lt;/code&gt;型&lt;code&gt;。&lt;/code&gt;根&lt;code&gt;据&lt;/code&gt;使&lt;code&gt;用&lt;/code&gt;的&lt;code&gt; &lt;/code&gt;L&lt;code&gt;L&lt;/code&gt;M&lt;code&gt;，`````M&lt;/code&gt;e&lt;code&gt;d&lt;/code&gt;i&lt;code&gt;a````` &lt;/code&gt;d&lt;code&gt;a&lt;/code&gt;t&lt;code&gt;a&lt;/code&gt; &lt;code&gt;字&lt;/code&gt;段&lt;code&gt;可&lt;/code&gt;以&lt;code&gt;是&lt;/code&gt;作&lt;code&gt;为&lt;/code&gt; &lt;code&gt;R``e``s``o``u``r``c``e&lt;/code&gt; &lt;code&gt;对&lt;/code&gt;象&lt;code&gt;的&lt;/code&gt;原&lt;code&gt;始&lt;/code&gt;媒&lt;code&gt;体&lt;/code&gt;内&lt;code&gt;容&lt;/code&gt;，&lt;code&gt;也&lt;/code&gt;可&lt;code&gt;以&lt;/code&gt;是&lt;code&gt;内&lt;/code&gt;容&lt;code&gt;的&lt;/code&gt; &lt;code&gt;U``R``I&lt;/code&gt;。&lt;code&gt; 例如，我们可以将下面的图片 （&lt;/code&gt;multimodal.test.png``） 作为输入，并要求 LLM 解释它所看到的内容。&#xA;&#xA;  &lt;img src=&#34;../images/multimodal.test.png&#34; alt=&#34;&#34; /&gt;&#xA;对于大多数多模态 LLM，Spring AI 代码将如下所示：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; imageResource &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ClassPathResource(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/multimodal.test.png&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; userMessage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; UserMessage(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Explain what do you see in this picture?&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// content&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Media(MimeTypeUtils.&lt;span style=&#34;color:#a6e22e&#34;&gt;IMAGE_PNG&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;imageResource&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// media&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ChatResponse response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chatModel.&lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Prompt(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;userMessage&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或使用 Fluent [&#xA;  &lt;a href=&#34;chatclient.html&#34;&gt;ChatClient&lt;/a&gt;](chatclient.html) API：&lt;/p&gt;</description>
    </item>
    <item>
      <title>聊天记忆</title>
      <link>https://studyllm.github.io/docs/chat-memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/chat-memory/</guid>
      <description>&lt;h1 id=&#34;聊天记忆&#34;&gt;&#xA;  聊天记忆&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8a%e5%a4%a9%e8%ae%b0%e5%bf%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;大型语言模型 （LLM） 是无状态的，这意味着它们不会保留有关以前交互的信息。当您希望在多个交互中维护上下文或状态时，这可能是一个限制。为了解决这个问题，Spring AI 提供了聊天内存功能，允许您在与 LLM 的多次交互中存储和检索信息。&#xA;&lt;code&gt;ChatMemory&lt;/code&gt; 抽象允许您实现各种类型的内存以支持不同的使用案例。消息的底层存储由 &lt;code&gt;ChatMemory&lt;/code&gt;Repository 处理，其唯一职责是存储和检索消息。由 &lt;code&gt;ChatMemory&lt;/code&gt; 实现决定要保留哪些消息以及何时删除它们。策略示例可能包括保留最后 N 条消息、将消息保留一段时间或将消息保持在某个令牌限制内。&#xA;在选择内存类型之前，必须了解聊天内存和聊天记录之间的区别。&#xA;&lt;code&gt;ChatMemory&lt;/code&gt; 抽象旨在管理聊天内存 。它允许您存储和检索与当前对话上下文相关的消息。但是，它并不是存储聊天记录的最佳选择。如果您需要维护所有交换消息的完整记录，您应该考虑使用不同的方法，例如依靠 Spring Data 来有效存储和检索完整的聊天历史记录。&lt;/p&gt;&#xA;&lt;h2 id=&#34;快速开始&#34;&gt;&#xA;  快速开始&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%ab%e9%80%9f%e5%bc%80%e5%a7%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Spring AI 会自动配置一个 &lt;code&gt;ChatMemory&lt;/code&gt; bean，您可以直接在应用程序中使用。默认情况下，它使用内存存储库来存储消息 （InMemory&lt;code&gt;ChatMemory&lt;/code&gt;Repository），并使用 MessageWindow&lt;code&gt;ChatMemory&lt;/code&gt; 实现来管理对话历史记录。如果已经配置了不同的存储库（例如，Cassandra、JDBC 或 Neo4j），Spring AI 将改用该存储库。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Autowired&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ChatMemory chatMemory;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下部分将进一步描述 Spring AI 中可用的不同内存类型和存储库。&lt;/p&gt;&#xA;&lt;h2 id=&#34;内存类型&#34;&gt;&#xA;  内存类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;ChatMemory&lt;/code&gt; 抽象允许您实现各种类型的内存以适应不同的用例。内存类型的选择会显著影响应用程序的性能和行为。本节介绍了 Spring AI 提供的内置内存类型及其特性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;消息窗口聊天内存&#34;&gt;&#xA;  消息窗口聊天内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b6%88%e6%81%af%e7%aa%97%e5%8f%a3%e8%81%8a%e5%a4%a9%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;MessageWindowChatMemory&lt;/code&gt; 将消息窗口维护到指定的最大大小。当消息数超过最大值时，将删除较旧的消息，同时保留系统消息。默认窗口大小为 20 封邮件。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MessageWindowChatMemory memory &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MessageWindowChatMemory.&lt;span style=&#34;color:#a6e22e&#34;&gt;builder&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;maxMessages&lt;/span&gt;(10)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是 Spring AI 用于自动配置 &lt;code&gt;ChatMemory&lt;/code&gt; bean 的默认消息类型。&lt;/p&gt;</description>
    </item>
    <item>
      <title>工具调用</title>
      <link>https://studyllm.github.io/docs/tool-calling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/tool-calling/</guid>
      <description>&lt;h1 id=&#34;工具调用&#34;&gt;&#xA;  工具调用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7%e8%b0%83%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;工具调用 （也称为函数调用 ）是 AI 应用程序中的一种常见模式，允许模型与一组 API 或工具进行交互，从而增强其功能。&#xA;工具主要用于：&#xA;尽管我们通常将工具调用称为模型功能，但实际上由客户端应用程序提供工具调用逻辑。模型只能请求工具调用并提供输入参数，而应用程序负责从输入参数执行工具调用并返回结果。该模型永远无法访问作为工具提供的任何 API，这是一个关键的安全考虑因素。&#xA;Spring AI 提供了方便的 API 来定义工具、解决来自模型的工具调用请求以及执行工具调用。以下部分概述了 Spring AI 中的工具调用功能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;快速开始&#34;&gt;&#xA;  快速开始&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%ab%e9%80%9f%e5%bc%80%e5%a7%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;让我们看看如何在 Spring AI 中开始使用工具调用。我们将实现两个简单的工具：一个用于信息检索，一个用于采取行动。信息检索工具将用于获取用户所在时区的当前日期和时间。作工具将用于设置指定时间的闹钟。&lt;/p&gt;&#xA;&lt;h2 id=&#34;信息检索&#34;&gt;&#xA;  信息检索&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%a1%e6%81%af%e6%a3%80%e7%b4%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;AI 模型无法访问实时信息。模型无法回答任何假设了解信息（如当前日期或天气预报）的问题。但是，我们可以提供一个可以检索此信息的工具，并让模型在需要访问实时信息时调用此工具。&#xA;让我们在 &lt;code&gt;DateTimeTools&lt;/code&gt; 类中实现一个工具来获取用户时区的当前日期和时间。该工具将不接受任何参数。Spring Framework 的 &lt;code&gt;LocaleContextHolder&lt;/code&gt; 可以提供用户的时区。该工具将被定义为带有 &lt;code&gt;@Tool&lt;/code&gt; 注释的方法。为了帮助模型了解是否以及何时调用此工具，我们将提供这些工具的作用的详细说明。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.time.LocalDateTime;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.ai.tool.annotation.Tool;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.context.i18n.LocaleContextHolder;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DateTimeTools&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Tool&lt;/span&gt;(description &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Get the current date and time in the user&amp;#39;s timezone&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String &lt;span style=&#34;color:#a6e22e&#34;&gt;getCurrentDateTime&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; LocalDateTime.&lt;span style=&#34;color:#a6e22e&#34;&gt;now&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;atZone&lt;/span&gt;(LocaleContextHolder.&lt;span style=&#34;color:#a6e22e&#34;&gt;getTimeZone&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;toZoneId&lt;/span&gt;()).&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，让我们使该工具可用于模型。在此示例中，我们将使用 &lt;code&gt;ChatClient&lt;/code&gt; 与模型交互。我们将通过 &lt;code&gt;tools（）&lt;/code&gt; 方法传递 &lt;code&gt;DateTimeTools&lt;/code&gt; 的实例，从而为模型提供该工具。当模型需要知道当前日期和时间时，它将请求调用该工具。在内部，&lt;code&gt;ChatClient&lt;/code&gt; 将调用该工具并将结果返回给模型，然后模型将使用工具调用结果生成对原始问题的最终响应。&lt;/p&gt;</description>
    </item>
    <item>
      <title>评估测试</title>
      <link>https://studyllm.github.io/docs/model-evaluation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/model-evaluation/</guid>
      <description>&lt;h1 id=&#34;评估测试&#34;&gt;&#xA;  评估测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%84%e4%bc%b0%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;测试 AI 应用程序需要评估生成的内容，以确保 AI 模型没有产生幻觉响应。&#xA;评估响应的一种方法是使用 AI 模型本身进行评估。选择最佳 AI 模型进行评估，该模型可能与用于生成响应的模型不同。&#xA;用于评估响应的 Spring AI 接口是 &lt;code&gt;Evaluator&lt;/code&gt;，定义为：&#xA;评估的输入是 &lt;code&gt;EvaluationRequest&lt;/code&gt;，定义为&lt;/p&gt;&#xA;&lt;h2 id=&#34;相关性评估器&#34;&gt;&#xA;  相关性评估器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%b8%e5%85%b3%e6%80%a7%e8%af%84%e4%bc%b0%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;`Relevancy&lt;code&gt;Evaluator``` 是 &lt;/code&gt;Evaluator&lt;code&gt;接口的一种实现，旨在评估 AI 生成的响应与提供的上下文的相关性。此评估器通过确定 AI 模型的响应是否与用户对检索到的上下文的输入相关，帮助评估 RAG 流的质量。 评估基于用户输入、AI 模型的响应和上下文信息。它使用提示模板询问 AI 模型响应是否与用户输入和上下文相关。 这是&lt;/code&gt;RelevancyEvaluator`` 使用的默认提示模板：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Your task is to evaluate if the response for the query&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;is in line with the context information provided.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;You have two options to answer. Either YES or NO.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Answer YES, if the response for the query&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;is in line with context information otherwise NO.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Query:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{query}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Response:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{response}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Context:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{context}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Answer:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;集成测试中的使用&#34;&gt;&#xA;  集成测试中的使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9b%86%e6%88%90%e6%b5%8b%e8%af%95%e4%b8%ad%e7%9a%84%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;以下是在集成测试中使用 &lt;code&gt;RelevancyEvaluator&lt;/code&gt; 的示例，使用 &lt;code&gt;RetrievalAugmentationAdvisor&lt;/code&gt; 验证 RAG 流的结果：&lt;/p&gt;</description>
    </item>
    <item>
      <title>可观察性</title>
      <link>https://studyllm.github.io/docs/observability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/observability/</guid>
      <description>&lt;h1 id=&#34;可观察性&#34;&gt;&#xA;  可观察性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e8%a7%82%e5%af%9f%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Spring AI 基于 Spring 生态系统中的可观察性功能构建，以提供对 AI 相关作的见解。Spring AI 为其核心组件提供指标和跟踪功能：&lt;code&gt;ChatClient&lt;/code&gt;（包括 &lt;code&gt;Advisor&lt;/code&gt;）、&#xA;&lt;code&gt;ChatModel&lt;/code&gt;、&lt;code&gt;EmbeddingModel&lt;/code&gt;、&lt;code&gt;ImageModel&lt;/code&gt; 和 &lt;code&gt;VectorStore&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;聊天客户端&#34;&gt;&#xA;  聊天客户端&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8a%e5%a4%a9%e5%ae%a2%e6%88%b7%e7%ab%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;spring.ai.chat.client&lt;/code&gt; 在调用 ChatClient &lt;code&gt;调用（）&lt;/code&gt; 或 &lt;code&gt;stream（）&lt;/code&gt; 作时记录观察结果。它们测量执行调用所花费的时间并传播相关的跟踪信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;提示内容&#34;&gt;&#xA;  提示内容&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%90%e7%a4%ba%e5%86%85%e5%ae%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;ChatClient&lt;/code&gt; 提示内容通常很大，并且可能包含敏感信息。由于这些原因，默认情况下不会导出它。&#xA;Spring AI 支持记录提示内容以帮助进行调试和故障排除。&lt;/p&gt;&#xA;&lt;h2 id=&#34;输入数据-已弃用&#34;&gt;&#xA;  输入数据 （已弃用）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%93%e5%85%a5%e6%95%b0%e6%8d%ae-%e5%b7%b2%e5%bc%83%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;ChatClient&lt;/code&gt; 输入数据通常很大，并且可能包含敏感信息。由于这些原因，默认情况下不会导出它。&#xA;Spring AI 支持记录 Importing 数据以帮助进行调试和故障排除。&lt;/p&gt;&#xA;&lt;h2 id=&#34;聊天客户顾问&#34;&gt;&#xA;  聊天客户顾问&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8a%e5%a4%a9%e5%ae%a2%e6%88%b7%e9%a1%be%e9%97%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;spring.ai.advisor&lt;/code&gt; 观察值在执行 advisor 时记录。它们测量在 advisor 中花费的时间（包括在内部 advisor 上花费的时间）并传播相关的跟踪信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;聊天模型&#34;&gt;&#xA;  聊天模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8a%e5%a4%a9%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;gen_ai.client.operation&lt;/code&gt; 的观察结果是在调用 ChatModel &lt;code&gt;call&lt;/code&gt; 或 &lt;code&gt;stream&lt;/code&gt; 方法时记录的。它们测量方法完成所花费的时间并传播相关的跟踪信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;聊天提示和完成数据&#34;&gt;&#xA;  聊天提示和完成数据&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8a%e5%a4%a9%e6%8f%90%e7%a4%ba%e5%92%8c%e5%ae%8c%e6%88%90%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;聊天提示和完成数据通常很大，并且可能包含敏感信息。由于这些原因，默认情况下不会导出它。&#xA;Spring AI 支持记录聊天提示和完成数据，这对于故障排除场景非常有用。当跟踪可用时，日志将包含跟踪信息，以便更好地关联。&lt;/p&gt;</description>
    </item>
    <item>
      <title>None</title>
      <link>https://studyllm.github.io/docs/development-time-services/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/development-time-services/</guid>
      <description>&lt;h1 id=&#34;none&#34;&gt;&#xA;  None&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#none&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Spring AI 提供了 Spring Boot 自动配置，用于建立与通过 Docker Compose 运行的模型服务或矢量存储的连接。要启用它，请将以下依赖项添加到项目的 Maven &lt;code&gt;pom.xml&lt;/code&gt; 文件中：&#xA;或您的 Gradle &lt;code&gt;build.gradle&lt;/code&gt; 构建文件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;服务连接&#34;&gt;&#xA;  服务连接&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e8%bf%9e%e6%8e%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;该 &lt;code&gt;spring-ai-spring-boot-docker-compose&lt;/code&gt; 模块中提供了以下服务连接工厂：&lt;/p&gt;</description>
    </item>
    <item>
      <title>提示工程模式</title>
      <link>https://studyllm.github.io/docs/prompt-engineering-patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/prompt-engineering-patterns/</guid>
      <description>&lt;h1 id=&#34;提示工程模式&#34;&gt;&#xA;  提示工程模式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%90%e7%a4%ba%e5%b7%a5%e7%a8%8b%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;基于全面的 [&#xA;  &lt;a href=&#34;https://www.kaggle.com/whitepaper-prompt-engineering&#34;&gt;Prompt Engineering Guide&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://www.kaggle.com/whitepaper-prompt-engineering&#34;&gt;https://www.kaggle.com/whitepaper-prompt-engineering&lt;/a&gt;) 的 Prompt Engineering 技术的实际实施。该指南涵盖了有效提示工程的理论、原则和模式，而在这里，我们演示了如何使用 Spring AI 的 Fluent [&#xA;  &lt;a href=&#34;../chatclient.html&#34;&gt;ChatClient API&lt;/a&gt;](../chatclient.html) 将这些概念转换为有效的 Java 代码。本文中使用的演示源代码可在以下网址获得：[&#xA;  &lt;a href=&#34;https://github.com/spring-projects/spring-ai-examples/tree/main/prompt-engineering/prompt-engineering-patterns&#34;&gt;Prompt Engineering Patterns Examples&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://github.com/spring-projects/spring-ai-examples/tree/main/prompt-engineering/prompt-engineering-patterns&#34;&gt;https://github.com/spring-projects/spring-ai-examples/tree/main/prompt-engineering/prompt-engineering-patterns&lt;/a&gt;)。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-配置&#34;&gt;&#xA;  1. 配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;配置部分概述了如何使用 Spring AI 设置和调整大型语言模型 （LLM）。它涵盖了为您的使用案例选择合适的 LLM 提供程序，以及配置控制模型输出的质量、样式和格式的重要生成参数。&lt;/p&gt;&#xA;&lt;h2 id=&#34;llm-提供商选择&#34;&gt;&#xA;  LLM 提供商选择&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#llm-%e6%8f%90%e4%be%9b%e5%95%86%e9%80%89%e6%8b%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;对于快速工程，您将首先选择一个模型。Spring AI 支持[&#xA;  &lt;a href=&#34;comparison.html&#34;&gt;多个 LLM 提供程序&lt;/a&gt;](comparison.html) （例如 OpenAI、Anthropic、Google Vertex AI、AWS Bedrock、Ollama 等），让您无需更改应用程序代码即可切换提供程序 - 只需更新配置即可。只需添加选定的 starter dependency &lt;code&gt;spring-ai-starter-model-&amp;lt;MODEL-PROVIDER-NAME&amp;gt;&lt;/code&gt; .例如，以下是启用 Anthropic Claude API 的方法：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.ai&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-ai-starter-model-anthropic&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以指定 LLM 模型名称，如下所示：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;options&lt;/span&gt;(ChatOptions.&lt;span style=&#34;color:#a6e22e&#34;&gt;builder&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .&lt;span style=&#34;color:#a6e22e&#34;&gt;model&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;claude-3-7-sonnet-latest&amp;#34;&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;// Use Anthropic&amp;#39;s Claude model&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在[&#xA;  &lt;a href=&#34;../chatmodel.html&#34;&gt;参考文档中&lt;/a&gt;](../chatmodel.html)查找有关启用每个模型的详细信息。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://studyllm.github.io/docs/building-effective-agents/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/building-effective-agents/</guid>
      <description>&lt;h1 id=&#34;&#34;&gt;&#xA;  &#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;代理系统&#34;&gt;&#xA;  代理系统&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%90%86%e7%b3%bb%e7%bb%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;该研究出版物对两种类型的代理系统进行了重要的架构区分：&#xA;关键的见解是，虽然完全自主的代理看起来很有吸引力，但工作流通常为定义明确的任务提供更好的可预测性和一致性。这与可靠性和可维护性至关重要的企业要求完全一致。&#xA;让我们看看 Spring AI 如何通过五种基本模式来实现这些概念，每种模式都服务于特定的用例：&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-chain-工作流程&#34;&gt;&#xA;  1. Chain 工作流程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-chain-%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Chain Workflow 模式体现了将复杂任务分解为更简单、更易于管理的步骤的原则。&#xA;&#xA;  &lt;img src=&#34;https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F7418719e3dab222dccb379b8879e1dc08ad34c78-2401x1000.png&amp;amp;w=3840&amp;amp;q=75&#34; alt=&#34;&#34; /&gt;&#xA;何时使用：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具有明确顺序步骤的任务&lt;/li&gt;&#xA;&lt;li&gt;当您想用延迟换取更高的准确性时&lt;/li&gt;&#xA;&lt;li&gt;当每个步骤都基于上一步的输出时&#xA;以下是 Spring AI 实现中的一个实际示例：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ChainWorkflow&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; ChatClient chatClient;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; systemPrompts;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;chain&lt;/span&gt;(String userInput) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; userInput;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (String prompt : systemPrompts) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            String input &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String.&lt;span style=&#34;color:#a6e22e&#34;&gt;format&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{%s}\n {%s}&amp;#34;&lt;/span&gt;, prompt, response);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chatClient.&lt;span style=&#34;color:#a6e22e&#34;&gt;prompt&lt;/span&gt;(input).&lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; response;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此实现演示了几个关键原则：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个步骤都有重点&lt;/li&gt;&#xA;&lt;li&gt;一个步骤的输出成为下一个步骤的输入&lt;/li&gt;&#xA;&lt;li&gt;该链易于扩展和维护&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2--并行化工作流程&#34;&gt;&#xA;  2.  并行化工作流程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2--%e5%b9%b6%e8%a1%8c%e5%8c%96%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;LLM 可以同时处理任务，并以编程方式聚合其输出。&#xA;&#xA;  &lt;img src=&#34;https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F406bb032ca007fd1624f261af717d70e6ca86286-2401x1000.png&amp;amp;w=3840&amp;amp;q=75&#34; alt=&#34;&#34; /&gt;&#xA;何时使用：&lt;/p&gt;</description>
    </item>
    <item>
      <title>云绑定</title>
      <link>https://studyllm.github.io/docs/deploying-to-the-cloud/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/deploying-to-the-cloud/</guid>
      <description>&lt;h1 id=&#34;云绑定&#34;&gt;&#xA;  云绑定&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%91%e7%bb%91%e5%ae%9a&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Spring AI 基于 [&#xA;  &lt;a href=&#34;https://github.com/spring-cloud/spring-cloud-bindings&#34;&gt;spring-cloud-bindings&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://github.com/spring-cloud/[spring-cloud-bindings]%28https://github.com/spring-cloud/spring-cloud-bindings%29&#34;&gt;https://github.com/spring-cloud/[spring-cloud-bindings](https://github.com/spring-cloud/spring-cloud-bindings)&lt;/a&gt;) 中的基础提供对云绑定的支持。这允许应用程序为提供程序指定绑定类型，然后使用泛型格式表示属性。spring-ai 云绑定将处理这些属性并将它们绑定到 spring-ai 本机属性。&#xA;例如，使用 &lt;code&gt;OpenAi&lt;/code&gt; 时，绑定类型为 &lt;code&gt;openai&lt;/code&gt;。使用属性 spring.ai.cloud.bindings.&lt;code&gt;openai&lt;/code&gt;.enabled ，可以启用或禁用绑定处理器。默认情况下，在指定绑定类型时，将启用此属性。可以指定 &lt;code&gt;api-key&lt;/code&gt;、&lt;code&gt;uri&lt;/code&gt;、 &lt;code&gt;用户名&lt;/code&gt; 、 &lt;code&gt;密码&lt;/code&gt;等的配置，spring-ai 会将它们映射到受支持系统中的相应属性。&#xA;要启用云绑定支持，请在应用程序中包括以下依赖项。&#xA;或您的 Gradle &lt;code&gt;build.gradle&lt;/code&gt; 构建文件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;可用的-cloud-bindings&#34;&gt;&#xA;  可用的 Cloud Bindings&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e7%94%a8%e7%9a%84-cloud-bindings&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;以下是 &lt;code&gt;spring-ai-spring-clou-bindings&lt;/code&gt; 模块中当前提供云绑定支持的组件：&lt;/p&gt;</description>
    </item>
    <item>
      <title>测试容器</title>
      <link>https://studyllm.github.io/docs/testcontainers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/testcontainers/</guid>
      <description>&lt;h1 id=&#34;测试容器&#34;&gt;&#xA;  测试容器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95%e5%ae%b9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Spring AI 提供了 Spring Boot 自动配置，用于建立与通过 Testcontainers 运行的模型服务或矢量存储的连接。要启用它，请将以下依赖项添加到项目的 Maven &lt;code&gt;pom.xml&lt;/code&gt; 文件中：&#xA;或您的 Gradle &lt;code&gt;build.gradle&lt;/code&gt; 构建文件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;服务连接&#34;&gt;&#xA;  服务连接&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e8%bf%9e%e6%8e%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;该 &lt;code&gt;spring-ai-spring-boot-testcontainers&lt;/code&gt; 模块中提供了以下服务连接工厂：&lt;/p&gt;</description>
    </item>
    <item>
      <title>OCI GenAI Cohere 聊天</title>
      <link>https://studyllm.github.io/docs/cohere/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/cohere/</guid>
      <description>&lt;h1 id=&#34;oci-genai-cohere-聊天&#34;&gt;&#xA;  OCI GenAI Cohere 聊天&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#oci-genai-cohere-%e8%81%8a%e5%a4%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;[&#xA;  &lt;a href=&#34;https://www.oracle.com/artificial-intelligence/generative-ai/generative-ai-service/&#34;&gt;OCI GenAI 服务&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://www.oracle.com/artificial-intelligence/generative-ai/generative-ai-service/&#34;&gt;https://www.oracle.com/artificial-intelligence/generative-ai/generative-ai-service/&lt;/a&gt;)提供与按需模型或专用 AI 集群的生成式 AI 聊天。&#xA;[&#xA;  &lt;a href=&#34;https://docs.oracle.com/en-us/iaas/Content/generative-ai/chat-models.htm&#34;&gt;OCI 聊天模型页面&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://docs.oracle.com/en-us/iaas/Content/generative-ai/chat-models.htm&#34;&gt;https://docs.oracle.com/en-us/iaas/Content/generative-ai/chat-models.htm&lt;/a&gt;)和 [&#xA;  &lt;a href=&#34;https://docs.oracle.com/en-us/iaas/Content/generative-ai/use-playground-embed.htm&#34;&gt;OCI 生成式 AI 游乐场&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://docs.oracle.com/en-us/iaas/Content/generative-ai/use-playground-embed.htm&#34;&gt;https://docs.oracle.com/en-us/iaas/Content/generative-ai/use-playground-embed.htm&lt;/a&gt;)提供了有关在 OCI 上使用和托管聊天模型的详细信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;先决条件&#34;&gt;&#xA;  先决条件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%88%e5%86%b3%e6%9d%a1%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;您需要一个有效的 [&#xA;  &lt;a href=&#34;https://signup.oraclecloud.com/&#34;&gt;Oracle Cloud Infrastructure （OCI）&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://signup.oraclecloud.com/&#34;&gt;https://signup.oraclecloud.com/&lt;/a&gt;) 账户才能使用 OCI GenAI Cohere Chat 客户端。客户端提供四种不同的连接方式，包括使用用户和私钥进行简单验证、工作负载身份、实例主体或 OCI 配置文件验证。&lt;/p&gt;&#xA;&lt;h2 id=&#34;添加存储库和-bom&#34;&gt;&#xA;  添加存储库和 BOM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%bb%e5%8a%a0%e5%ad%98%e5%82%a8%e5%ba%93%e5%92%8c-bom&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Spring AI 工件发布在 Maven Central 和 Spring Snapshot 存储库中。请参阅 [&#xA;  &lt;a href=&#34;../../../getting-started.html#artifact-repositories&#34;&gt;Artifact Repositories&lt;/a&gt;](../../../getting-started.html#artifact-repositories) 部分，将这些存储库添加到您的构建系统中。&#xA;为了帮助进行[&#xA;  &lt;a href=&#34;../../../getting-started.html#dependency-management&#34;&gt;依赖项管理&lt;/a&gt;](../../../getting-started.html#dependency-management)，Spring AI 提供了一个 BOM（物料清单），以确保在整个项目中使用一致的 Spring AI 版本。请参阅[&#xA;  &lt;a href=&#34;../../../getting-started.html#dependency-management&#34;&gt;依赖项管理&lt;/a&gt;](../../../getting-started.html#dependency-management)部分，将 Spring AI BOM 添加到您的构建系统中。&lt;/p&gt;&#xA;&lt;h2 id=&#34;自动配置&#34;&gt;&#xA;  自动配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%8a%a8%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Spring AI 为 OCI GenAI Cohere 聊天客户端提供 Spring Boot 自动配置。要启用它，请将以下依赖项添加到项目的 Maven &lt;code&gt;pom.xml&lt;/code&gt; 文件中：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Google VertexAI 文本嵌入</title>
      <link>https://studyllm.github.io/docs/text-embedding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/text-embedding/</guid>
      <description>&lt;h1 id=&#34;google-vertexai-文本嵌入&#34;&gt;&#xA;  Google VertexAI 文本嵌入&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#google-vertexai-%e6%96%87%e6%9c%ac%e5%b5%8c%e5%85%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Vertex AI 支持两种类型的嵌入：文本模型和多模态。本文档介绍如何使用 Vertex AI  [&#xA;  &lt;a href=&#34;https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/text-embeddings-api&#34;&gt;文本嵌入 API&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/text-embeddings-api&#34;&gt;https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/text-embeddings-api&lt;/a&gt;) 创建文本嵌入。&#xA;Vertex AI 文本嵌入 API 使用密集的矢量表示形式。与倾向于直接将单词映射到数字的稀疏向量不同，密集向量旨在更好地表示一段文本的含义。在生成式 AI 中使用密集向量嵌入的好处是，您可以更好地搜索与查询含义一致的段落，而不是直接搜索单词或语法匹配，即使这些段落没有使用相同的语言。&lt;/p&gt;&#xA;&lt;h2 id=&#34;先决条件&#34;&gt;&#xA;  先决条件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%88%e5%86%b3%e6%9d%a1%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;安装适合您作系统的 gcloud CLI。&lt;/li&gt;&#xA;&lt;li&gt;通过运行以下命令进行身份验证。将 PROJECT_ID 替换为您的 Google Cloud 项目 ID，将 ACCOUNT 替换为您的 Google Cloud 用户名。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gcloud config set project &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PROJECT_ID&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gcloud auth application&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; login &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ACCOUNT&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;添加存储库和-bom&#34;&gt;&#xA;  添加存储库和 BOM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%bb%e5%8a%a0%e5%ad%98%e5%82%a8%e5%ba%93%e5%92%8c-bom&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Spring AI 工件发布在 Maven Central 和 Spring Snapshot 存储库中。请参阅 [&#xA;  &lt;a href=&#34;../../getting-started.html#artifact-repositories&#34;&gt;Artifact Repositories&lt;/a&gt;](../../getting-started.html#artifact-repositories) 部分，将这些存储库添加到您的构建系统中。&#xA;为了帮助进行[&#xA;  &lt;a href=&#34;../../getting-started.html#dependency-management&#34;&gt;依赖项管理&lt;/a&gt;](../../getting-started.html#dependency-management)，Spring AI 提供了一个 BOM（物料清单），以确保在整个项目中使用一致的 Spring AI 版本。请参阅[&#xA;  &lt;a href=&#34;../../getting-started.html#dependency-management&#34;&gt;依赖项管理&lt;/a&gt;](../../getting-started.html#dependency-management)部分，将 Spring AI BOM 添加到您的构建系统中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Google VertexAI 多模态嵌入</title>
      <link>https://studyllm.github.io/docs/multimodal-embedding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/multimodal-embedding/</guid>
      <description>&lt;h1 id=&#34;google-vertexai-多模态嵌入&#34;&gt;&#xA;  Google VertexAI 多模态嵌入&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#google-vertexai-%e5%a4%9a%e6%a8%a1%e6%80%81%e5%b5%8c%e5%85%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Vertex AI 支持两种类型的嵌入：文本模型和多模态。本文档介绍如何使用 Vertex AI  [&#xA;  &lt;a href=&#34;https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-multimodal-embeddings&#34;&gt;多模态嵌入 API&lt;/a&gt;](&#xA;  &lt;a href=&#34;https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-multimodal-embeddings&#34;&gt;https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-multimodal-embeddings&lt;/a&gt;) 创建多模态嵌入。&#xA;多模态嵌入模型根据您提供的输入生成 1408 维向量，其中可以包括图像、文本和视频数据的组合。然后，嵌入向量可用于后续任务，如图像分类或视频内容审核。&#xA;图像嵌入向量和文本嵌入向量位于同一语义空间内，具有相同的维度。因此，这些向量可以互换用于逐个文本搜索或逐个搜索视频等使用案例。&lt;/p&gt;&#xA;&lt;h2 id=&#34;先决条件&#34;&gt;&#xA;  先决条件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%88%e5%86%b3%e6%9d%a1%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;安装适合您作系统的 gcloud CLI。&lt;/li&gt;&#xA;&lt;li&gt;通过运行以下命令进行身份验证。将 PROJECT_ID 替换为您的 Google Cloud 项目 ID，将 ACCOUNT 替换为您的 Google Cloud 用户名。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gcloud config set project &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PROJECT_ID&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gcloud auth application&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; login &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ACCOUNT&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;添加存储库和-bom&#34;&gt;&#xA;  添加存储库和 BOM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%bb%e5%8a%a0%e5%ad%98%e5%82%a8%e5%ba%93%e5%92%8c-bom&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Spring AI 工件发布在 Maven Central 和 Spring Snapshot 存储库中。请参阅 [&#xA;  &lt;a href=&#34;../../getting-started.html#artifact-repositories&#34;&gt;Artifact Repositories&lt;/a&gt;](../../getting-started.html#artifact-repositories) 部分，将这些存储库添加到您的构建系统中。&#xA;为了帮助进行[&#xA;  &lt;a href=&#34;../../getting-started.html#dependency-management&#34;&gt;依赖项管理&lt;/a&gt;](../../getting-started.html#dependency-management)，Spring AI 提供了一个 BOM（物料清单），以确保在整个项目中使用一致的 Spring AI 版本。请参阅[&#xA;  &lt;a href=&#34;../../getting-started.html#dependency-management&#34;&gt;依赖项管理&lt;/a&gt;](../../getting-started.html#dependency-management)部分，将 Spring AI BOM 添加到您的构建系统中。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
