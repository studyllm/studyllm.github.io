<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>聊天客户端 API on Spring AI 1.0.0</title>
    <link>https://studyllm.github.io/docs/chat-client-api/</link>
    <description>Recent content in 聊天客户端 API on Spring AI 1.0.0</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://studyllm.github.io/docs/chat-client-api/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>顾问 API</title>
      <link>https://studyllm.github.io/docs/chat-client-api/advisors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://studyllm.github.io/docs/chat-client-api/advisors/</guid>
      <description>&lt;h1 id=&#34;顾问-api&#34;&gt;&#xA;  顾问 API&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a1%be%e9%97%ae-api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Spring AI Advisors API 提供了一种灵活而强大的方法来拦截、修改和增强 Spring 应用程序中的 AI 驱动的交互。通过利用 Advisors API，开发人员可以创建更复杂、可重用和可维护的 AI 组件。&#xA;主要优势包括封装重复的生成式 AI 模式、转换发送到大型语言模型 （LLM） 和从大型语言模型 （LLM） 发送的数据，以及提供跨各种模型和用例的可移植性。&#xA;您可以使用 [&#xA;  &lt;a href=&#34;chatclient.html#_advisor_configuration_in_chatclient&#34;&gt;ChatClient API&lt;/a&gt;](chatclient.html#_advisor_configuration_in_chatclient) 配置现有顾问，如以下示例所示：&#xA;建议在构建时使用 builder 的 &lt;code&gt;defaultAdvisors（）&lt;/code&gt; 方法注册 advisor。&#xA;顾问还参与可观测性堆栈，因此您可以查看与其执行相关的指标和跟踪。&lt;/p&gt;&#xA;&lt;h2 id=&#34;核心组件&#34;&gt;&#xA;  核心组件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;该 API 由用于非流式处理场景的 &lt;code&gt;CallAroundAdvisor&lt;/code&gt; 和 &lt;code&gt;CallAroundAdvisor&lt;/code&gt;Chain 以及用于流式处理场景的 &lt;code&gt;StreamAroundAdvisor&lt;/code&gt; 和 &lt;code&gt;StreamAroundAdvisor&lt;/code&gt;Chain 组成。它还包括 &lt;code&gt;AdvisedRequest&lt;/code&gt; 来表示未密封的 Prompt 请求，&lt;code&gt;AdvisedResponse&lt;/code&gt; 用于聊天完成响应。两者都持有一个 &lt;code&gt;advise-context&lt;/code&gt; 来在整个 advisor 链中共享状态。&#xA;&#xA;  &lt;img src=&#34;../../images/advisors-api-classes.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;code&gt;nextAroundCall（）&lt;/code&gt; 和 &lt;code&gt;nextAroundStream（）&lt;/code&gt; 是关键的 advisor 方法，通常执行一些作，例如检查未密封的 Prompt 数据、自定义和扩充 Prompt 数据、调用 advisor 链中的下一个实体、选择性地阻止请求、检查聊天完成响应以及引发异常以指示处理错误。&#xA;此外，&lt;code&gt;getOrder（）&lt;/code&gt; 方法确定链中的 advisor 顺序，而 &lt;code&gt;getName（）&lt;/code&gt; 提供唯一的 advisor 名称。&#xA;由 Spring AI 框架创建的 Advisor 链允许按顺序调用多个 advisor，这些 advisor 按其 &lt;code&gt;getOrder（）&lt;/code&gt; 值排序。首先执行较低的值。自动添加的最后一个 advisor 将请求发送到 LLM。&#xA;以程图说明了顾问链和聊天模型之间的交互：&#xA;&#xA;  &lt;img src=&#34;../../images/advisors-flow.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
