<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  刀具调用
  #

工具调用（也称为函数调用）是人工智能应用程序中的一种常见模式，允许模型与一组API或工具交互，以增强其功能。
工具主要用于：
尽管我们通常将工具调用称为模型功能，但实际上由客户端应用程序提供工具调用逻辑。模型只能请求工具调用并提供输入参数，而应用程序负责从输入参数执行工具调用并返回结果。该模型永远无法访问作为工具提供的任何API，这是一个关键的安全考虑事项。
SpringAI提供了方便的API来定义工具、解决来自模型的工具调用请求和执行工具调用。以下部分概述了Spring AI中的工具调用功能。

  快速入门
  #

让我们看看如何开始在SpringAI中使用工具调用。我们将实现两个简单的工具：一个用于信息检索，另一个用于采取行动。信息检索工具将用于获取用户时区中的当前日期和时间。操作工具将用于设置指定时间的报警。
人工智能模型无法访问实时信息。任何假设知道当前日期或天气预报等信息的问题都不能由模型回答。然而，我们可以提供一个可以检索该信息的工具，并让模型在需要访问实时信息时调用该工具。
让我们实现一个工具，在DateTimeTools类中获取用户时区中的当前日期和时间。该工具不需要参数。Spring框架中的LocaleContextHolder可以提供用户的时区。该工具将被定义为用@tool注释的方法。为了帮助模型理解是否以及何时调用该工具，我们将提供工具功能的详细描述。
import java.time.LocalDateTime;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.context.i18n.LocaleContextHolder;

class DateTimeTools {

    @Tool(description = &#34;Get the current date and time in the user&#39;s timezone&#34;)
    String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

}
接下来，让我们为模型提供该工具。在这个例子中，我们将使用ChatClient与模型交互。我们将通过tools（）方法传递DateTimeTools的实例来为模型提供工具。当模型需要知道当前日期和时间时，它将请求调用该工具。在内部，ChatClient将调用工具并将结果返回给模型，然后模型将使用工具调用结果来生成对原始问题的最终响应。
ChatModel chatModel = ...

String response = ChatClient.create(chatModel)
        .prompt(&#34;What day is tomorrow?&#34;)
        .tools(new DateTimeTools())
        .call()
        .content();

System.out.println(response);
输出将类似于：
Tomorrow is 2015-10-21.
您可以重新尝试询问相同的问题。这一次，不要为模型提供工具。输出将类似于：">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://studyllm.github.io/docs/api/tools/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="刀具调用 # 工具调用（也称为函数调用）是人工智能应用程序中的一种常见模式，允许模型与一组API或工具交互，以增强其功能。 工具主要用于： 尽管我们通常将工具调用称为模型功能，但实际上由客户端应用程序提供工具调用逻辑。模型只能请求工具调用并提供输入参数，而应用程序负责从输入参数执行工具调用并返回结果。该模型永远无法访问作为工具提供的任何API，这是一个关键的安全考虑事项。 SpringAI提供了方便的API来定义工具、解决来自模型的工具调用请求和执行工具调用。以下部分概述了Spring AI中的工具调用功能。
快速入门 # 让我们看看如何开始在SpringAI中使用工具调用。我们将实现两个简单的工具：一个用于信息检索，另一个用于采取行动。信息检索工具将用于获取用户时区中的当前日期和时间。操作工具将用于设置指定时间的报警。 人工智能模型无法访问实时信息。任何假设知道当前日期或天气预报等信息的问题都不能由模型回答。然而，我们可以提供一个可以检索该信息的工具，并让模型在需要访问实时信息时调用该工具。 让我们实现一个工具，在DateTimeTools类中获取用户时区中的当前日期和时间。该工具不需要参数。Spring框架中的LocaleContextHolder可以提供用户的时区。该工具将被定义为用@tool注释的方法。为了帮助模型理解是否以及何时调用该工具，我们将提供工具功能的详细描述。
import java.time.LocalDateTime; import org.springframework.ai.tool.annotation.Tool; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = &#34;Get the current date and time in the user&#39;s timezone&#34;) String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } 接下来，让我们为模型提供该工具。在这个例子中，我们将使用ChatClient与模型交互。我们将通过tools（）方法传递DateTimeTools的实例来为模型提供工具。当模型需要知道当前日期和时间时，它将请求调用该工具。在内部，ChatClient将调用工具并将结果返回给模型，然后模型将使用工具调用结果来生成对原始问题的最终响应。
ChatModel chatModel = ... String response = ChatClient.create(chatModel) .prompt(&#34;What day is tomorrow?&#34;) .tools(new DateTimeTools()) .call() .content(); System.out.println(response); 输出将类似于：
Tomorrow is 2015-10-21. 您可以重新尝试询问相同的问题。这一次，不要为模型提供工具。输出将类似于：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
<title>Tools | My New Hugo Site</title>
<link rel="icon" href="../../../favicon.png" >
<link rel="manifest" href="../../../manifest.json">
<link rel="canonical" href="https://studyllm.github.io/docs/api/tools/">
<link rel="stylesheet" href="../../../book.min.e9f68c3fff3d8236a489d16a9caf6de5e4d1a29c20eb4b5524e42cd30be4d319.css" integrity="sha256-6faMP/89gjakidFqnK9t5eTRopwg60tVJOQs0wvk0xk=" crossorigin="anonymous">
  <script defer src="../../../fuse.min.js"></script>
  <script defer src="../../../en.search.min.159df6c2caba755774f33df0face5fe8fea68105062d487cf9d8934fdfbd903c.js" integrity="sha256-FZ32wsq6dVd08z3w&#43;s5f6P6mgQUGLUh8&#43;diTT9&#43;9kDw=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="../../../"><span>My New Hugo Site</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="../../../docs/api/tools/" class="active">Tools</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="../../../docs/concepts/" class="">Concepts</a>
  

        </li>
      
    
  </ul>










  
<ul>
  
  <li>
    <a href="https://github.com"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="../../../svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Tools</h3>

  <label for="toc-control">
    
    <img src="../../../svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#刀具调用">刀具调用</a>
      <ul>
        <li><a href="#快速入门">快速入门</a></li>
        <li><a href="#信息检索">信息检索</a></li>
        <li><a href="#采取行动">采取行动</a></li>
        <li><a href="#概述">概述</a></li>
        <li><a href="#方法作为工具">方法作为工具</a></li>
        <li><a href="#声明性规范tool">声明性规范：@Tool</a></li>
        <li><a href="#将工具添加到chatclient">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel">将默认工具添加到ChatModel</a></li>
        <li><a href="#编程规范methodtoolcallback">编程规范：MethodToolCallback</a></li>
        <li><a href="#将工具添加到chatclient和chatmodel">将工具添加到ChatClient和ChatModel</a></li>
        <li><a href="#将默认工具添加到chatclient-1">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-1">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-1">将默认工具添加到ChatModel</a></li>
        <li><a href="#方法工具限制">方法工具限制</a></li>
        <li><a href="#作为工具的功能">作为工具的功能</a></li>
        <li><a href="#编程规范functiontoolcallback">编程规范：FunctionToolCallback</a></li>
        <li><a href="#将工具添加到chatclient-1">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient-2">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-2">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-2">将默认工具添加到ChatModel</a></li>
        <li><a href="#动态规范bean">动态规范：@Bean</a></li>
        <li><a href="#将工具添加到chatclient-2">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient-3">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-3">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-3">将默认工具添加到ChatModel</a></li>
        <li><a href="#功能工具限制">功能工具限制</a></li>
        <li><a href="#工具规格">工具规格</a></li>
        <li><a href="#工具回调">工具回调</a></li>
        <li><a href="#刀具定义">刀具定义</a></li>
        <li><a href="#方法工具定义">方法工具定义</a></li>
        <li><a href="#功能工具定义">功能工具定义</a></li>
        <li><a href="#json架构">JSON架构</a></li>
        <li><a href="#描述">描述</a></li>
        <li><a href="#必需可选">必需/可选</a></li>
        <li><a href="#结果转换">结果转换</a></li>
        <li><a href="#方法工具调用结果转换">方法工具调用结果转换</a></li>
        <li><a href="#函数工具调用结果转换">函数工具调用结果转换</a></li>
        <li><a href="#工具上下文">工具上下文</a></li>
        <li><a href="#直接退货">直接退货</a></li>
        <li><a href="#方法直接返回">方法直接返回</a></li>
        <li><a href="#函数直接返回">函数直接返回</a></li>
        <li><a href="#刀具执行">刀具执行</a></li>
        <li><a href="#框架控制的工具执行">框架控制的工具执行</a></li>
        <li><a href="#用户控制的工具执行">用户控制的工具执行</a></li>
        <li><a href="#异常处理">异常处理</a></li>
        <li><a href="#工具分辨率">工具分辨率</a></li>
        <li><a href="#可观察性">可观察性</a></li>
        <li><a href="#日志记录">日志记录</a></li>
        <li><a href="#信息检索-1">信息检索</a></li>
        <li><a href="#将工具添加到chatclient-3">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient-4">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-4">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-4">将默认工具添加到ChatModel</a></li>
        <li><a href="#将工具添加到chatclient和chatmodel-1">将工具添加到ChatClient和ChatModel</a></li>
        <li><a href="#将默认工具添加到chatclient-5">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-5">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-5">将默认工具添加到ChatModel</a></li>
        <li><a href="#将工具添加到chatclient-4">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient-6">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-6">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-6">将默认工具添加到ChatModel</a></li>
        <li><a href="#将工具添加到chatclient-5">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient-7">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-7">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-7">将默认工具添加到ChatModel</a></li>
        <li><a href="#方法工具定义-1">方法工具定义</a></li>
        <li><a href="#功能工具定义-1">功能工具定义</a></li>
        <li><a href="#描述-1">描述</a></li>
        <li><a href="#必需可选-1">必需/可选</a></li>
        <li><a href="#方法工具调用结果转换-1">方法工具调用结果转换</a></li>
        <li><a href="#函数工具调用结果转换-1">函数工具调用结果转换</a></li>
        <li><a href="#方法直接返回-1">方法直接返回</a></li>
        <li><a href="#函数直接返回-1">函数直接返回</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="刀具调用">
  刀具调用
  <a class="anchor" href="#%e5%88%80%e5%85%b7%e8%b0%83%e7%94%a8">#</a>
</h1>
<p>工具调用（也称为函数调用）是人工智能应用程序中的一种常见模式，允许模型与一组API或工具交互，以增强其功能。
工具主要用于：
尽管我们通常将工具调用称为模型功能，但实际上由客户端应用程序提供工具调用逻辑。模型只能请求工具调用并提供输入参数，而应用程序负责从输入参数执行工具调用并返回结果。该模型永远无法访问作为工具提供的任何API，这是一个关键的安全考虑事项。
SpringAI提供了方便的API来定义工具、解决来自模型的工具调用请求和执行工具调用。以下部分概述了Spring AI中的工具调用功能。</p>
<h2 id="快速入门">
  快速入门
  <a class="anchor" href="#%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8">#</a>
</h2>
<p>让我们看看如何开始在SpringAI中使用工具调用。我们将实现两个简单的工具：一个用于信息检索，另一个用于采取行动。信息检索工具将用于获取用户时区中的当前日期和时间。操作工具将用于设置指定时间的报警。
人工智能模型无法访问实时信息。任何假设知道当前日期或天气预报等信息的问题都不能由模型回答。然而，我们可以提供一个可以检索该信息的工具，并让模型在需要访问实时信息时调用该工具。
让我们实现一个工具，在<code>DateTimeTools</code>类中获取用户时区中的当前日期和时间。该工具不需要参数。Spring框架中的<code>LocaleContextHolder</code>可以提供用户的时区。该工具将被定义为用@tool注释的方法。为了帮助模型理解是否以及何时调用该工具，我们将提供工具功能的详细描述。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接下来，让我们为模型提供该工具。在这个例子中，我们将使用<code>ChatClient</code>与模型交互。我们将通过tools（）方法传递<code>DateTimeTools</code>的实例来为模型提供工具。当模型需要知道当前日期和时间时，它将请求调用该工具。在内部，<code>ChatClient</code>将调用工具并将结果返回给模型，然后模型将使用工具调用结果来生成对原始问题的最终响应。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String response <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">content</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(response);
</span></span></code></pre></div><p>输出将类似于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Tomorrow is 2015<span style="color:#f92672">-</span>10<span style="color:#f92672">-</span>21.
</span></span></code></pre></div><p>您可以重新尝试询问相同的问题。这一次，不要为模型提供工具。输出将类似于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>I am an AI and <span style="color:#66d9ef">do</span> not have access to real<span style="color:#f92672">-</span>time information. Please provide the current date so I can accurately determine what day tomorrow will be.
</span></span></code></pre></div><p>如果没有该工具，模型就不知道如何回答这个问题，因为它不能确定当前的日期和时间。
人工智能模型可用于生成实现特定目标的计划。例如，模型可以生成预订丹麦旅行的计划。然而，模型没有执行计划的能力。这就是工具的作用：它们可以用于执行模型生成的计划。
在前面的示例中，我们使用了一个工具来确定当前日期和时间。在本例中，我们将定义第二个工具，用于在特定时间设置报警。目标是从现在开始设置10分钟的警报，因此我们需要为模型提供这两个工具来完成这项任务。
我们将一如既往地将新工具添加到相同的<code>DateTimeTools</code>类中。新工具将采用单个参数，即ISO-8601格式的时间。然后，该工具将向控制台打印一条消息，指示已为给定时间设置报警。与前面一样，该工具被定义为用@tool注释的方法，我们也使用它来提供详细的描述，以帮助模型理解何时以及如何使用该工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time, provided in ISO-8601 format&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接下来，让我们将这两个工具都提供给模型。我们将使用<code>ChatClient</code>与模型交互。我们将通过tools（）方法传递<code>DateTimeTools</code>的实例来为模型提供工具。当我们要求在10分钟后设置警报时，模型首先需要知道当前的日期和时间。然后，它将使用当前日期和时间来计算报警时间。最后，它将使用报警工具来设置报警。在内部，<code>ChatClient</code>将处理来自模型的任何工具调用请求，并将任何工具调用执行结果发送回它，以便模型可以生成最终响应。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String response <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;Can you set an alarm 10 minutes from now?&#34;</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">content</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(response);
</span></span></code></pre></div><p>在应用程序日志中，您可以检查警报是否已在正确的时间设置。</p>
<h2 id="信息检索">
  信息检索
  <a class="anchor" href="#%e4%bf%a1%e6%81%af%e6%a3%80%e7%b4%a2">#</a>
</h2>
<p>人工智能模型无法访问实时信息。任何假设知道当前日期或天气预报等信息的问题都不能由模型回答。然而，我们可以提供一个可以检索该信息的工具，并让模型在需要访问实时信息时调用该工具。
让我们实现一个工具，在<code>DateTimeTools</code>类中获取用户时区中的当前日期和时间。该工具不需要参数。Spring框架中的<code>LocaleContextHolder</code>可以提供用户的时区。该工具将被定义为用@tool注释的方法。为了帮助模型理解是否以及何时调用该工具，我们将提供工具功能的详细描述。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接下来，让我们为模型提供该工具。在这个例子中，我们将使用<code>ChatClient</code>与模型交互。我们将通过tools（）方法传递<code>DateTimeTools</code>的实例来为模型提供工具。当模型需要知道当前日期和时间时，它将请求调用该工具。在内部，<code>ChatClient</code>将调用工具并将结果返回给模型，然后模型将使用工具调用结果来生成对原始问题的最终响应。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String response <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">content</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(response);
</span></span></code></pre></div><p>输出将类似于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Tomorrow is 2015<span style="color:#f92672">-</span>10<span style="color:#f92672">-</span>21.
</span></span></code></pre></div><p>您可以重新尝试询问相同的问题。这一次，不要为模型提供工具。输出将类似于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>I am an AI and <span style="color:#66d9ef">do</span> not have access to real<span style="color:#f92672">-</span>time information. Please provide the current date so I can accurately determine what day tomorrow will be.
</span></span></code></pre></div><p>如果没有该工具，模型就不知道如何回答这个问题，因为它不能确定当前的日期和时间。</p>
<h2 id="采取行动">
  采取行动
  <a class="anchor" href="#%e9%87%87%e5%8f%96%e8%a1%8c%e5%8a%a8">#</a>
</h2>
<p>人工智能模型可用于生成实现特定目标的计划。例如，模型可以生成预订丹麦旅行的计划。然而，模型没有执行计划的能力。这就是工具的作用：它们可以用于执行模型生成的计划。
在前面的示例中，我们使用了一个工具来确定当前日期和时间。在本例中，我们将定义第二个工具，用于在特定时间设置报警。目标是从现在开始设置10分钟的警报，因此我们需要为模型提供这两个工具来完成这项任务。
我们将一如既往地将新工具添加到相同的<code>DateTimeTools</code>类中。新工具将采用单个参数，即ISO-8601格式的时间。然后，该工具将向控制台打印一条消息，指示已为给定时间设置报警。与前面一样，该工具被定义为用@tool注释的方法，我们也使用它来提供详细的描述，以帮助模型理解何时以及如何使用该工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time, provided in ISO-8601 format&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接下来，让我们将这两个工具都提供给模型。我们将使用<code>ChatClient</code>与模型交互。我们将通过tools（）方法传递<code>DateTimeTools</code>的实例来为模型提供工具。当我们要求在10分钟后设置警报时，模型首先需要知道当前的日期和时间。然后，它将使用当前日期和时间来计算报警时间。最后，它将使用报警工具来设置报警。在内部，<code>ChatClient</code>将处理来自模型的任何工具调用请求，并将任何工具调用执行结果发送回它，以便模型可以生成最终响应。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String response <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;Can you set an alarm 10 minutes from now?&#34;</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">content</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(response);
</span></span></code></pre></div><p>在应用程序日志中，您可以检查警报是否已在正确的时间设置。</p>
<h2 id="概述">
  概述
  <a class="anchor" href="#%e6%a6%82%e8%bf%b0">#</a>
</h2>
<p>SpringAI通过一组灵活的抽象来支持工具调用，这些抽象允许您以一致的方式定义、解析和执行工具。本节概述了Spring AI中工具调用的主要概念和组件。

  <img src="../../../images/tools/tool-calling-01.jpg" alt="工具调用的主要操作序列" />
工具是工具调用的构建块，它们由<code>ToolCallback</code>接口建模。Spring AI提供了从方法和函数指定<code>ToolCallback</code>的内置支持，但您始终可以定义自己的ToolCallbak实现来支持更多用例。
<code>ChatModel</code>实现透明地将工具调用请求分派到相应的<code>ToolCallback</code>实现，并将工具调用结果发送回模型，该模型最终将生成最终响应。它们使用<code>ToolCallingManager</code>接口来执行此操作，该接口负责管理工具执行生命周期。
<code>ChatClient</code>和<code>ChatModel</code>都接受<code>ToolCallback</code>对象的列表，以使工具可用于模型和最终将执行它们的<code>ToolCallingManager</code>。
除了直接传递<code>ToolCallback</code>对象外，还可以传递工具名称列表，该列表将使用ToolCallbickResolver接口动态解析。
下面的部分将详细介绍所有这些概念和API，包括如何定制和扩展它们以支持更多用例。</p>
<h2 id="方法作为工具">
  方法作为工具
  <a class="anchor" href="#%e6%96%b9%e6%b3%95%e4%bd%9c%e4%b8%ba%e5%b7%a5%e5%85%b7">#</a>
</h2>
<p>Spring AI以两种方式提供了从方法中指定工具（即<code>ToolCallback</code>）的内置支持：</p>
<ul>
<li>声明性地，使用@Tool注释</li>
<li>以编程方式，使用低级MethodToolCallback实现。
通过使用@tool对方法进行注释，可以将其转换为工具。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>@Tool</code>注释允许您提供有关工具的关键信息：</p>
<ul>
<li>name：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。</li>
<li>description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</li>
<li>returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。</li>
<li>resultConverter：用于将工具调用的结果转换为String对象以发送回AI模型的ToolCallResultConvertor实现。有关详细信息，请参见结果转换。
该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。
可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括<code>void</code>。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。
Spring AI将自动为<code>@Tool</code>注释方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。<code>@Tool</code>Param注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>@ToolParam</code>注释允许您提供有关工具参数的关键信息：</p>
<ul>
<li>description:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。</li>
<li>required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。
如果参数被注释为<code>@Nullable</code>，则它将被视为可选的，除非使用<code>@ToolParam</code>注释根据需要显式标记。
除了<code>@ToolParam</code>注释外，您还可以使用Swager的<code>@Schema</code>注释或Jackson的<code>@JsonProperty</code>注释。有关更多详细信息，请参阅JSON模式。
使用声明性规范方法时，可以在调用<code>ChatClient</code>时将工具类实例传递给tools（）方法。此类工具仅适用于它们添加到的特定聊天请求。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>在幕后，<code>ChatClient</code>将从工具类实例中的每个<code>@Tool</code>注释方法生成一个<code>ToolCallback</code>，并将它们传递给模型。如果希望自己生成<code>ToolCallback</code>，则可以使用ToolCallbaks实用程序类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span></code></pre></div><p>使用声明性规范方法时，可以将默认工具添加到ChatClient。通过将工具类实例传递给defaultTools（）方法来生成生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用声明性规范方法时，可以将工具类实例传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的toolCallback（）方法。此类工具仅适用于它们添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(dateTimeTools)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用声明性规范方法时，可以通过将工具类实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的toolCallback（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(dateTimeTools)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>通过以编程方式构建<code>MethodToolCallback</code>，可以将方法转换为工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>MethodToolCallback</code>。Builder允许您构建<code>MethodToolCallback</code>实例，并提供有关该工具的关键信息：</p>
<ul>
<li>toolDefinition：定义工具名称、描述和输入架构的toolDefinition实例。可以使用ToolDefinition构建它。生成器类。必需。</li>
<li>toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。</li>
<li>toolMethod：表示工具方法的Method实例。必需。</li>
<li>toolObject：包含工具方法的对象实例。如果方法是静态的，则可以省略此参数。</li>
<li>toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。
工具定义。Builder允许您构建<code>ToolDefinition</code>实例，并定义工具名称、描述和输入架构：</li>
<li>name：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。</li>
<li>description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</li>
<li>inputSchema：工具输入参数的JSON模式。如果未提供，则将基于方法参数自动生成架构。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。
<code>ToolMetadata</code>。Builder允许您构建<code>ToolMetadata</code>实例，并定义工具的其他设置：</li>
<li>returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> MethodToolCallback.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolDefinition</span>(ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolMethod</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolObject</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。
可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括<code>void</code>。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。
如果方法是静态的，则可以省略toolObject（）方法，因为不需要它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> MethodToolCallback.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolDefinition</span>(ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolMethod</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>Spring AI将自动为方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。<code>@ToolParam</code>注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>@ToolParam</code>注释允许您提供有关工具参数的关键信息：</p>
<ul>
<li>description:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。</li>
<li>required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。
如果参数被注释为<code>@Nullable</code>，则它将被视为可选的，除非使用<code>@ToolParam</code>注释根据需要显式标记。
除了<code>@ToolParam</code>注释外，您还可以使用Swager的<code>@Schema</code>注释或Jackson的<code>@JsonProperty</code>注释。有关更多详细信息，请参阅JSON模式。
使用编程规范方法时，可以将<code>MethodToolCallback</code>实例传递给<code>ChatClient</code>的tools（）方法。
该工具仅适用于其添加到的特定聊天请求。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将默认工具添加到ChatClient。通过将<code>MethodToolCallback</code>实例传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将<code>MethodToolCallback</code>实例传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的Toolcallback（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用编程规范方法时，可以通过将<code>MethodToolCallback</code>实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的ToolCallbark（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>以下类型当前不支持作为用作工具的方法的参数或返回类型：</p>
<ul>
<li>可选</li>
<li>异步类型（例如CompletableFuture、Future）</li>
<li>无功类型（例如Flow、Mono、Flux）</li>
<li>功能类型（例如功能、供应商、消费者）。
使用基于函数的工具规范方法支持函数类型。有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</li>
</ul>
<h2 id="声明性规范tool">
  声明性规范：@Tool
  <a class="anchor" href="#%e5%a3%b0%e6%98%8e%e6%80%a7%e8%a7%84%e8%8c%83tool">#</a>
</h2>
<p>通过使用@tool对方法进行注释，可以将其转换为工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>@Tool</code>注释允许您提供有关工具的关键信息：</p>
<ul>
<li>name：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。</li>
<li>description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</li>
<li>returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。</li>
<li>resultConverter：用于将工具调用的结果转换为String对象以发送回AI模型的ToolCallResultConvertor实现。有关详细信息，请参见结果转换。
该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。
可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括<code>void</code>。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。
Spring AI将自动为<code>@Tool</code>注释方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。<code>@Tool</code>Param注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>@ToolParam</code>注释允许您提供有关工具参数的关键信息：</p>
<ul>
<li>description:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。</li>
<li>required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。
如果参数被注释为<code>@Nullable</code>，则它将被视为可选的，除非使用<code>@ToolParam</code>注释根据需要显式标记。
除了<code>@ToolParam</code>注释外，您还可以使用Swager的<code>@Schema</code>注释或Jackson的<code>@JsonProperty</code>注释。有关更多详细信息，请参阅JSON模式。
使用声明性规范方法时，可以在调用<code>ChatClient</code>时将工具类实例传递给tools（）方法。此类工具仅适用于它们添加到的特定聊天请求。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>在幕后，<code>ChatClient</code>将从工具类实例中的每个<code>@Tool</code>注释方法生成一个<code>ToolCallback</code>，并将它们传递给模型。如果希望自己生成<code>ToolCallback</code>，则可以使用ToolCallbaks实用程序类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span></code></pre></div><p>使用声明性规范方法时，可以将默认工具添加到ChatClient。通过将工具类实例传递给defaultTools（）方法来生成生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用声明性规范方法时，可以将工具类实例传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的toolCallback（）方法。此类工具仅适用于它们添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(dateTimeTools)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用声明性规范方法时，可以通过将工具类实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的toolCallback（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(dateTimeTools)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatclient">
  将工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient">#</a>
</h2>
<p>使用声明性规范方法时，可以在调用<code>ChatClient</code>时将工具类实例传递给tools（）方法。此类工具仅适用于它们添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>在幕后，<code>ChatClient</code>将从工具类实例中的每个<code>@Tool</code>注释方法生成一个<code>ToolCallback</code>，并将它们传递给模型。如果希望自己生成<code>ToolCallback</code>，则可以使用ToolCallbaks实用程序类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span></code></pre></div><h2 id="将默认工具添加到chatclient">
  将默认工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient">#</a>
</h2>
<p>使用声明性规范方法时，可以将默认工具添加到ChatClient。通过将工具类实例传递给defaultTools（）方法来生成生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatmodel">
  将工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel">#</a>
</h2>
<p>使用声明性规范方法时，可以将工具类实例传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的toolCallback（）方法。此类工具仅适用于它们添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(dateTimeTools)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><h2 id="将默认工具添加到chatmodel">
  将默认工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel">#</a>
</h2>
<p>使用声明性规范方法时，可以通过将工具类实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的toolCallback（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(dateTimeTools)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="编程规范methodtoolcallback">
  编程规范：MethodToolCallback
  <a class="anchor" href="#%e7%bc%96%e7%a8%8b%e8%a7%84%e8%8c%83methodtoolcallback">#</a>
</h2>
<p>通过以编程方式构建<code>MethodToolCallback</code>，可以将方法转换为工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>MethodToolCallback</code>。Builder允许您构建<code>MethodToolCallback</code>实例，并提供有关该工具的关键信息：</p>
<ul>
<li>toolDefinition：定义工具名称、描述和输入架构的toolDefinition实例。可以使用ToolDefinition构建它。生成器类。必需。</li>
<li>toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。</li>
<li>toolMethod：表示工具方法的Method实例。必需。</li>
<li>toolObject：包含工具方法的对象实例。如果方法是静态的，则可以省略此参数。</li>
<li>toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。
工具定义。Builder允许您构建<code>ToolDefinition</code>实例，并定义工具名称、描述和输入架构：</li>
<li>name：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。</li>
<li>description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</li>
<li>inputSchema：工具输入参数的JSON模式。如果未提供，则将基于方法参数自动生成架构。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。
<code>ToolMetadata</code>。Builder允许您构建<code>ToolMetadata</code>实例，并定义工具的其他设置：</li>
<li>returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> MethodToolCallback.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolDefinition</span>(ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolMethod</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolObject</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。
可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括<code>void</code>。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。
如果方法是静态的，则可以省略toolObject（）方法，因为不需要它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> MethodToolCallback.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolDefinition</span>(ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolMethod</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>Spring AI将自动为方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。<code>@ToolParam</code>注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>@ToolParam</code>注释允许您提供有关工具参数的关键信息：</p>
<ul>
<li>description:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。</li>
<li>required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。
如果参数被注释为<code>@Nullable</code>，则它将被视为可选的，除非使用<code>@ToolParam</code>注释根据需要显式标记。
除了<code>@ToolParam</code>注释外，您还可以使用Swager的<code>@Schema</code>注释或Jackson的<code>@JsonProperty</code>注释。有关更多详细信息，请参阅JSON模式。
使用编程规范方法时，可以将<code>MethodToolCallback</code>实例传递给<code>ChatClient</code>的tools（）方法。
该工具仅适用于其添加到的特定聊天请求。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将默认工具添加到ChatClient。通过将<code>MethodToolCallback</code>实例传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将<code>MethodToolCallback</code>实例传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的Toolcallback（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用编程规范方法时，可以通过将<code>MethodToolCallback</code>实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的ToolCallbark（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatclient和chatmodel">
  将工具添加到ChatClient和ChatModel
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient%e5%92%8cchatmodel">#</a>
</h2>
<p>使用编程规范方法时，可以将<code>MethodToolCallback</code>实例传递给<code>ChatClient</code>的tools（）方法。
该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><h2 id="将默认工具添加到chatclient-1">
  将默认工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-1">#</a>
</h2>
<p>使用编程规范方法时，可以将默认工具添加到ChatClient。通过将<code>MethodToolCallback</code>实例传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatmodel-1">
  将工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-1">#</a>
</h2>
<p>使用编程规范方法时，可以将<code>MethodToolCallback</code>实例传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的Toolcallback（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><h2 id="将默认工具添加到chatmodel-1">
  将默认工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-1">#</a>
</h2>
<p>使用编程规范方法时，可以通过将<code>MethodToolCallback</code>实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的ToolCallbark（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="方法工具限制">
  方法工具限制
  <a class="anchor" href="#%e6%96%b9%e6%b3%95%e5%b7%a5%e5%85%b7%e9%99%90%e5%88%b6">#</a>
</h2>
<p>以下类型当前不支持作为用作工具的方法的参数或返回类型：</p>
<ul>
<li>可选</li>
<li>异步类型（例如CompletableFuture、Future）</li>
<li>无功类型（例如Flow、Mono、Flux）</li>
<li>功能类型（例如功能、供应商、消费者）。
使用基于函数的工具规范方法支持函数类型。有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</li>
</ul>
<h2 id="作为工具的功能">
  作为工具的功能
  <a class="anchor" href="#%e4%bd%9c%e4%b8%ba%e5%b7%a5%e5%85%b7%e7%9a%84%e5%8a%9f%e8%83%bd">#</a>
</h2>
<p>Spring AI提供了从函数中指定工具的内置支持，可以通过编程方式使用低级<code>FunctionToolCallback</code>实现，也可以在运行时动态解析为<code>@Bean</code>。
通过以编程方式构建<code>Function</code>ToolCallback，可以将函数类型（<code>Function</code>、<code>Supplier</code>、<code>Consumer</code>或Bi<code>Function</code>）转换为工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeatherService</span> <span style="color:#66d9ef">implements</span> Function<span style="color:#f92672">&lt;</span>WeatherRequest, WeatherResponse<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> WeatherResponse <span style="color:#a6e22e">apply</span>(WeatherRequest request) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> WeatherResponse(30.<span style="color:#a6e22e">0</span>, Unit.<span style="color:#a6e22e">C</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> Unit { C, F }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">record</span> <span style="color:#a6e22e">WeatherRequest</span>(String location, Unit unit) {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">record</span> <span style="color:#a6e22e">WeatherResponse</span>(<span style="color:#66d9ef">double</span> temp, Unit unit) {}
</span></span></code></pre></div><p><code>FunctionToolCallback</code>。Builder允许您构建<code>FunctionToolCallback</code>实例，并提供有关该工具的关键信息：</p>
<ul>
<li>name：工具的名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一上下文中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。必需。</li>
<li>toolFunction：表示工具方法（Function、Supplier、Consumer或BiFunction）的函数对象。必需。</li>
<li>description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</li>
<li>inputType：函数输入的类型。必需。</li>
<li>inputSchema：工具输入参数的JSON模式。如果未提供，则将基于inputType自动生成模式。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。</li>
<li>toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。</li>
<li>toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。
<code>ToolMetadata</code>。Builder允许您构建<code>ToolMetadata</code>实例，并定义工具的其他设置：</li>
<li>returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> FunctionToolCallback
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">builder</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>, <span style="color:#66d9ef">new</span> WeatherService())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputType</span>(WeatherRequest.<span style="color:#a6e22e">class</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>功能输入和输出可以是<code>Void</code>或POJO。输入和输出POJO必须是可序列化的，因为结果将被序列化并发送回模型。函数以及输入和输出类型必须是公共的。
使用编程规范方法时，可以将<code>FunctionToolCallback</code>实例传递给<code>ChatClient</code>的tools（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将默认工具添加到ChatClient。通过将<code>FunctionToolCallback</code>实例传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将<code>FunctionToolCallback</code>实例传递给<code>ToolCallingChatOptions</code>的toolCallbacks（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用编程规范方法时，可以通过将<code>FunctionToolCallback</code>实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的ToolCallbick（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>您可以将工具定义为Springbean，并让SpringAI使用<code>ToolCallbackResolver</code>接口（通过SpringBeanToolCallbickResolver实现）在运行时动态解析它们，而不是以编程方式指定工具。该选项允许您使用任何<code>Function</code>、<code>Supplier</code>、<code>Consumer</code>或Bi<code>Function</code>bean作为工具。bean名称将用作工具名称，Spring Framework中的<code>@Description</code>注释可用于提供该工具的描述，模型使用该注释来理解何时以及如何调用该工具。如果不提供描述，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>(proxyBeanMethods <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeatherTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    WeatherService weatherService <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> WeatherService();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>	Function<span style="color:#f92672">&lt;</span>WeatherRequest, WeatherResponse<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">currentWeather</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> weatherService;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将自动生成工具输入参数的JSON模式。您可以使用<code>@ToolParam</code>注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">record</span> <span style="color:#a6e22e">WeatherRequest</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;The name of a city or a country&#34;</span>) String location, Unit unit) {}
</span></span></code></pre></div><p>这种工具规范方法的缺点是不能保证类型安全，因为工具解析是在运行时完成的。为了减轻这种情况，可以使用<code>@Bean</code>注释显式地指定工具名称，并将值存储在常量中，以便可以在聊天请求中使用它，而不是硬编码工具名称。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>(proxyBeanMethods <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeatherTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String CURRENT_WEATHER_TOOL <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;currentWeather&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Bean</span>(CURRENT_WEATHER_TOOL)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>	Function<span style="color:#f92672">&lt;</span>WeatherRequest, WeatherResponse<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">currentWeather</span>() {
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用动态规范方法时，可以将工具名称（即函数bean名称）传递给<code>ChatClient</code>的tools（）方法。
该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>使用动态规范方法时，可以将默认工具添加到ChatClient。通过将工具名称传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用动态规范方法时，可以将工具名称传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的toolNames（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolNames</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用动态规范方法时，可以通过将工具名称传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的toolNames（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolNames</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>以下类型当前不支持作为用作工具的函数的输入或输出类型：</p>
<ul>
<li>基本体类型</li>
<li>可选</li>
<li>集合类型（例如列表、映射、数组、集合）</li>
<li>异步类型（例如CompletableFuture、Future）</li>
<li>无功类型（例如流量、单声道、通量）。
使用基于方法的工具规范方法支持基元类型和集合。有关详细信息，请参见作为工具的方法。</li>
</ul>
<h2 id="编程规范functiontoolcallback">
  编程规范：FunctionToolCallback
  <a class="anchor" href="#%e7%bc%96%e7%a8%8b%e8%a7%84%e8%8c%83functiontoolcallback">#</a>
</h2>
<p>通过以编程方式构建<code>Function</code>ToolCallback，可以将函数类型（<code>Function</code>、<code>Supplier</code>、<code>Consumer</code>或Bi<code>Function</code>）转换为工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeatherService</span> <span style="color:#66d9ef">implements</span> Function<span style="color:#f92672">&lt;</span>WeatherRequest, WeatherResponse<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> WeatherResponse <span style="color:#a6e22e">apply</span>(WeatherRequest request) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> WeatherResponse(30.<span style="color:#a6e22e">0</span>, Unit.<span style="color:#a6e22e">C</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> Unit { C, F }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">record</span> <span style="color:#a6e22e">WeatherRequest</span>(String location, Unit unit) {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">record</span> <span style="color:#a6e22e">WeatherResponse</span>(<span style="color:#66d9ef">double</span> temp, Unit unit) {}
</span></span></code></pre></div><p><code>FunctionToolCallback</code>。Builder允许您构建<code>FunctionToolCallback</code>实例，并提供有关该工具的关键信息：</p>
<ul>
<li>name：工具的名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一上下文中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。必需。</li>
<li>toolFunction：表示工具方法（Function、Supplier、Consumer或BiFunction）的函数对象。必需。</li>
<li>description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</li>
<li>inputType：函数输入的类型。必需。</li>
<li>inputSchema：工具输入参数的JSON模式。如果未提供，则将基于inputType自动生成模式。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。</li>
<li>toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。</li>
<li>toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。
<code>ToolMetadata</code>。Builder允许您构建<code>ToolMetadata</code>实例，并定义工具的其他设置：</li>
<li>returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> FunctionToolCallback
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">builder</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>, <span style="color:#66d9ef">new</span> WeatherService())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputType</span>(WeatherRequest.<span style="color:#a6e22e">class</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>功能输入和输出可以是<code>Void</code>或POJO。输入和输出POJO必须是可序列化的，因为结果将被序列化并发送回模型。函数以及输入和输出类型必须是公共的。
使用编程规范方法时，可以将<code>FunctionToolCallback</code>实例传递给<code>ChatClient</code>的tools（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将默认工具添加到ChatClient。通过将<code>FunctionToolCallback</code>实例传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将<code>FunctionToolCallback</code>实例传递给<code>ToolCallingChatOptions</code>的toolCallbacks（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用编程规范方法时，可以通过将<code>FunctionToolCallback</code>实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的ToolCallbick（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatclient-1">
  将工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-1">#</a>
</h2>
<p>使用编程规范方法时，可以将<code>FunctionToolCallback</code>实例传递给<code>ChatClient</code>的tools（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><h2 id="将默认工具添加到chatclient-2">
  将默认工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-2">#</a>
</h2>
<p>使用编程规范方法时，可以将默认工具添加到ChatClient。通过将<code>FunctionToolCallback</code>实例传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatmodel-2">
  将工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-2">#</a>
</h2>
<p>使用编程规范方法时，可以将<code>FunctionToolCallback</code>实例传递给<code>ToolCallingChatOptions</code>的toolCallbacks（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><h2 id="将默认工具添加到chatmodel-2">
  将默认工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-2">#</a>
</h2>
<p>使用编程规范方法时，可以通过将<code>FunctionToolCallback</code>实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的ToolCallbick（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="动态规范bean">
  动态规范：@Bean
  <a class="anchor" href="#%e5%8a%a8%e6%80%81%e8%a7%84%e8%8c%83bean">#</a>
</h2>
<p>您可以将工具定义为Springbean，并让SpringAI使用<code>ToolCallbackResolver</code>接口（通过SpringBeanToolCallbickResolver实现）在运行时动态解析它们，而不是以编程方式指定工具。该选项允许您使用任何<code>Function</code>、<code>Supplier</code>、<code>Consumer</code>或Bi<code>Function</code>bean作为工具。bean名称将用作工具名称，Spring Framework中的<code>@Description</code>注释可用于提供该工具的描述，模型使用该注释来理解何时以及如何调用该工具。如果不提供描述，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>(proxyBeanMethods <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeatherTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    WeatherService weatherService <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> WeatherService();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>	Function<span style="color:#f92672">&lt;</span>WeatherRequest, WeatherResponse<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">currentWeather</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> weatherService;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将自动生成工具输入参数的JSON模式。您可以使用<code>@ToolParam</code>注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">record</span> <span style="color:#a6e22e">WeatherRequest</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;The name of a city or a country&#34;</span>) String location, Unit unit) {}
</span></span></code></pre></div><p>这种工具规范方法的缺点是不能保证类型安全，因为工具解析是在运行时完成的。为了减轻这种情况，可以使用<code>@Bean</code>注释显式地指定工具名称，并将值存储在常量中，以便可以在聊天请求中使用它，而不是硬编码工具名称。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>(proxyBeanMethods <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeatherTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String CURRENT_WEATHER_TOOL <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;currentWeather&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Bean</span>(CURRENT_WEATHER_TOOL)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>	Function<span style="color:#f92672">&lt;</span>WeatherRequest, WeatherResponse<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">currentWeather</span>() {
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用动态规范方法时，可以将工具名称（即函数bean名称）传递给<code>ChatClient</code>的tools（）方法。
该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>使用动态规范方法时，可以将默认工具添加到ChatClient。通过将工具名称传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用动态规范方法时，可以将工具名称传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的toolNames（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolNames</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用动态规范方法时，可以通过将工具名称传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的toolNames（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolNames</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatclient-2">
  将工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-2">#</a>
</h2>
<p>使用动态规范方法时，可以将工具名称（即函数bean名称）传递给<code>ChatClient</code>的tools（）方法。
该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><h2 id="将默认工具添加到chatclient-3">
  将默认工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-3">#</a>
</h2>
<p>使用动态规范方法时，可以将默认工具添加到ChatClient。通过将工具名称传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatmodel-3">
  将工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-3">#</a>
</h2>
<p>使用动态规范方法时，可以将工具名称传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的toolNames（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolNames</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><h2 id="将默认工具添加到chatmodel-3">
  将默认工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-3">#</a>
</h2>
<p>使用动态规范方法时，可以通过将工具名称传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的toolNames（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolNames</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="功能工具限制">
  功能工具限制
  <a class="anchor" href="#%e5%8a%9f%e8%83%bd%e5%b7%a5%e5%85%b7%e9%99%90%e5%88%b6">#</a>
</h2>
<p>以下类型当前不支持作为用作工具的函数的输入或输出类型：</p>
<ul>
<li>基本体类型</li>
<li>可选</li>
<li>集合类型（例如列表、映射、数组、集合）</li>
<li>异步类型（例如CompletableFuture、Future）</li>
<li>无功类型（例如流量、单声道、通量）。
使用基于方法的工具规范方法支持基元类型和集合。有关详细信息，请参见作为工具的方法。</li>
</ul>
<h2 id="工具规格">
  工具规格
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7%e8%a7%84%e6%a0%bc">#</a>
</h2>
<p>在Spring AI中，工具通过<code>ToolCallback</code>接口建模。在前面的部分中，我们已经看到了如何使用Spring AI提供的内置支持从方法和函数中定义工具（请参见
  <a href="../../../#_methods_as_tools">方法作为工具</a>和函数作为工具）。本节将深入研究工具规范，以及如何定制和扩展它以支持更多用例。
<code>ToolCallback</code>接口提供了一种定义AI模型可以调用的工具的方法，包括定义和执行逻辑。当您想要从头定义工具时，它是要实现的主界面。例如，可以从MCP客户端（使用模型上下文协议）或<code>ChatClient</code>（构建模块化代理应用程序）定义<code>ToolCallback</code>。
该接口提供以下方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolCallback</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Definition used by the AI model to determine when and how to call the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	ToolDefinition <span style="color:#a6e22e">getToolDefinition</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Metadata providing additional information on how to handle the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	ToolMetadata <span style="color:#a6e22e">getToolMetadata</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Execute tool with the given input and return the result to send back to the AI model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">call</span>(String toolInput);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Execute tool with the given input and context, and return the result to send back to the AI model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">call</span>(String toolInput, ToolContext tooContext);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Spring AI为工具方法（<code>MethodToolCallback</code>）和工具函数（FunctionToolCallbak）提供了内置实现。
<code>ToolDefinition</code>接口为AI模型提供所需的信息，以了解工具的可用性，包括工具名称、描述和输入模式。每个<code>ToolCallback</code>实现都必须提供<code>ToolDefinition</code>实例来定义工具。
该接口提供以下方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolDefinition</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * The tool name. Unique within the tool set provided to a model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">name</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * The tool description, used by the AI model to determine what the tool does.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">description</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * The schema of the parameters used to call the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">inputSchema</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>工具定义。Builder允许使用默认实现（Default<code>ToolDefinition</code>）构建<code>ToolDefinition</code>Instance。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">name</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputSchema</span>(<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;type&#34;: &#34;object&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;properties&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;location&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    &#34;type&#34;: &#34;string&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;unit&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    &#34;type&#34;: &#34;string&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    &#34;enum&#34;: [&#34;C&#34;, &#34;F&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;required&#34;: [&#34;location&#34;, &#34;unit&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>从方法生成工具时，将自动为您生成<code>ToolDefinition</code>。如果您希望自己生成<code>ToolDefinition</code>，则可以使用此方便的生成器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">from</span>(method);
</span></span></code></pre></div><p>从方法生成的<code>ToolDefinition</code>包括作为工具名称的方法名、作为工具描述的方法名以及方法输入参数的JSON模式。如果使用<code>@Tool</code>对方法进行注释，则工具名称和描述将从注释中获取（如果设置）。
如果希望显式提供部分或全部属性，则可以使用<code>ToolDefinition</code>。生成器以生成自定义<code>ToolDefinition</code>实例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">name</span>(<span style="color:#e6db74">&#34;currentDateTime&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputSchema</span>(JsonSchemaGenerator.<span style="color:#a6e22e">generateForMethodInput</span>(method))
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>从函数构建工具时，将自动为您生成工具定义。使用<code>FunctionToolCallback</code>时。生成器以生成<code>FunctionToolCallback</code>实例，则可以提供将用于生成<code>ToolDefinition</code>的工具名称、描述和输入架构。有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。
当为AI模型提供工具时，模型需要知道用于调用该工具的输入类型的模式。模式用于理解如何调用工具和准备工具请求。SpringAI通过<code>JsonSchemaGenerator</code>类为工具生成输入类型的JSONSchema提供了内置支持。架构作为<code>ToolDefinition</code>的一部分提供。
<code>JsonSchemaGenerator</code>类在幕后用于为方法或函数的输入参数生成JSON模式，使用Methods as Tools和Functions as Tools中描述的任何策略。JSON模式生成逻辑支持一系列注释，您可以对方法和函数的输入参数使用这些注释来定制结果模式。
本节描述在为工具的输入参数生成JSON模式时可以定制的两个主要选项：描述和所需状态。
除了为工具本身提供描述外，还可以为工具的输入参数提供描述。描述可用于提供有关输入参数的关键信息，例如参数应采用何种格式、允许使用何种值等。这有助于帮助模型理解输入模式以及如何使用它。Spring AI为使用以下注释之一生成输入参数的描述提供了内置支持：</p>
<ul>
<li>@Spring AI的ToolParam（description=“…”）</li>
<li>@来自Jackson的JsonClassDescription（description=“…”）</li>
<li>@来自Jackson的JsonPropertyDescription（description=“…”）</li>
<li>@Swagger的架构（description=“…”）。
这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>默认情况下，每个输入参数都被认为是必需的，这迫使AI模型在调用工具时为其提供值。然而，可以通过使用以下注释之一（按优先级顺序）使输入参数成为可选的：</p>
<ul>
<li>@Spring AI的ToolParam（必需=假）</li>
<li>@Jackson的JsonProperty（必需=false）</li>
<li>@Swagger的架构（必需=假）</li>
<li>@从Spring Framework可以为Null。
这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Update customer information&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updateCustomerInfo</span>(Long id, String name, <span style="color:#a6e22e">@ToolParam</span>(required <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>) String email) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Updated info for customer with id: &#34;</span> <span style="color:#f92672">+</span> id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>工具调用的结果使用<code>ToolCallResultConverter</code>序列化，然后发送回AI模型。<code>ToolCallResultConverter</code>接口提供了一种将工具调用的结果转换为<code>String</code>对象的方法。
该接口提供以下方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@FunctionalInterface</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolCallResultConverter</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Given an Object returned by a tool, convert it to a String compatible with the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * given class type.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">convert</span>(<span style="color:#a6e22e">@Nullable</span> Object result, <span style="color:#a6e22e">@Nullable</span> Type returnType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结果必须是可序列化类型。默认情况下，使用Jackson（<code>Default</code>ToolCallResultConverter``）将结果序列化为JSON，但您可以通过提供自己的ToolCallresultConvertor实现来定制序列化过程。
Spring AI在方法和函数工具中都依赖于<code>ToolCallResultConverter</code>。
从具有声明性方法的方法构建工具时，可以通过设置@tool注释的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>, resultConverter <span style="color:#f92672">=</span> CustomToolCallResultConverter.<span style="color:#a6e22e">class</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用编程方法，则可以通过设置MethodToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。
有关详细信息，请参见作为工具的方法。
使用编程方法从函数构建工具时，可以通过设置FunctionToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。
有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。
Spring AI支持通过<code>ToolContext</code> API将额外的上下文信息传递给工具。此功能允许您提供额外的用户提供的数据，这些数据可以与AI模型传递的工具参数一起在工具执行中使用。

  <img src="../../../images/tools/tool-context.jpg" alt="为工具提供其他上下文信息" /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id, ToolContext toolContext) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id, toolContext.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;tenantId&#34;</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ToolContext</code>由用户在调用<code>ChatClient</code>时提供的数据填充。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String response <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;Tell me more about the customer with ID 42&#34;</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> CustomerTools())
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">toolContext</span>(Map.<span style="color:#a6e22e">of</span>(<span style="color:#e6db74">&#34;tenantId&#34;</span>, <span style="color:#e6db74">&#34;acme&#34;</span>))
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">content</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(response);
</span></span></code></pre></div><p>类似地，您可以在直接调用<code>ChatModel</code>时定义工具上下文数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> customerTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> CustomerTools());
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(customerTools)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolContext</span>(Map.<span style="color:#a6e22e">of</span>(<span style="color:#e6db74">&#34;tenantId&#34;</span>, <span style="color:#e6db74">&#34;acme&#34;</span>))
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;Tell me more about the customer with ID 42&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>如果在默认选项和运行时选项中都设置了<code>toolContext</code>选项，则生成的<code>toolContext</code>将是这两个选项的合并，
其中运行时选项优先于默认选项。
默认情况下，工具调用的结果作为响应发送回模型。然后，模型可以使用结果来继续对话。
在某些情况下，您宁愿将结果直接返回给调用者，而不是将其发送回模型。例如，如果构建依赖于RAG工具的代理，则可能希望将结果直接返回给调用者，而不是将其发送回模型进行不必要的后处理。或者，您可能有某些工具可以结束代理的推理循环。
每个<code>ToolCallback</code>实现都可以定义是将工具调用的结果直接返回给调用者，还是发送回模型。默认情况下，结果被发送回模型。但您可以根据工具更改此行为。
<code>ToolCallingManager</code>负责管理工具执行生命周期，负责处理与工具关联的<code>returnDirect</code>属性。如果属性设置为<code>true</code>，则工具调用的结果将直接返回给调用者。否则，结果将发送回模型。

  <img src="../../../images/tools/return-direct.jpg" alt="将工具调用结果直接返回给调用者" />
从具有声明性方法的方法构建工具时，可以通过将@tool注释的<code>returnDirect</code>属性设置为<code>true</code>来标记工具以直接将结果返回给调用方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>, returnDirect <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用编程方法，则可以通过<code>ToolMetadata</code>接口设置<code>returnDirect</code>属性，并将其传递给MethodToolCallback。建筑商。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolMetadata toolMetadata <span style="color:#f92672">=</span> ToolMetadata.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">returnDirect</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>有关详细信息，请参见作为工具的方法。
使用编程方法从函数构建工具时，可以通过<code>ToolMetadata</code>接口设置<code>returnDirect</code>属性，并将其传递给FunctionToolCallback。建筑商。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolMetadata toolMetadata <span style="color:#f92672">=</span> ToolMetadata.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">returnDirect</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</p>
<h2 id="工具回调">
  工具回调
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7%e5%9b%9e%e8%b0%83">#</a>
</h2>
<p><code>ToolCallback</code>接口提供了一种定义AI模型可以调用的工具的方法，包括定义和执行逻辑。当您想要从头定义工具时，它是要实现的主界面。例如，可以从MCP客户端（使用模型上下文协议）或<code>ChatClient</code>（构建模块化代理应用程序）定义<code>ToolCallback</code>。
该接口提供以下方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolCallback</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Definition used by the AI model to determine when and how to call the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	ToolDefinition <span style="color:#a6e22e">getToolDefinition</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Metadata providing additional information on how to handle the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	ToolMetadata <span style="color:#a6e22e">getToolMetadata</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Execute tool with the given input and return the result to send back to the AI model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">call</span>(String toolInput);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Execute tool with the given input and context, and return the result to send back to the AI model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">call</span>(String toolInput, ToolContext tooContext);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Spring AI为工具方法（<code>MethodToolCallback</code>）和工具函数（FunctionToolCallbak）提供了内置实现。</p>
<h2 id="刀具定义">
  刀具定义
  <a class="anchor" href="#%e5%88%80%e5%85%b7%e5%ae%9a%e4%b9%89">#</a>
</h2>
<p><code>ToolDefinition</code>接口为AI模型提供所需的信息，以了解工具的可用性，包括工具名称、描述和输入模式。每个<code>ToolCallback</code>实现都必须提供<code>ToolDefinition</code>实例来定义工具。
该接口提供以下方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolDefinition</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * The tool name. Unique within the tool set provided to a model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">name</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * The tool description, used by the AI model to determine what the tool does.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">description</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * The schema of the parameters used to call the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">inputSchema</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>工具定义。Builder允许使用默认实现（Default<code>ToolDefinition</code>）构建<code>ToolDefinition</code>Instance。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">name</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputSchema</span>(<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;type&#34;: &#34;object&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;properties&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;location&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    &#34;type&#34;: &#34;string&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;unit&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    &#34;type&#34;: &#34;string&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    &#34;enum&#34;: [&#34;C&#34;, &#34;F&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;required&#34;: [&#34;location&#34;, &#34;unit&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>从方法生成工具时，将自动为您生成<code>ToolDefinition</code>。如果您希望自己生成<code>ToolDefinition</code>，则可以使用此方便的生成器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">from</span>(method);
</span></span></code></pre></div><p>从方法生成的<code>ToolDefinition</code>包括作为工具名称的方法名、作为工具描述的方法名以及方法输入参数的JSON模式。如果使用<code>@Tool</code>对方法进行注释，则工具名称和描述将从注释中获取（如果设置）。
如果希望显式提供部分或全部属性，则可以使用<code>ToolDefinition</code>。生成器以生成自定义<code>ToolDefinition</code>实例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">name</span>(<span style="color:#e6db74">&#34;currentDateTime&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputSchema</span>(JsonSchemaGenerator.<span style="color:#a6e22e">generateForMethodInput</span>(method))
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>从函数构建工具时，将自动为您生成工具定义。使用<code>FunctionToolCallback</code>时。生成器以生成<code>FunctionToolCallback</code>实例，则可以提供将用于生成<code>ToolDefinition</code>的工具名称、描述和输入架构。有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</p>
<h2 id="方法工具定义">
  方法工具定义
  <a class="anchor" href="#%e6%96%b9%e6%b3%95%e5%b7%a5%e5%85%b7%e5%ae%9a%e4%b9%89">#</a>
</h2>
<p>从方法生成工具时，将自动为您生成<code>ToolDefinition</code>。如果您希望自己生成<code>ToolDefinition</code>，则可以使用此方便的生成器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">from</span>(method);
</span></span></code></pre></div><p>从方法生成的<code>ToolDefinition</code>包括作为工具名称的方法名、作为工具描述的方法名以及方法输入参数的JSON模式。如果使用<code>@Tool</code>对方法进行注释，则工具名称和描述将从注释中获取（如果设置）。
如果希望显式提供部分或全部属性，则可以使用<code>ToolDefinition</code>。生成器以生成自定义<code>ToolDefinition</code>实例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">name</span>(<span style="color:#e6db74">&#34;currentDateTime&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputSchema</span>(JsonSchemaGenerator.<span style="color:#a6e22e">generateForMethodInput</span>(method))
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="功能工具定义">
  功能工具定义
  <a class="anchor" href="#%e5%8a%9f%e8%83%bd%e5%b7%a5%e5%85%b7%e5%ae%9a%e4%b9%89">#</a>
</h2>
<p>从函数构建工具时，将自动为您生成工具定义。使用<code>FunctionToolCallback</code>时。生成器以生成<code>FunctionToolCallback</code>实例，则可以提供将用于生成<code>ToolDefinition</code>的工具名称、描述和输入架构。有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</p>
<h2 id="json架构">
  JSON架构
  <a class="anchor" href="#json%e6%9e%b6%e6%9e%84">#</a>
</h2>
<p>当为AI模型提供工具时，模型需要知道用于调用该工具的输入类型的模式。模式用于理解如何调用工具和准备工具请求。SpringAI通过<code>JsonSchemaGenerator</code>类为工具生成输入类型的JSONSchema提供了内置支持。架构作为<code>ToolDefinition</code>的一部分提供。
<code>JsonSchemaGenerator</code>类在幕后用于为方法或函数的输入参数生成JSON模式，使用Methods as Tools和Functions as Tools中描述的任何策略。JSON模式生成逻辑支持一系列注释，您可以对方法和函数的输入参数使用这些注释来定制结果模式。
本节描述在为工具的输入参数生成JSON模式时可以定制的两个主要选项：描述和所需状态。
除了为工具本身提供描述外，还可以为工具的输入参数提供描述。描述可用于提供有关输入参数的关键信息，例如参数应采用何种格式、允许使用何种值等。这有助于帮助模型理解输入模式以及如何使用它。Spring AI为使用以下注释之一生成输入参数的描述提供了内置支持：</p>
<ul>
<li>@Spring AI的ToolParam（description=“…”）</li>
<li>@来自Jackson的JsonClassDescription（description=“…”）</li>
<li>@来自Jackson的JsonPropertyDescription（description=“…”）</li>
<li>@Swagger的架构（description=“…”）。
这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>默认情况下，每个输入参数都被认为是必需的，这迫使AI模型在调用工具时为其提供值。然而，可以通过使用以下注释之一（按优先级顺序）使输入参数成为可选的：</p>
<ul>
<li>@Spring AI的ToolParam（必需=假）</li>
<li>@Jackson的JsonProperty（必需=false）</li>
<li>@Swagger的架构（必需=假）</li>
<li>@从Spring Framework可以为Null。
这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Update customer information&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updateCustomerInfo</span>(Long id, String name, <span style="color:#a6e22e">@ToolParam</span>(required <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>) String email) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Updated info for customer with id: &#34;</span> <span style="color:#f92672">+</span> id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="描述">
  描述
  <a class="anchor" href="#%e6%8f%8f%e8%bf%b0">#</a>
</h2>
<p>除了为工具本身提供描述外，还可以为工具的输入参数提供描述。描述可用于提供有关输入参数的关键信息，例如参数应采用何种格式、允许使用何种值等。这有助于帮助模型理解输入模式以及如何使用它。Spring AI为使用以下注释之一生成输入参数的描述提供了内置支持：</p>
<ul>
<li>@Spring AI的ToolParam（description=“…”）</li>
<li>@来自Jackson的JsonClassDescription（description=“…”）</li>
<li>@来自Jackson的JsonPropertyDescription（description=“…”）</li>
<li>@Swagger的架构（description=“…”）。
这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="必需可选">
  必需/可选
  <a class="anchor" href="#%e5%bf%85%e9%9c%80%e5%8f%af%e9%80%89">#</a>
</h2>
<p>默认情况下，每个输入参数都被认为是必需的，这迫使AI模型在调用工具时为其提供值。然而，可以通过使用以下注释之一（按优先级顺序）使输入参数成为可选的：</p>
<ul>
<li>@Spring AI的ToolParam（必需=假）</li>
<li>@Jackson的JsonProperty（必需=false）</li>
<li>@Swagger的架构（必需=假）</li>
<li>@从Spring Framework可以为Null。
这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Update customer information&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updateCustomerInfo</span>(Long id, String name, <span style="color:#a6e22e">@ToolParam</span>(required <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>) String email) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Updated info for customer with id: &#34;</span> <span style="color:#f92672">+</span> id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="结果转换">
  结果转换
  <a class="anchor" href="#%e7%bb%93%e6%9e%9c%e8%bd%ac%e6%8d%a2">#</a>
</h2>
<p>工具调用的结果使用<code>ToolCallResultConverter</code>序列化，然后发送回AI模型。<code>ToolCallResultConverter</code>接口提供了一种将工具调用的结果转换为<code>String</code>对象的方法。
该接口提供以下方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@FunctionalInterface</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolCallResultConverter</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Given an Object returned by a tool, convert it to a String compatible with the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * given class type.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">convert</span>(<span style="color:#a6e22e">@Nullable</span> Object result, <span style="color:#a6e22e">@Nullable</span> Type returnType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结果必须是可序列化类型。默认情况下，使用Jackson（<code>Default</code>ToolCallResultConverter``）将结果序列化为JSON，但您可以通过提供自己的ToolCallresultConvertor实现来定制序列化过程。
Spring AI在方法和函数工具中都依赖于<code>ToolCallResultConverter</code>。
从具有声明性方法的方法构建工具时，可以通过设置@tool注释的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>, resultConverter <span style="color:#f92672">=</span> CustomToolCallResultConverter.<span style="color:#a6e22e">class</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用编程方法，则可以通过设置MethodToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。
有关详细信息，请参见作为工具的方法。
使用编程方法从函数构建工具时，可以通过设置FunctionToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。
有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</p>
<h2 id="方法工具调用结果转换">
  方法工具调用结果转换
  <a class="anchor" href="#%e6%96%b9%e6%b3%95%e5%b7%a5%e5%85%b7%e8%b0%83%e7%94%a8%e7%bb%93%e6%9e%9c%e8%bd%ac%e6%8d%a2">#</a>
</h2>
<p>从具有声明性方法的方法构建工具时，可以通过设置@tool注释的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>, resultConverter <span style="color:#f92672">=</span> CustomToolCallResultConverter.<span style="color:#a6e22e">class</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用编程方法，则可以通过设置MethodToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。
有关详细信息，请参见作为工具的方法。</p>
<h2 id="函数工具调用结果转换">
  函数工具调用结果转换
  <a class="anchor" href="#%e5%87%bd%e6%95%b0%e5%b7%a5%e5%85%b7%e8%b0%83%e7%94%a8%e7%bb%93%e6%9e%9c%e8%bd%ac%e6%8d%a2">#</a>
</h2>
<p>使用编程方法从函数构建工具时，可以通过设置FunctionToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。
有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</p>
<h2 id="工具上下文">
  工具上下文
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7%e4%b8%8a%e4%b8%8b%e6%96%87">#</a>
</h2>
<p>Spring AI支持通过<code>ToolContext</code> API将额外的上下文信息传递给工具。此功能允许您提供额外的用户提供的数据，这些数据可以与AI模型传递的工具参数一起在工具执行中使用。

  <img src="../../../images/tools/tool-context.jpg" alt="为工具提供其他上下文信息" /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id, ToolContext toolContext) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id, toolContext.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;tenantId&#34;</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ToolContext</code>由用户在调用<code>ChatClient</code>时提供的数据填充。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String response <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;Tell me more about the customer with ID 42&#34;</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> CustomerTools())
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">toolContext</span>(Map.<span style="color:#a6e22e">of</span>(<span style="color:#e6db74">&#34;tenantId&#34;</span>, <span style="color:#e6db74">&#34;acme&#34;</span>))
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">content</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(response);
</span></span></code></pre></div><p>类似地，您可以在直接调用<code>ChatModel</code>时定义工具上下文数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> customerTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> CustomerTools());
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(customerTools)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolContext</span>(Map.<span style="color:#a6e22e">of</span>(<span style="color:#e6db74">&#34;tenantId&#34;</span>, <span style="color:#e6db74">&#34;acme&#34;</span>))
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;Tell me more about the customer with ID 42&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>如果在默认选项和运行时选项中都设置了<code>toolContext</code>选项，则生成的<code>toolContext</code>将是这两个选项的合并，
其中运行时选项优先于默认选项。</p>
<h2 id="直接退货">
  直接退货
  <a class="anchor" href="#%e7%9b%b4%e6%8e%a5%e9%80%80%e8%b4%a7">#</a>
</h2>
<p>默认情况下，工具调用的结果作为响应发送回模型。然后，模型可以使用结果来继续对话。
在某些情况下，您宁愿将结果直接返回给调用者，而不是将其发送回模型。例如，如果构建依赖于RAG工具的代理，则可能希望将结果直接返回给调用者，而不是将其发送回模型进行不必要的后处理。或者，您可能有某些工具可以结束代理的推理循环。
每个<code>ToolCallback</code>实现都可以定义是将工具调用的结果直接返回给调用者，还是发送回模型。默认情况下，结果被发送回模型。但您可以根据工具更改此行为。
<code>ToolCallingManager</code>负责管理工具执行生命周期，负责处理与工具关联的<code>returnDirect</code>属性。如果属性设置为<code>true</code>，则工具调用的结果将直接返回给调用者。否则，结果将发送回模型。

  <img src="../../../images/tools/return-direct.jpg" alt="将工具调用结果直接返回给调用者" />
从具有声明性方法的方法构建工具时，可以通过将@tool注释的<code>returnDirect</code>属性设置为<code>true</code>来标记工具以直接将结果返回给调用方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>, returnDirect <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用编程方法，则可以通过<code>ToolMetadata</code>接口设置<code>returnDirect</code>属性，并将其传递给MethodToolCallback。建筑商。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolMetadata toolMetadata <span style="color:#f92672">=</span> ToolMetadata.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">returnDirect</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>有关详细信息，请参见作为工具的方法。
使用编程方法从函数构建工具时，可以通过<code>ToolMetadata</code>接口设置<code>returnDirect</code>属性，并将其传递给FunctionToolCallback。建筑商。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolMetadata toolMetadata <span style="color:#f92672">=</span> ToolMetadata.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">returnDirect</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</p>
<h2 id="方法直接返回">
  方法直接返回
  <a class="anchor" href="#%e6%96%b9%e6%b3%95%e7%9b%b4%e6%8e%a5%e8%bf%94%e5%9b%9e">#</a>
</h2>
<p>从具有声明性方法的方法构建工具时，可以通过将@tool注释的<code>returnDirect</code>属性设置为<code>true</code>来标记工具以直接将结果返回给调用方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>, returnDirect <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用编程方法，则可以通过<code>ToolMetadata</code>接口设置<code>returnDirect</code>属性，并将其传递给MethodToolCallback。建筑商。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolMetadata toolMetadata <span style="color:#f92672">=</span> ToolMetadata.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">returnDirect</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>有关详细信息，请参见作为工具的方法。</p>
<h2 id="函数直接返回">
  函数直接返回
  <a class="anchor" href="#%e5%87%bd%e6%95%b0%e7%9b%b4%e6%8e%a5%e8%bf%94%e5%9b%9e">#</a>
</h2>
<p>使用编程方法从函数构建工具时，可以通过<code>ToolMetadata</code>接口设置<code>returnDirect</code>属性，并将其传递给FunctionToolCallback。建筑商。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolMetadata toolMetadata <span style="color:#f92672">=</span> ToolMetadata.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">returnDirect</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</p>
<h2 id="刀具执行">
  刀具执行
  <a class="anchor" href="#%e5%88%80%e5%85%b7%e6%89%a7%e8%a1%8c">#</a>
</h2>
<p>工具执行是使用提供的输入参数调用工具并返回结果的过程。工具执行由<code>ToolCallingManager</code>接口处理，该接口负责管理工具执行生命周期。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolCallingManager</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Resolve the tool definitions from the model&#39;s tool calling options.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	List<span style="color:#f92672">&lt;</span>ToolDefinition<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">resolveToolDefinitions</span>(ToolCallingChatOptions chatOptions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Execute the tool calls requested by the model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	ToolExecutionResult <span style="color:#a6e22e">executeToolCalls</span>(Prompt prompt, ChatResponse chatResponse);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果您正在使用任何Spring AI Spring Boot Starters，`Default<code>ToolCallingManager```是ToolCalling Manager接口的自动配置实现。您可以通过提供自己的</code>ToolCallingManager``bean来定制工具执行行为。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>ToolCallingManager <span style="color:#a6e22e">toolCallingManager</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ToolCallingManager.<span style="color:#a6e22e">builder</span>().<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>默认情况下，Spring AI从每个<code>ChatModel</code>实现中为您透明地管理工具执行生命周期。但您有可能选择退出此行为，并自行控制工具的执行。本节描述这两个场景。
当使用默认行为时，Spring AI将自动拦截来自模型的任何工具调用请求，调用该工具并将结果返回给模型。所有这些都是通过使用<code>ToolCallingManager</code>的每个<code>ChatModel</code>实现为您透明地完成的。

  <img src="../../../images/tools/framework-manager.jpg" alt="框架控制的工具执行生命周期" />
在某些情况下，您宁愿自己控制工具执行生命周期。可以通过将<code>ToolCallingChatOptions</code>的<code>internalToolExecutionEnabled</code>属性设置为<code>false</code>来完成此操作。
或者，您可以实现<code>ToolExecutionEligibilityPredicate</code>谓词来控制工具执行合格性。
默认谓词实现如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DefaultToolExecutionEligibilityPredicate</span> <span style="color:#66d9ef">implements</span> ToolExecutionEligibilityPredicate {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span>(ChatOptions promptOptions, ChatResponse chatResponse) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ToolCallingChatOptions.<span style="color:#a6e22e">isInternalToolExecutionEnabled</span>(promptOptions) <span style="color:#f92672">&amp;&amp;</span> chatResponse <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">&amp;&amp;</span> chatResponse.<span style="color:#a6e22e">hasToolCalls</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用此选项调用<code>ChatModel</code>时，工具执行将委托给调用者，使您能够完全控制工具执行生命周期。您的责任是检查<code>ChatResponse</code>中的工具调用，并使用<code>ToolCallingManager</code>执行它们。
下面的示例演示了用户控制的工具执行方法的最小实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallingManager toolCallingManager <span style="color:#f92672">=</span> ToolCallingManager.<span style="color:#a6e22e">builder</span>().<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(<span style="color:#66d9ef">new</span> CustomerTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">internalToolExecutionEnabled</span>(<span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;Tell me more about the customer with ID 42&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ChatResponse chatResponse <span style="color:#f92672">=</span> chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (chatResponse.<span style="color:#a6e22e">hasToolCalls</span>()) {
</span></span><span style="display:flex;"><span>    ToolExecutionResult toolExecutionResult <span style="color:#f92672">=</span> toolCallingManager.<span style="color:#a6e22e">executeToolCalls</span>(prompt, chatResponse);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(toolExecutionResult.<span style="color:#a6e22e">conversationHistory</span>(), chatOptions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    chatResponse <span style="color:#f92672">=</span> chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(chatResponse.<span style="color:#a6e22e">getResult</span>().<span style="color:#a6e22e">getOutput</span>().<span style="color:#a6e22e">getText</span>());
</span></span></code></pre></div><p>当工具调用失败时，异常将作为<code>ToolExecutionException</code>传播，可以捕获该异常来处理错误。<code>ToolExecutionException</code>Processor可用于处理ToolExectionException，具有两个结果：要么生成要发送回AI模型的错误消息，要么引发要由调用方处理的异常。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@FunctionalInterface</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolExecutionExceptionProcessor</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Convert an exception thrown by a tool to a String that can be sent back to the AI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * model or throw an exception to be handled by the caller.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">process</span>(ToolExecutionException exception);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果您正在使用任何Spring AI Spring Boot Starters，<code>Default</code>ToolExecutionExceptionProcessor<code>是ToolExectionException处理器接口的自动配置实现。默认情况下，错误消息被发送回模型。`Default`ToolExecutionExceptionProcessor</code>构造函数允许将<code>alwaysThrow</code>属性设置为<code>true</code>或<code>false</code>。如果为<code>true</code>，则将引发异常，而不是将错误消息发送回模型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>ToolExecutionExceptionProcessor <span style="color:#a6e22e">toolExecutionExceptionProcessor</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> DefaultToolExecutionExceptionProcessor(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ToolExecutionExceptionProcessor</code>由默认<code>ToolCallingManager</code>（DefaultToolCalling Manager）在内部使用，以处理工具执行期间的异常。有关工具执行生命周期的更多详细信息，请参见工具执行。</p>
<h2 id="框架控制的工具执行">
  框架控制的工具执行
  <a class="anchor" href="#%e6%a1%86%e6%9e%b6%e6%8e%a7%e5%88%b6%e7%9a%84%e5%b7%a5%e5%85%b7%e6%89%a7%e8%a1%8c">#</a>
</h2>
<p>当使用默认行为时，Spring AI将自动拦截来自模型的任何工具调用请求，调用该工具并将结果返回给模型。所有这些都是通过使用<code>ToolCallingManager</code>的每个<code>ChatModel</code>实现为您透明地完成的。

  <img src="../../../images/tools/framework-manager.jpg" alt="框架控制的工具执行生命周期" /></p>
<h2 id="用户控制的工具执行">
  用户控制的工具执行
  <a class="anchor" href="#%e7%94%a8%e6%88%b7%e6%8e%a7%e5%88%b6%e7%9a%84%e5%b7%a5%e5%85%b7%e6%89%a7%e8%a1%8c">#</a>
</h2>
<p>在某些情况下，您宁愿自己控制工具执行生命周期。可以通过将<code>ToolCallingChatOptions</code>的<code>internalToolExecutionEnabled</code>属性设置为<code>false</code>来完成此操作。
或者，您可以实现<code>ToolExecutionEligibilityPredicate</code>谓词来控制工具执行合格性。
默认谓词实现如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DefaultToolExecutionEligibilityPredicate</span> <span style="color:#66d9ef">implements</span> ToolExecutionEligibilityPredicate {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span>(ChatOptions promptOptions, ChatResponse chatResponse) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ToolCallingChatOptions.<span style="color:#a6e22e">isInternalToolExecutionEnabled</span>(promptOptions) <span style="color:#f92672">&amp;&amp;</span> chatResponse <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">&amp;&amp;</span> chatResponse.<span style="color:#a6e22e">hasToolCalls</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用此选项调用<code>ChatModel</code>时，工具执行将委托给调用者，使您能够完全控制工具执行生命周期。您的责任是检查<code>ChatResponse</code>中的工具调用，并使用<code>ToolCallingManager</code>执行它们。
下面的示例演示了用户控制的工具执行方法的最小实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallingManager toolCallingManager <span style="color:#f92672">=</span> ToolCallingManager.<span style="color:#a6e22e">builder</span>().<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(<span style="color:#66d9ef">new</span> CustomerTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">internalToolExecutionEnabled</span>(<span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;Tell me more about the customer with ID 42&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ChatResponse chatResponse <span style="color:#f92672">=</span> chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (chatResponse.<span style="color:#a6e22e">hasToolCalls</span>()) {
</span></span><span style="display:flex;"><span>    ToolExecutionResult toolExecutionResult <span style="color:#f92672">=</span> toolCallingManager.<span style="color:#a6e22e">executeToolCalls</span>(prompt, chatResponse);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(toolExecutionResult.<span style="color:#a6e22e">conversationHistory</span>(), chatOptions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    chatResponse <span style="color:#f92672">=</span> chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(chatResponse.<span style="color:#a6e22e">getResult</span>().<span style="color:#a6e22e">getOutput</span>().<span style="color:#a6e22e">getText</span>());
</span></span></code></pre></div><h2 id="异常处理">
  异常处理
  <a class="anchor" href="#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86">#</a>
</h2>
<p>当工具调用失败时，异常将作为<code>ToolExecutionException</code>传播，可以捕获该异常来处理错误。<code>ToolExecutionException</code>Processor可用于处理ToolExectionException，具有两个结果：要么生成要发送回AI模型的错误消息，要么引发要由调用方处理的异常。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@FunctionalInterface</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolExecutionExceptionProcessor</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Convert an exception thrown by a tool to a String that can be sent back to the AI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * model or throw an exception to be handled by the caller.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">process</span>(ToolExecutionException exception);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果您正在使用任何Spring AI Spring Boot Starters，<code>Default</code>ToolExecutionExceptionProcessor<code>是ToolExectionException处理器接口的自动配置实现。默认情况下，错误消息被发送回模型。`Default`ToolExecutionExceptionProcessor</code>构造函数允许将<code>alwaysThrow</code>属性设置为<code>true</code>或<code>false</code>。如果为<code>true</code>，则将引发异常，而不是将错误消息发送回模型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>ToolExecutionExceptionProcessor <span style="color:#a6e22e">toolExecutionExceptionProcessor</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> DefaultToolExecutionExceptionProcessor(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ToolExecutionExceptionProcessor</code>由默认<code>ToolCallingManager</code>（DefaultToolCalling Manager）在内部使用，以处理工具执行期间的异常。有关工具执行生命周期的更多详细信息，请参见工具执行。</p>
<h2 id="工具分辨率">
  工具分辨率
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7%e5%88%86%e8%be%a8%e7%8e%87">#</a>
</h2>
<p>将工具传递到模型的主要方法是在调用<code>ChatClient</code>或<code>ChatModel</code>时提供<code>ToolCallback</code>，
使用
  <a href="../../../#_methods_as_tools">方法作为工具</a>和功能作为工具中描述的策略之一。
然而，Spring AI还支持使用<code>ToolCallbackResolver</code>接口在运行时动态解析工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolCallbackResolver</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Resolve the {@link ToolCallback} for the given tool name.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Nullable</span>
</span></span><span style="display:flex;"><span>	ToolCallback <span style="color:#a6e22e">resolve</span>(String toolName);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用此方法时：</p>
<ul>
<li>在客户端，将工具名称提供给ChatClient或ChatModel，而不是ToolCallback。</li>
<li>在服务器端，ToolCallbackResolver实现负责将工具名称解析为相应的ToolCallbak实例。
默认情况下，Spring AI依赖于<code>Delegating</code>ToolCallbackResolver``，后者将工具解析委托给ToolCallbakResolver实例列表：</li>
<li>SpringBeanToolCallbackResolver从Function、Supplier、Consumer或BiFunction类型的SpringBean解析工具。有关详细信息，请参阅动态规范：@Bean。</li>
<li>StaticToolCallbackResolver从ToolCallbak实例的静态列表中解析工具。当使用SpringBoot自动配置时，该解析器自动配置为应用程序上下文中定义的所有ToolCallback类型的bean。
如果依赖于SpringBoot自动配置，则可以通过提供自定义<code>ToolCallbackResolver</code>bean来定制解析逻辑。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>ToolCallbackResolver <span style="color:#a6e22e">toolCallbackResolver</span>(List<span style="color:#f92672">&lt;</span>FunctionCallback<span style="color:#f92672">&gt;</span> toolCallbacks) {
</span></span><span style="display:flex;"><span>    StaticToolCallbackResolver staticToolCallbackResolver <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StaticToolCallbackResolver(toolCallbacks);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> DelegatingToolCallbackResolver(List.<span style="color:#a6e22e">of</span>(staticToolCallbackResolver));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ToolCallbackResolver</code>由<code>ToolCallingManager</code>在内部使用，以在运行时动态解析工具，支持
  <a href="../../../#_framework_controlled_tool_execution">框架控制的工具执行</a>和用户控制的工具运行。</p>
<h2 id="可观察性">
  可观察性
  <a class="anchor" href="#%e5%8f%af%e8%a7%82%e5%af%9f%e6%80%a7">#</a>
</h2>
<p>工具调用的检测正在进行中。现在，您可以使用日志功能来跟踪工具调用操作。
刀具调用功能的所有主要操作都在<code>DEBUG</code>级别记录。您可以通过将<code>org.springframework.ai</code>包的日志级别设置为<code>DEBUG</code>来启用日志记录。</p>
<h2 id="日志记录">
  日志记录
  <a class="anchor" href="#%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95">#</a>
</h2>
<p>刀具调用功能的所有主要操作都在<code>DEBUG</code>级别记录。您可以通过将<code>org.springframework.ai</code>包的日志级别设置为<code>DEBUG</code>来启用日志记录。</p>
<h2 id="信息检索-1">
  信息检索
  <a class="anchor" href="#%e4%bf%a1%e6%81%af%e6%a3%80%e7%b4%a2-1">#</a>
</h2>
<p>该版本仍在开发中，尚不稳定。对于最新的快照版本，请使用Spring AI 1.0.0-snapshot！
工具调用（也称为函数调用）是人工智能应用程序中的一种常见模式，允许模型与一组API或工具交互，以增强其功能。
工具主要用于：</p>
<ul>
<li>信息检索。此类别中的工具可用于从外部源（如数据库、web服务、文件系统或web搜索引擎）检索信息。目标是增加模型的知识，使其能够回答否则无法回答的问题。因此，它们可以用于检索增强生成（RAG）场景。例如，工具可以用于检索给定位置的当前天气、检索最新的新闻文章或查询数据库中的特定记录。</li>
<li>采取行动。此类别中的工具可用于在软件系统中执行操作，例如发送电子邮件、在数据库中创建新记录、提交表单或触发工作流。目标是将需要人工干预或显式编程的任务自动化。例如，工具可以用于为与聊天机器人交互的客户预订航班，在网页上填写表单，或者在代码生成场景中基于自动测试（TDD）实现Java类。
尽管我们通常将工具调用称为模型功能，但实际上由客户端应用程序提供工具调用逻辑。模型只能请求工具调用并提供输入参数，而应用程序负责从输入参数执行工具调用并返回结果。该模型永远无法访问作为工具提供的任何API，这是一个关键的安全考虑事项。
SpringAI提供了方便的API来定义工具、解决来自模型的工具调用请求和执行工具调用。以下部分概述了Spring AI中的工具调用功能。
让我们看看如何开始在SpringAI中使用工具调用。我们将实现两个简单的工具：一个用于信息检索，另一个用于采取行动。信息检索工具将用于获取用户时区中的当前日期和时间。操作工具将用于设置指定时间的报警。
人工智能模型无法访问实时信息。任何假设知道当前日期或天气预报等信息的问题都不能由模型回答。然而，我们可以提供一个可以检索该信息的工具，并让模型在需要访问实时信息时调用该工具。
让我们实现一个工具，在<code>DateTimeTools</code>类中获取用户时区中的当前日期和时间。该工具不需要参数。Spring框架中的<code>LocaleContextHolder</code>可以提供用户的时区。该工具将被定义为用@tool注释的方法。为了帮助模型理解是否以及何时调用该工具，我们将提供工具功能的详细描述。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接下来，让我们为模型提供该工具。在这个例子中，我们将使用<code>ChatClient</code>与模型交互。我们将通过tools（）方法传递<code>DateTimeTools</code>的实例来为模型提供工具。当模型需要知道当前日期和时间时，它将请求调用该工具。在内部，<code>ChatClient</code>将调用工具并将结果返回给模型，然后模型将使用工具调用结果来生成对原始问题的最终响应。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String response <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">content</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(response);
</span></span></code></pre></div><p>输出将类似于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Tomorrow is 2015<span style="color:#f92672">-</span>10<span style="color:#f92672">-</span>21.
</span></span></code></pre></div><p>您可以重新尝试询问相同的问题。这一次，不要为模型提供工具。输出将类似于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>I am an AI and <span style="color:#66d9ef">do</span> not have access to real<span style="color:#f92672">-</span>time information. Please provide the current date so I can accurately determine what day tomorrow will be.
</span></span></code></pre></div><p>如果没有该工具，模型就不知道如何回答这个问题，因为它不能确定当前的日期和时间。
人工智能模型可用于生成实现特定目标的计划。例如，模型可以生成预订丹麦旅行的计划。然而，模型没有执行计划的能力。这就是工具的作用：它们可以用于执行模型生成的计划。
在前面的示例中，我们使用了一个工具来确定当前日期和时间。在本例中，我们将定义第二个工具，用于在特定时间设置报警。目标是从现在开始设置10分钟的警报，因此我们需要为模型提供这两个工具来完成这项任务。
我们将一如既往地将新工具添加到相同的<code>DateTimeTools</code>类中。新工具将采用单个参数，即ISO-8601格式的时间。然后，该工具将向控制台打印一条消息，指示已为给定时间设置报警。与前面一样，该工具被定义为用@tool注释的方法，我们也使用它来提供详细的描述，以帮助模型理解何时以及如何使用该工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time, provided in ISO-8601 format&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接下来，让我们将这两个工具都提供给模型。我们将使用<code>ChatClient</code>与模型交互。我们将通过tools（）方法传递<code>DateTimeTools</code>的实例来为模型提供工具。当我们要求在10分钟后设置警报时，模型首先需要知道当前的日期和时间。然后，它将使用当前日期和时间来计算报警时间。最后，它将使用报警工具来设置报警。在内部，<code>ChatClient</code>将处理来自模型的任何工具调用请求，并将任何工具调用执行结果发送回它，以便模型可以生成最终响应。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String response <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;Can you set an alarm 10 minutes from now?&#34;</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">content</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(response);
</span></span></code></pre></div><p>在应用程序日志中，您可以检查警报是否已在正确的时间设置。
SpringAI通过一组灵活的抽象来支持工具调用，这些抽象允许您以一致的方式定义、解析和执行工具。本节概述了Spring AI中工具调用的主要概念和组件。

  <img src="../../../images/tools/tool-calling-01.jpg" alt="工具调用的主要操作序列" />
工具是工具调用的构建块，它们由<code>ToolCallback</code>接口建模。Spring AI提供了从方法和函数指定<code>ToolCallback</code>的内置支持，但您始终可以定义自己的ToolCallbak实现来支持更多用例。
<code>ChatModel</code>实现透明地将工具调用请求分派到相应的<code>ToolCallback</code>实现，并将工具调用结果发送回模型，该模型最终将生成最终响应。它们使用<code>ToolCallingManager</code>接口来执行此操作，该接口负责管理工具执行生命周期。
<code>ChatClient</code>和<code>ChatModel</code>都接受<code>ToolCallback</code>对象的列表，以使工具可用于模型和最终将执行它们的<code>ToolCallingManager</code>。
除了直接传递<code>ToolCallback</code>对象外，还可以传递工具名称列表，该列表将使用ToolCallbickResolver接口动态解析。
下面的部分将详细介绍所有这些概念和API，包括如何定制和扩展它们以支持更多用例。
Spring AI以两种方式提供了从方法中指定工具（即<code>ToolCallback</code>）的内置支持：</p>
<ul>
<li>声明性地，使用@Tool注释</li>
<li>以编程方式，使用低级MethodToolCallback实现。
通过使用@tool对方法进行注释，可以将其转换为工具。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>@Tool</code>注释允许您提供有关工具的关键信息：</p>
<ul>
<li>name：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。</li>
<li>description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</li>
<li>returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。</li>
<li>resultConverter：用于将工具调用的结果转换为String对象以发送回AI模型的ToolCallResultConvertor实现。有关详细信息，请参见结果转换。
该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。
可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括<code>void</code>。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。
Spring AI将自动为<code>@Tool</code>注释方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。<code>@Tool</code>Param注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>@ToolParam</code>注释允许您提供有关工具参数的关键信息：</p>
<ul>
<li>description:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。</li>
<li>required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。
如果参数被注释为<code>@Nullable</code>，则它将被视为可选的，除非使用<code>@ToolParam</code>注释根据需要显式标记。
除了<code>@ToolParam</code>注释外，您还可以使用Swager的<code>@Schema</code>注释或Jackson的<code>@JsonProperty</code>注释。有关更多详细信息，请参阅JSON模式。
使用声明性规范方法时，可以在调用<code>ChatClient</code>时将工具类实例传递给tools（）方法。此类工具仅适用于它们添加到的特定聊天请求。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>在幕后，<code>ChatClient</code>将从工具类实例中的每个<code>@Tool</code>注释方法生成一个<code>ToolCallback</code>，并将它们传递给模型。如果希望自己生成<code>ToolCallback</code>，则可以使用ToolCallbaks实用程序类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span></code></pre></div><p>使用声明性规范方法时，可以将默认工具添加到ChatClient。通过将工具类实例传递给defaultTools（）方法来生成生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用声明性规范方法时，可以将工具类实例传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的toolCallback（）方法。此类工具仅适用于它们添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(dateTimeTools)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用声明性规范方法时，可以通过将工具类实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的toolCallback（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(dateTimeTools)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>通过以编程方式构建<code>MethodToolCallback</code>，可以将方法转换为工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>MethodToolCallback</code>。Builder允许您构建<code>MethodToolCallback</code>实例，并提供有关该工具的关键信息：</p>
<ul>
<li>toolDefinition：定义工具名称、描述和输入架构的toolDefinition实例。可以使用ToolDefinition构建它。生成器类。必需。</li>
<li>toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。</li>
<li>toolMethod：表示工具方法的Method实例。必需。</li>
<li>toolObject：包含工具方法的对象实例。如果方法是静态的，则可以省略此参数。</li>
<li>toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。
工具定义。Builder允许您构建<code>ToolDefinition</code>实例，并定义工具名称、描述和输入架构：</li>
<li>name：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。</li>
<li>description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</li>
<li>inputSchema：工具输入参数的JSON模式。如果未提供，则将基于方法参数自动生成架构。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。
<code>ToolMetadata</code>。Builder允许您构建<code>ToolMetadata</code>实例，并定义工具的其他设置：</li>
<li>returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> MethodToolCallback.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolDefinition</span>(ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolMethod</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolObject</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。
可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括<code>void</code>。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。
如果方法是静态的，则可以省略toolObject（）方法，因为不需要它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">getCurrentDateTime</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LocalDateTime.<span style="color:#a6e22e">now</span>().<span style="color:#a6e22e">atZone</span>(LocaleContextHolder.<span style="color:#a6e22e">getTimeZone</span>().<span style="color:#a6e22e">toZoneId</span>()).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> MethodToolCallback.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolDefinition</span>(ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolMethod</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>Spring AI将自动为方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。<code>@ToolParam</code>注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>@ToolParam</code>注释允许您提供有关工具参数的关键信息：</p>
<ul>
<li>description:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。</li>
<li>required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。
如果参数被注释为<code>@Nullable</code>，则它将被视为可选的，除非使用<code>@ToolParam</code>注释根据需要显式标记。
除了<code>@ToolParam</code>注释外，您还可以使用Swager的<code>@Schema</code>注释或Jackson的<code>@JsonProperty</code>注释。有关更多详细信息，请参阅JSON模式。
使用编程规范方法时，可以将<code>MethodToolCallback</code>实例传递给<code>ChatClient</code>的tools（）方法。
该工具仅适用于其添加到的特定聊天请求。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将默认工具添加到ChatClient。通过将<code>MethodToolCallback</code>实例传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将<code>MethodToolCallback</code>实例传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的Toolcallback（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用编程规范方法时，可以通过将<code>MethodToolCallback</code>实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的ToolCallbark（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>以下类型当前不支持作为用作工具的方法的参数或返回类型：</p>
<ul>
<li>可选</li>
<li>异步类型（例如CompletableFuture、Future）</li>
<li>无功类型（例如Flow、Mono、Flux）</li>
<li>功能类型（例如功能、供应商、消费者）。
使用基于函数的工具规范方法支持函数类型。有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。
Spring AI提供了从函数中指定工具的内置支持，可以通过编程方式使用低级<code>FunctionToolCallback</code>实现，也可以在运行时动态解析为<code>@Bean</code>。
通过以编程方式构建<code>Function</code>ToolCallback，可以将函数类型（<code>Function</code>、<code>Supplier</code>、<code>Consumer</code>或Bi<code>Function</code>）转换为工具。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeatherService</span> <span style="color:#66d9ef">implements</span> Function<span style="color:#f92672">&lt;</span>WeatherRequest, WeatherResponse<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> WeatherResponse <span style="color:#a6e22e">apply</span>(WeatherRequest request) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> WeatherResponse(30.<span style="color:#a6e22e">0</span>, Unit.<span style="color:#a6e22e">C</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> Unit { C, F }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">record</span> <span style="color:#a6e22e">WeatherRequest</span>(String location, Unit unit) {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">record</span> <span style="color:#a6e22e">WeatherResponse</span>(<span style="color:#66d9ef">double</span> temp, Unit unit) {}
</span></span></code></pre></div><p><code>FunctionToolCallback</code>。Builder允许您构建<code>FunctionToolCallback</code>实例，并提供有关该工具的关键信息：</p>
<ul>
<li>name：工具的名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一上下文中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。必需。</li>
<li>toolFunction：表示工具方法（Function、Supplier、Consumer或BiFunction）的函数对象。必需。</li>
<li>description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</li>
<li>inputType：函数输入的类型。必需。</li>
<li>inputSchema：工具输入参数的JSON模式。如果未提供，则将基于inputType自动生成模式。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。</li>
<li>toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。</li>
<li>toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。
<code>ToolMetadata</code>。Builder允许您构建<code>ToolMetadata</code>实例，并定义工具的其他设置：</li>
<li>returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> FunctionToolCallback
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">builder</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>, <span style="color:#66d9ef">new</span> WeatherService())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputType</span>(WeatherRequest.<span style="color:#a6e22e">class</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>功能输入和输出可以是<code>Void</code>或POJO。输入和输出POJO必须是可序列化的，因为结果将被序列化并发送回模型。函数以及输入和输出类型必须是公共的。
使用编程规范方法时，可以将<code>FunctionToolCallback</code>实例传递给<code>ChatClient</code>的tools（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将默认工具添加到ChatClient。通过将<code>FunctionToolCallback</code>实例传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用编程规范方法时，可以将<code>FunctionToolCallback</code>实例传递给<code>ToolCallingChatOptions</code>的toolCallbacks（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用编程规范方法时，可以通过将<code>FunctionToolCallback</code>实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的ToolCallbick（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>您可以将工具定义为Springbean，并让SpringAI使用<code>ToolCallbackResolver</code>接口（通过SpringBeanToolCallbickResolver实现）在运行时动态解析它们，而不是以编程方式指定工具。该选项允许您使用任何<code>Function</code>、<code>Supplier</code>、<code>Consumer</code>或Bi<code>Function</code>bean作为工具。bean名称将用作工具名称，Spring Framework中的<code>@Description</code>注释可用于提供该工具的描述，模型使用该注释来理解何时以及如何调用该工具。如果不提供描述，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>(proxyBeanMethods <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeatherTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    WeatherService weatherService <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> WeatherService();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>	Function<span style="color:#f92672">&lt;</span>WeatherRequest, WeatherResponse<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">currentWeather</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> weatherService;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将自动生成工具输入参数的JSON模式。您可以使用<code>@ToolParam</code>注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">record</span> <span style="color:#a6e22e">WeatherRequest</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;The name of a city or a country&#34;</span>) String location, Unit unit) {}
</span></span></code></pre></div><p>这种工具规范方法的缺点是不能保证类型安全，因为工具解析是在运行时完成的。为了减轻这种情况，可以使用<code>@Bean</code>注释显式地指定工具名称，并将值存储在常量中，以便可以在聊天请求中使用它，而不是硬编码工具名称。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>(proxyBeanMethods <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeatherTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String CURRENT_WEATHER_TOOL <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;currentWeather&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Bean</span>(CURRENT_WEATHER_TOOL)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>	Function<span style="color:#f92672">&lt;</span>WeatherRequest, WeatherResponse<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">currentWeather</span>() {
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用动态规范方法时，可以将工具名称（即函数bean名称）传递给<code>ChatClient</code>的tools（）方法。
该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>使用动态规范方法时，可以将默认工具添加到ChatClient。通过将工具名称传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>使用动态规范方法时，可以将工具名称传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的toolNames（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolNames</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>使用动态规范方法时，可以通过将工具名称传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的toolNames（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolNames</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>以下类型当前不支持作为用作工具的函数的输入或输出类型：</p>
<ul>
<li>基本体类型</li>
<li>可选</li>
<li>集合类型（例如列表、映射、数组、集合）</li>
<li>异步类型（例如CompletableFuture、Future）</li>
<li>无功类型（例如流量、单声道、通量）。
使用基于方法的工具规范方法支持基元类型和集合。有关详细信息，请参见作为工具的方法。
在Spring AI中，工具通过<code>ToolCallback</code>接口建模。在前面的部分中，我们已经看到了如何使用Spring AI提供的内置支持从方法和函数中定义工具（请参见
  <a href="../../../#_methods_as_tools">方法作为工具</a>和函数作为工具）。本节将深入研究工具规范，以及如何定制和扩展它以支持更多用例。
<code>ToolCallback</code>接口提供了一种定义AI模型可以调用的工具的方法，包括定义和执行逻辑。当您想要从头定义工具时，它是要实现的主界面。例如，可以从MCP客户端（使用模型上下文协议）或<code>ChatClient</code>（构建模块化代理应用程序）定义<code>ToolCallback</code>。
该接口提供以下方法：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolCallback</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Definition used by the AI model to determine when and how to call the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	ToolDefinition <span style="color:#a6e22e">getToolDefinition</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Metadata providing additional information on how to handle the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	ToolMetadata <span style="color:#a6e22e">getToolMetadata</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Execute tool with the given input and return the result to send back to the AI model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">call</span>(String toolInput);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Execute tool with the given input and context, and return the result to send back to the AI model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">call</span>(String toolInput, ToolContext tooContext);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Spring AI为工具方法（<code>MethodToolCallback</code>）和工具函数（FunctionToolCallbak）提供了内置实现。
<code>ToolDefinition</code>接口为AI模型提供所需的信息，以了解工具的可用性，包括工具名称、描述和输入模式。每个<code>ToolCallback</code>实现都必须提供<code>ToolDefinition</code>实例来定义工具。
该接口提供以下方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolDefinition</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * The tool name. Unique within the tool set provided to a model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">name</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * The tool description, used by the AI model to determine what the tool does.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">description</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * The schema of the parameters used to call the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">inputSchema</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>工具定义。Builder允许使用默认实现（Default<code>ToolDefinition</code>）构建<code>ToolDefinition</code>Instance。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">name</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the weather in location&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputSchema</span>(<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;type&#34;: &#34;object&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;properties&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;location&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    &#34;type&#34;: &#34;string&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;unit&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    &#34;type&#34;: &#34;string&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    &#34;enum&#34;: [&#34;C&#34;, &#34;F&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;required&#34;: [&#34;location&#34;, &#34;unit&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>从方法生成工具时，将自动为您生成<code>ToolDefinition</code>。如果您希望自己生成<code>ToolDefinition</code>，则可以使用此方便的生成器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">from</span>(method);
</span></span></code></pre></div><p>从方法生成的<code>ToolDefinition</code>包括作为工具名称的方法名、作为工具描述的方法名以及方法输入参数的JSON模式。如果使用<code>@Tool</code>对方法进行注释，则工具名称和描述将从注释中获取（如果设置）。
如果希望显式提供部分或全部属性，则可以使用<code>ToolDefinition</code>。生成器以生成自定义<code>ToolDefinition</code>实例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">name</span>(<span style="color:#e6db74">&#34;currentDateTime&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputSchema</span>(JsonSchemaGenerator.<span style="color:#a6e22e">generateForMethodInput</span>(method))
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>从函数构建工具时，将自动为您生成工具定义。使用<code>FunctionToolCallback</code>时。生成器以生成<code>FunctionToolCallback</code>实例，则可以提供将用于生成<code>ToolDefinition</code>的工具名称、描述和输入架构。有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。
当为AI模型提供工具时，模型需要知道用于调用该工具的输入类型的模式。模式用于理解如何调用工具和准备工具请求。SpringAI通过<code>JsonSchemaGenerator</code>类为工具生成输入类型的JSONSchema提供了内置支持。架构作为<code>ToolDefinition</code>的一部分提供。
<code>JsonSchemaGenerator</code>类在幕后用于为方法或函数的输入参数生成JSON模式，使用Methods as Tools和Functions as Tools中描述的任何策略。JSON模式生成逻辑支持一系列注释，您可以对方法和函数的输入参数使用这些注释来定制结果模式。
本节描述在为工具的输入参数生成JSON模式时可以定制的两个主要选项：描述和所需状态。
除了为工具本身提供描述外，还可以为工具的输入参数提供描述。描述可用于提供有关输入参数的关键信息，例如参数应采用何种格式、允许使用何种值等。这有助于帮助模型理解输入模式以及如何使用它。Spring AI为使用以下注释之一生成输入参数的描述提供了内置支持：</p>
<ul>
<li>@Spring AI的ToolParam（description=“…”）</li>
<li>@来自Jackson的JsonClassDescription（description=“…”）</li>
<li>@来自Jackson的JsonPropertyDescription（description=“…”）</li>
<li>@Swagger的架构（description=“…”）。
这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>默认情况下，每个输入参数都被认为是必需的，这迫使AI模型在调用工具时为其提供值。然而，可以通过使用以下注释之一（按优先级顺序）使输入参数成为可选的：</p>
<ul>
<li>@Spring AI的ToolParam（必需=假）</li>
<li>@Jackson的JsonProperty（必需=false）</li>
<li>@Swagger的架构（必需=假）</li>
<li>@从Spring Framework可以为Null。
这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Update customer information&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updateCustomerInfo</span>(Long id, String name, <span style="color:#a6e22e">@ToolParam</span>(required <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>) String email) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Updated info for customer with id: &#34;</span> <span style="color:#f92672">+</span> id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>工具调用的结果使用<code>ToolCallResultConverter</code>序列化，然后发送回AI模型。<code>ToolCallResultConverter</code>接口提供了一种将工具调用的结果转换为<code>String</code>对象的方法。
该接口提供以下方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@FunctionalInterface</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolCallResultConverter</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Given an Object returned by a tool, convert it to a String compatible with the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * given class type.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">convert</span>(<span style="color:#a6e22e">@Nullable</span> Object result, <span style="color:#a6e22e">@Nullable</span> Type returnType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结果必须是可序列化类型。默认情况下，使用Jackson（<code>Default</code>ToolCallResultConverter``）将结果序列化为JSON，但您可以通过提供自己的ToolCallresultConvertor实现来定制序列化过程。
Spring AI在方法和函数工具中都依赖于<code>ToolCallResultConverter</code>。
从具有声明性方法的方法构建工具时，可以通过设置@tool注释的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>, resultConverter <span style="color:#f92672">=</span> CustomToolCallResultConverter.<span style="color:#a6e22e">class</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用编程方法，则可以通过设置MethodToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。
有关详细信息，请参见作为工具的方法。
使用编程方法从函数构建工具时，可以通过设置FunctionToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。
有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。
Spring AI支持通过<code>ToolContext</code> API将额外的上下文信息传递给工具。此功能允许您提供额外的用户提供的数据，这些数据可以与AI模型传递的工具参数一起在工具执行中使用。

  <img src="../../../images/tools/tool-context.jpg" alt="为工具提供其他上下文信息" /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id, ToolContext toolContext) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id, toolContext.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;tenantId&#34;</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ToolContext</code>由用户在调用<code>ChatClient</code>时提供的数据填充。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String response <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;Tell me more about the customer with ID 42&#34;</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> CustomerTools())
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">toolContext</span>(Map.<span style="color:#a6e22e">of</span>(<span style="color:#e6db74">&#34;tenantId&#34;</span>, <span style="color:#e6db74">&#34;acme&#34;</span>))
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">content</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(response);
</span></span></code></pre></div><p>类似地，您可以在直接调用<code>ChatModel</code>时定义工具上下文数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> customerTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> CustomerTools());
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(customerTools)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolContext</span>(Map.<span style="color:#a6e22e">of</span>(<span style="color:#e6db74">&#34;tenantId&#34;</span>, <span style="color:#e6db74">&#34;acme&#34;</span>))
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;Tell me more about the customer with ID 42&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><p>如果在默认选项和运行时选项中都设置了<code>toolContext</code>选项，则生成的<code>toolContext</code>将是这两个选项的合并，
其中运行时选项优先于默认选项。
默认情况下，工具调用的结果作为响应发送回模型。然后，模型可以使用结果来继续对话。
在某些情况下，您宁愿将结果直接返回给调用者，而不是将其发送回模型。例如，如果构建依赖于RAG工具的代理，则可能希望将结果直接返回给调用者，而不是将其发送回模型进行不必要的后处理。或者，您可能有某些工具可以结束代理的推理循环。
每个<code>ToolCallback</code>实现都可以定义是将工具调用的结果直接返回给调用者，还是发送回模型。默认情况下，结果被发送回模型。但您可以根据工具更改此行为。
<code>ToolCallingManager</code>负责管理工具执行生命周期，负责处理与工具关联的<code>returnDirect</code>属性。如果属性设置为<code>true</code>，则工具调用的结果将直接返回给调用者。否则，结果将发送回模型。

  <img src="../../../images/tools/return-direct.jpg" alt="将工具调用结果直接返回给调用者" />
从具有声明性方法的方法构建工具时，可以通过将@tool注释的<code>returnDirect</code>属性设置为<code>true</code>来标记工具以直接将结果返回给调用方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>, returnDirect <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用编程方法，则可以通过<code>ToolMetadata</code>接口设置<code>returnDirect</code>属性，并将其传递给MethodToolCallback。建筑商。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolMetadata toolMetadata <span style="color:#f92672">=</span> ToolMetadata.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">returnDirect</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>有关详细信息，请参见作为工具的方法。
使用编程方法从函数构建工具时，可以通过<code>ToolMetadata</code>接口设置<code>returnDirect</code>属性，并将其传递给FunctionToolCallback。建筑商。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolMetadata toolMetadata <span style="color:#f92672">=</span> ToolMetadata.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">returnDirect</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。
工具执行是使用提供的输入参数调用工具并返回结果的过程。工具执行由<code>ToolCallingManager</code>接口处理，该接口负责管理工具执行生命周期。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolCallingManager</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Resolve the tool definitions from the model&#39;s tool calling options.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	List<span style="color:#f92672">&lt;</span>ToolDefinition<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">resolveToolDefinitions</span>(ToolCallingChatOptions chatOptions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Execute the tool calls requested by the model.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	ToolExecutionResult <span style="color:#a6e22e">executeToolCalls</span>(Prompt prompt, ChatResponse chatResponse);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果您正在使用任何Spring AI Spring Boot Starters，`Default<code>ToolCallingManager```是ToolCalling Manager接口的自动配置实现。您可以通过提供自己的</code>ToolCallingManager``bean来定制工具执行行为。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>ToolCallingManager <span style="color:#a6e22e">toolCallingManager</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ToolCallingManager.<span style="color:#a6e22e">builder</span>().<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>默认情况下，Spring AI从每个<code>ChatModel</code>实现中为您透明地管理工具执行生命周期。但您有可能选择退出此行为，并自行控制工具的执行。本节描述这两个场景。
当使用默认行为时，Spring AI将自动拦截来自模型的任何工具调用请求，调用该工具并将结果返回给模型。所有这些都是通过使用<code>ToolCallingManager</code>的每个<code>ChatModel</code>实现为您透明地完成的。

  <img src="../../../images/tools/framework-manager.jpg" alt="框架控制的工具执行生命周期" />
在某些情况下，您宁愿自己控制工具执行生命周期。可以通过将<code>ToolCallingChatOptions</code>的<code>internalToolExecutionEnabled</code>属性设置为<code>false</code>来完成此操作。
或者，您可以实现<code>ToolExecutionEligibilityPredicate</code>谓词来控制工具执行合格性。
默认谓词实现如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DefaultToolExecutionEligibilityPredicate</span> <span style="color:#66d9ef">implements</span> ToolExecutionEligibilityPredicate {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span>(ChatOptions promptOptions, ChatResponse chatResponse) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ToolCallingChatOptions.<span style="color:#a6e22e">isInternalToolExecutionEnabled</span>(promptOptions) <span style="color:#f92672">&amp;&amp;</span> chatResponse <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">&amp;&amp;</span> chatResponse.<span style="color:#a6e22e">hasToolCalls</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用此选项调用<code>ChatModel</code>时，工具执行将委托给调用者，使您能够完全控制工具执行生命周期。您的责任是检查<code>ChatResponse</code>中的工具调用，并使用<code>ToolCallingManager</code>执行它们。
下面的示例演示了用户控制的工具执行方法的最小实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallingManager toolCallingManager <span style="color:#f92672">=</span> ToolCallingManager.<span style="color:#a6e22e">builder</span>().<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(<span style="color:#66d9ef">new</span> CustomerTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">internalToolExecutionEnabled</span>(<span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;Tell me more about the customer with ID 42&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ChatResponse chatResponse <span style="color:#f92672">=</span> chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (chatResponse.<span style="color:#a6e22e">hasToolCalls</span>()) {
</span></span><span style="display:flex;"><span>    ToolExecutionResult toolExecutionResult <span style="color:#f92672">=</span> toolCallingManager.<span style="color:#a6e22e">executeToolCalls</span>(prompt, chatResponse);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(toolExecutionResult.<span style="color:#a6e22e">conversationHistory</span>(), chatOptions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    chatResponse <span style="color:#f92672">=</span> chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(chatResponse.<span style="color:#a6e22e">getResult</span>().<span style="color:#a6e22e">getOutput</span>().<span style="color:#a6e22e">getText</span>());
</span></span></code></pre></div><p>当工具调用失败时，异常将作为<code>ToolExecutionException</code>传播，可以捕获该异常来处理错误。<code>ToolExecutionException</code>Processor可用于处理ToolExectionException，具有两个结果：要么生成要发送回AI模型的错误消息，要么引发要由调用方处理的异常。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@FunctionalInterface</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolExecutionExceptionProcessor</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Convert an exception thrown by a tool to a String that can be sent back to the AI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * model or throw an exception to be handled by the caller.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	String <span style="color:#a6e22e">process</span>(ToolExecutionException exception);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果您正在使用任何Spring AI Spring Boot Starters，<code>Default</code>ToolExecutionExceptionProcessor<code>是ToolExectionException处理器接口的自动配置实现。默认情况下，错误消息被发送回模型。`Default`ToolExecutionExceptionProcessor</code>构造函数允许将<code>alwaysThrow</code>属性设置为<code>true</code>或<code>false</code>。如果为<code>true</code>，则将引发异常，而不是将错误消息发送回模型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>ToolExecutionExceptionProcessor <span style="color:#a6e22e">toolExecutionExceptionProcessor</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> DefaultToolExecutionExceptionProcessor(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ToolExecutionExceptionProcessor</code>由默认<code>ToolCallingManager</code>（DefaultToolCalling Manager）在内部使用，以处理工具执行期间的异常。有关工具执行生命周期的更多详细信息，请参见工具执行。
将工具传递到模型的主要方法是在调用<code>ChatClient</code>或<code>ChatModel</code>时提供<code>ToolCallback</code>，
使用
  <a href="../../../#_methods_as_tools">方法作为工具</a>和功能作为工具中描述的策略之一。
然而，Spring AI还支持使用<code>ToolCallbackResolver</code>接口在运行时动态解析工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ToolCallbackResolver</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Resolve the {@link ToolCallback} for the given tool name.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Nullable</span>
</span></span><span style="display:flex;"><span>	ToolCallback <span style="color:#a6e22e">resolve</span>(String toolName);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用此方法时：</p>
<ul>
<li>在客户端，将工具名称提供给ChatClient或ChatModel，而不是ToolCallback。</li>
<li>在服务器端，ToolCallbackResolver实现负责将工具名称解析为相应的ToolCallbak实例。
默认情况下，Spring AI依赖于<code>Delegating</code>ToolCallbackResolver``，后者将工具解析委托给ToolCallbakResolver实例列表：</li>
<li>SpringBeanToolCallbackResolver从Function、Supplier、Consumer或BiFunction类型的SpringBean解析工具。有关详细信息，请参阅动态规范：@Bean。</li>
<li>StaticToolCallbackResolver从ToolCallbak实例的静态列表中解析工具。当使用SpringBoot自动配置时，该解析器自动配置为应用程序上下文中定义的所有ToolCallback类型的bean。
如果依赖于SpringBoot自动配置，则可以通过提供自定义<code>ToolCallbackResolver</code>bean来定制解析逻辑。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>ToolCallbackResolver <span style="color:#a6e22e">toolCallbackResolver</span>(List<span style="color:#f92672">&lt;</span>FunctionCallback<span style="color:#f92672">&gt;</span> toolCallbacks) {
</span></span><span style="display:flex;"><span>    StaticToolCallbackResolver staticToolCallbackResolver <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StaticToolCallbackResolver(toolCallbacks);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> DelegatingToolCallbackResolver(List.<span style="color:#a6e22e">of</span>(staticToolCallbackResolver));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ToolCallbackResolver</code>由<code>ToolCallingManager</code>在内部使用，以在运行时动态解析工具，支持
  <a href="../../../#_framework_controlled_tool_execution">框架控制的工具执行</a>和用户控制的工具运行。
工具调用的检测正在进行中。现在，您可以使用日志功能来跟踪工具调用操作。
刀具调用功能的所有主要操作都在<code>DEBUG</code>级别记录。您可以通过将<code>org.springframework.ai</code>包的日志级别设置为<code>DEBUG</code>来启用日志记录。</p>
<h2 id="将工具添加到chatclient-3">
  将工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-3">#</a>
</h2>
<p>使用声明性规范方法时，可以在调用<code>ChatClient</code>时将工具类实例传递给tools（）方法。此类工具仅适用于它们添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><p>在幕后，<code>ChatClient</code>将从工具类实例中的每个<code>@Tool</code>注释方法生成一个<code>ToolCallback</code>，并将它们传递给模型。如果希望自己生成<code>ToolCallback</code>，则可以使用ToolCallbaks实用程序类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span></code></pre></div><h2 id="将默认工具添加到chatclient-4">
  将默认工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-4">#</a>
</h2>
<p>使用声明性规范方法时，可以将默认工具添加到ChatClient。通过将工具类实例传递给defaultTools（）方法来生成生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(<span style="color:#66d9ef">new</span> DateTimeTools())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatmodel-4">
  将工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-4">#</a>
</h2>
<p>使用声明性规范方法时，可以将工具类实例传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的toolCallback（）方法。此类工具仅适用于它们添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(dateTimeTools)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><h2 id="将默认工具添加到chatmodel-4">
  将默认工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-4">#</a>
</h2>
<p>使用声明性规范方法时，可以通过将工具类实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的toolCallback（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback<span style="color:#f92672">[]</span> dateTimeTools <span style="color:#f92672">=</span> ToolCallbacks.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">new</span> DateTimeTools());
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(dateTimeTools)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatclient和chatmodel-1">
  将工具添加到ChatClient和ChatModel
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient%e5%92%8cchatmodel-1">#</a>
</h2>
<p>使用编程规范方法时，可以将<code>MethodToolCallback</code>实例传递给<code>ChatClient</code>的tools（）方法。
该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><h2 id="将默认工具添加到chatclient-5">
  将默认工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-5">#</a>
</h2>
<p>使用编程规范方法时，可以将默认工具添加到ChatClient。通过将<code>MethodToolCallback</code>实例传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatmodel-5">
  将工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-5">#</a>
</h2>
<p>使用编程规范方法时，可以将<code>MethodToolCallback</code>实例传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的Toolcallback（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What day is tomorrow?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><h2 id="将默认工具添加到chatmodel-5">
  将默认工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-5">#</a>
</h2>
<p>使用编程规范方法时，可以通过将<code>MethodToolCallback</code>实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的ToolCallbark（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatclient-4">
  将工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-4">#</a>
</h2>
<p>使用编程规范方法时，可以将<code>FunctionToolCallback</code>实例传递给<code>ChatClient</code>的tools（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><h2 id="将默认工具添加到chatclient-6">
  将默认工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-6">#</a>
</h2>
<p>使用编程规范方法时，可以将默认工具添加到ChatClient。通过将<code>FunctionToolCallback</code>实例传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatmodel-6">
  将工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-6">#</a>
</h2>
<p>使用编程规范方法时，可以将<code>FunctionToolCallback</code>实例传递给<code>ToolCallingChatOptions</code>的toolCallbacks（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><h2 id="将默认工具添加到chatmodel-6">
  将默认工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-6">#</a>
</h2>
<p>使用编程规范方法时，可以通过将<code>FunctionToolCallback</code>实例传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的ToolCallbick（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolCallback toolCallback <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolCallbacks</span>(toolCallback)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatclient-5">
  将工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-5">#</a>
</h2>
<p>使用动态规范方法时，可以将工具名称（即函数bean名称）传递给<code>ChatClient</code>的tools（）方法。
该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatClient.<span style="color:#a6e22e">create</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">prompt</span>(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">tools</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">call</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>();
</span></span></code></pre></div><h2 id="将默认工具添加到chatclient-7">
  将默认工具添加到ChatClient
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatclient-7">#</a>
</h2>
<p>使用动态规范方法时，可以将默认工具添加到ChatClient。通过将工具名称传递给defaultTools（）方法来构建生成器。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatClient chatClient <span style="color:#f92672">=</span> ChatClient.<span style="color:#a6e22e">builder</span>(chatModel)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultTools</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="将工具添加到chatmodel-7">
  将工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-7">#</a>
</h2>
<p>使用动态规范方法时，可以将工具名称传递给用于调用<code>ChatModel</code>的<code>ToolCallingChatOptions</code>的toolNames（）方法。该工具仅适用于其添加到的特定聊天请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> ...
</span></span><span style="display:flex;"><span>ChatOptions chatOptions <span style="color:#f92672">=</span> ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toolNames</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>():
</span></span><span style="display:flex;"><span>Prompt prompt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Prompt(<span style="color:#e6db74">&#34;What&#39;s the weather like in Copenhagen?&#34;</span>, chatOptions);
</span></span><span style="display:flex;"><span>chatModel.<span style="color:#a6e22e">call</span>(prompt);
</span></span></code></pre></div><h2 id="将默认工具添加到chatmodel-7">
  将默认工具添加到ChatModel
  <a class="anchor" href="#%e5%b0%86%e9%bb%98%e8%ae%a4%e5%b7%a5%e5%85%b7%e6%b7%bb%e5%8a%a0%e5%88%b0chatmodel-7">#</a>
</h2>
<p>使用动态规范方法时，可以通过将工具名称传递给用于创建<code>ChatModel</code>的<code>ToolCallingChatOptions</code>实例的toolNames（）方法，在构造时将默认工具添加到<code>ChatModel</code>。
如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ChatModel chatModel <span style="color:#f92672">=</span> OllamaChatModel.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">ollamaApi</span>(<span style="color:#66d9ef">new</span> OllamaApi())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">defaultOptions</span>(ToolCallingChatOptions.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">toolNames</span>(<span style="color:#e6db74">&#34;currentWeather&#34;</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">build</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="方法工具定义-1">
  方法工具定义
  <a class="anchor" href="#%e6%96%b9%e6%b3%95%e5%b7%a5%e5%85%b7%e5%ae%9a%e4%b9%89-1">#</a>
</h2>
<p>从方法生成工具时，将自动为您生成<code>ToolDefinition</code>。如果您希望自己生成<code>ToolDefinition</code>，则可以使用此方便的生成器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">from</span>(method);
</span></span></code></pre></div><p>从方法生成的<code>ToolDefinition</code>包括作为工具名称的方法名、作为工具描述的方法名以及方法输入参数的JSON模式。如果使用<code>@Tool</code>对方法进行注释，则工具名称和描述将从注释中获取（如果设置）。
如果希望显式提供部分或全部属性，则可以使用<code>ToolDefinition</code>。生成器以生成自定义<code>ToolDefinition</code>实例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Method method <span style="color:#f92672">=</span> ReflectionUtils.<span style="color:#a6e22e">findMethod</span>(DateTimeTools.<span style="color:#a6e22e">class</span>, <span style="color:#e6db74">&#34;getCurrentDateTime&#34;</span>);
</span></span><span style="display:flex;"><span>ToolDefinition toolDefinition <span style="color:#f92672">=</span> ToolDefinition.<span style="color:#a6e22e">builder</span>(method)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">name</span>(<span style="color:#e6db74">&#34;currentDateTime&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">description</span>(<span style="color:#e6db74">&#34;Get the current date and time in the user&#39;s timezone&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">inputSchema</span>(JsonSchemaGenerator.<span style="color:#a6e22e">generateForMethodInput</span>(method))
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><h2 id="功能工具定义-1">
  功能工具定义
  <a class="anchor" href="#%e5%8a%9f%e8%83%bd%e5%b7%a5%e5%85%b7%e5%ae%9a%e4%b9%89-1">#</a>
</h2>
<p>从函数构建工具时，将自动为您生成工具定义。使用<code>FunctionToolCallback</code>时。生成器以生成<code>FunctionToolCallback</code>实例，则可以提供将用于生成<code>ToolDefinition</code>的工具名称、描述和输入架构。有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</p>
<h2 id="描述-1">
  描述
  <a class="anchor" href="#%e6%8f%8f%e8%bf%b0-1">#</a>
</h2>
<p>除了为工具本身提供描述外，还可以为工具的输入参数提供描述。描述可用于提供有关输入参数的关键信息，例如参数应采用何种格式、允许使用何种值等。这有助于帮助模型理解输入模式以及如何使用它。Spring AI为使用以下注释之一生成输入参数的描述提供了内置支持：</p>
<ul>
<li>@Spring AI的ToolParam（description=“…”）</li>
<li>@来自Jackson的JsonClassDescription（description=“…”）</li>
<li>@来自Jackson的JsonPropertyDescription（description=“…”）</li>
<li>@Swagger的架构（description=“…”）。
这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.LocalDateTime;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.time.format.DateTimeFormatter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.Tool;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.ai.tool.annotation.ToolParam;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.springframework.context.i18n.LocaleContextHolder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DateTimeTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Set a user alarm for the given time&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAlarm</span>(<span style="color:#a6e22e">@ToolParam</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Time in ISO-8601 format&#34;</span>) String time) {
</span></span><span style="display:flex;"><span>        LocalDateTime alarmTime <span style="color:#f92672">=</span> LocalDateTime.<span style="color:#a6e22e">parse</span>(time, DateTimeFormatter.<span style="color:#a6e22e">ISO_DATE_TIME</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Alarm set for &#34;</span> <span style="color:#f92672">+</span> alarmTime);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="必需可选-1">
  必需/可选
  <a class="anchor" href="#%e5%bf%85%e9%9c%80%e5%8f%af%e9%80%89-1">#</a>
</h2>
<p>默认情况下，每个输入参数都被认为是必需的，这迫使AI模型在调用工具时为其提供值。然而，可以通过使用以下注释之一（按优先级顺序）使输入参数成为可选的：</p>
<ul>
<li>@Spring AI的ToolParam（必需=假）</li>
<li>@Jackson的JsonProperty（必需=false）</li>
<li>@Swagger的架构（必需=假）</li>
<li>@从Spring Framework可以为Null。
这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Update customer information&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updateCustomerInfo</span>(Long id, String name, <span style="color:#a6e22e">@ToolParam</span>(required <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>) String email) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Updated info for customer with id: &#34;</span> <span style="color:#f92672">+</span> id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="方法工具调用结果转换-1">
  方法工具调用结果转换
  <a class="anchor" href="#%e6%96%b9%e6%b3%95%e5%b7%a5%e5%85%b7%e8%b0%83%e7%94%a8%e7%bb%93%e6%9e%9c%e8%bd%ac%e6%8d%a2-1">#</a>
</h2>
<p>从具有声明性方法的方法构建工具时，可以通过设置@tool注释的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>, resultConverter <span style="color:#f92672">=</span> CustomToolCallResultConverter.<span style="color:#a6e22e">class</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用编程方法，则可以通过设置MethodToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。
有关详细信息，请参见作为工具的方法。</p>
<h2 id="函数工具调用结果转换-1">
  函数工具调用结果转换
  <a class="anchor" href="#%e5%87%bd%e6%95%b0%e5%b7%a5%e5%85%b7%e8%b0%83%e7%94%a8%e7%bb%93%e6%9e%9c%e8%bd%ac%e6%8d%a2-1">#</a>
</h2>
<p>使用编程方法从函数构建工具时，可以通过设置FunctionToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。
有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</p>
<h2 id="方法直接返回-1">
  方法直接返回
  <a class="anchor" href="#%e6%96%b9%e6%b3%95%e7%9b%b4%e6%8e%a5%e8%bf%94%e5%9b%9e-1">#</a>
</h2>
<p>从具有声明性方法的方法构建工具时，可以通过将@tool注释的<code>returnDirect</code>属性设置为<code>true</code>来标记工具以直接将结果返回给调用方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerTools</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Tool</span>(description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Retrieve customer information&#34;</span>, returnDirect <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    Customer <span style="color:#a6e22e">getCustomerInfo</span>(Long id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> customerRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用编程方法，则可以通过<code>ToolMetadata</code>接口设置<code>returnDirect</code>属性，并将其传递给MethodToolCallback。建筑商。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolMetadata toolMetadata <span style="color:#f92672">=</span> ToolMetadata.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">returnDirect</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>有关详细信息，请参见作为工具的方法。</p>
<h2 id="函数直接返回-1">
  函数直接返回
  <a class="anchor" href="#%e5%87%bd%e6%95%b0%e7%9b%b4%e6%8e%a5%e8%bf%94%e5%9b%9e-1">#</a>
</h2>
<p>使用编程方法从函数构建工具时，可以通过<code>ToolMetadata</code>接口设置<code>returnDirect</code>属性，并将其传递给FunctionToolCallback。建筑商。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ToolMetadata toolMetadata <span style="color:#f92672">=</span> ToolMetadata.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">returnDirect</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div><p>有关详细信息，请参阅“
  <a href="../../../#_functions_as_tools">作为工具的功能</a>”。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#刀具调用">刀具调用</a>
      <ul>
        <li><a href="#快速入门">快速入门</a></li>
        <li><a href="#信息检索">信息检索</a></li>
        <li><a href="#采取行动">采取行动</a></li>
        <li><a href="#概述">概述</a></li>
        <li><a href="#方法作为工具">方法作为工具</a></li>
        <li><a href="#声明性规范tool">声明性规范：@Tool</a></li>
        <li><a href="#将工具添加到chatclient">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel">将默认工具添加到ChatModel</a></li>
        <li><a href="#编程规范methodtoolcallback">编程规范：MethodToolCallback</a></li>
        <li><a href="#将工具添加到chatclient和chatmodel">将工具添加到ChatClient和ChatModel</a></li>
        <li><a href="#将默认工具添加到chatclient-1">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-1">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-1">将默认工具添加到ChatModel</a></li>
        <li><a href="#方法工具限制">方法工具限制</a></li>
        <li><a href="#作为工具的功能">作为工具的功能</a></li>
        <li><a href="#编程规范functiontoolcallback">编程规范：FunctionToolCallback</a></li>
        <li><a href="#将工具添加到chatclient-1">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient-2">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-2">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-2">将默认工具添加到ChatModel</a></li>
        <li><a href="#动态规范bean">动态规范：@Bean</a></li>
        <li><a href="#将工具添加到chatclient-2">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient-3">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-3">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-3">将默认工具添加到ChatModel</a></li>
        <li><a href="#功能工具限制">功能工具限制</a></li>
        <li><a href="#工具规格">工具规格</a></li>
        <li><a href="#工具回调">工具回调</a></li>
        <li><a href="#刀具定义">刀具定义</a></li>
        <li><a href="#方法工具定义">方法工具定义</a></li>
        <li><a href="#功能工具定义">功能工具定义</a></li>
        <li><a href="#json架构">JSON架构</a></li>
        <li><a href="#描述">描述</a></li>
        <li><a href="#必需可选">必需/可选</a></li>
        <li><a href="#结果转换">结果转换</a></li>
        <li><a href="#方法工具调用结果转换">方法工具调用结果转换</a></li>
        <li><a href="#函数工具调用结果转换">函数工具调用结果转换</a></li>
        <li><a href="#工具上下文">工具上下文</a></li>
        <li><a href="#直接退货">直接退货</a></li>
        <li><a href="#方法直接返回">方法直接返回</a></li>
        <li><a href="#函数直接返回">函数直接返回</a></li>
        <li><a href="#刀具执行">刀具执行</a></li>
        <li><a href="#框架控制的工具执行">框架控制的工具执行</a></li>
        <li><a href="#用户控制的工具执行">用户控制的工具执行</a></li>
        <li><a href="#异常处理">异常处理</a></li>
        <li><a href="#工具分辨率">工具分辨率</a></li>
        <li><a href="#可观察性">可观察性</a></li>
        <li><a href="#日志记录">日志记录</a></li>
        <li><a href="#信息检索-1">信息检索</a></li>
        <li><a href="#将工具添加到chatclient-3">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient-4">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-4">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-4">将默认工具添加到ChatModel</a></li>
        <li><a href="#将工具添加到chatclient和chatmodel-1">将工具添加到ChatClient和ChatModel</a></li>
        <li><a href="#将默认工具添加到chatclient-5">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-5">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-5">将默认工具添加到ChatModel</a></li>
        <li><a href="#将工具添加到chatclient-4">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient-6">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-6">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-6">将默认工具添加到ChatModel</a></li>
        <li><a href="#将工具添加到chatclient-5">将工具添加到ChatClient</a></li>
        <li><a href="#将默认工具添加到chatclient-7">将默认工具添加到ChatClient</a></li>
        <li><a href="#将工具添加到chatmodel-7">将工具添加到ChatModel</a></li>
        <li><a href="#将默认工具添加到chatmodel-7">将默认工具添加到ChatModel</a></li>
        <li><a href="#方法工具定义-1">方法工具定义</a></li>
        <li><a href="#功能工具定义-1">功能工具定义</a></li>
        <li><a href="#描述-1">描述</a></li>
        <li><a href="#必需可选-1">必需/可选</a></li>
        <li><a href="#方法工具调用结果转换-1">方法工具调用结果转换</a></li>
        <li><a href="#函数工具调用结果转换-1">函数工具调用结果转换</a></li>
        <li><a href="#方法直接返回-1">方法直接返回</a></li>
        <li><a href="#函数直接返回-1">函数直接返回</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












