[{"id":0,"href":"/docs/","title":"文档","section":"My New Hugo Site","content":" 文档中心 # 欢迎访问文档中心。这里包含了所有的技术文档和指南。\n"},{"id":1,"href":"/docs/chat_client_api/","title":"Chat Client API","section":"文档","content":" Chat Client API Documentation # The ChatClient offers a fluent API for communicating with an AI Model. It supports both a synchronous and streaming programming model. For more details, see Creating a ChatClient section.\nCreating a ChatClient # The ChatClient is created using a ChatClient.Builder object. You can obtain an autoconfigured ChatClient.Builder instance for any ChatModel Spring Boot autoconfiguration or create one programmatically. For more information about the fluent API, see [ChatClient Fluent API](#ChatClient Fluent API) section.\nUsing an autoconfigured ChatClient.Builder # Spring AI provides Spring Boot autoconfiguration, creating a prototype ChatClient.Builder bean for you to inject into your class. For more details about responses, see ChatClient Responses section.\n@RestController class MyController { private final ChatClient chatClient; public MyController(ChatClient.Builder chatClientBuilder) { this.chatClient = chatClientBuilder.build(); } @GetMapping(\u0026#34;/ai\u0026#34;) String generation(String userInput) { return this.chatClient.prompt() .user(userInput) .call() .content(); } } Create a ChatClient programmatically # You can disable the ChatClient.Builder autoconfiguration by setting the property spring.ai.chat.client.enabled=false. For more information about streaming responses, see Streaming Responses section.\nChatModel myChatModel = ... // usually autowired ChatClient.Builder builder = ChatClient.builder(this.myChatModel); // or create a ChatClient with the default builder settings: ChatClient chatClient = ChatClient.create(this.myChatModel); ChatClient Fluent API # The ChatClient fluent API allows you to create a prompt in three distinct ways using an overloaded prompt method to initiate the fluent API. For more information about responses, see ChatClient Responses section.\nPrompt Methods # Three ways to create a prompt:\nChatClient Responses # The ChatClient API offers several ways to format the response from the AI Model using the fluent API. For streaming responses, see Streaming Responses section.\nReturning a ChatResponse # The response from the AI model is a rich structure defined by the type ChatResponse.\nChatResponse chatResponse = chatClient.prompt() .user(\u0026#34;Tell me a joke\u0026#34;) .call() .chatResponse(); Returning an Entity # You can map the AI model\u0026rsquo;s output to a Java record or class.\nrecord ActorFilms(String actor, List\u0026lt;String\u0026gt; movies) {} ActorFilms actorFilms = chatClient.prompt() .user(\u0026#34;Generate the filmography for a random actor.\u0026#34;) .call() .entity(ActorFilms.class); Streaming Responses # The stream() method lets you get an asynchronous response. For more information about chat memory, see Chat Memory section.\nFlux\u0026lt;String\u0026gt; output = chatClient.prompt() .user(\u0026#34;Tell me a joke\u0026#34;) .stream() .content(); Using Defaults # Creating a ChatClient with default settings simplifies runtime code. For more information about advisors, see Advisors section.\nDefault System Text # Configure default system text in an @Configuration class.\n@Configuration class Config { @Bean ChatClient chatClient(ChatClient.Builder builder) { return builder.defaultSystem(\u0026#34;You are a friendly chat bot that answers question in the voice of a Pirate\u0026#34;) .build(); } } Advisors # The Advisors API provides a flexible and powerful way to intercept, modify, and enhance AI-driven interactions. For more information about chat memory, see Chat Memory section.\nAdvisor Configuration # The ChatClient fluent API provides an AdvisorSpec interface for configuring advisors.\nChatClient.builder(chatModel) .build() .prompt() .advisors( new MessageChatMemoryAdvisor(chatMemory), new QuestionAnswerAdvisor(vectorStore) ) .user(userText) .call() .content(); Chat Memory # The interface ChatMemory represents a storage for chat conversation history. For more information about creating a ChatClient, see Creating a ChatClient section.\nImplementations # Different implementations of ChatMemory:\nInMemoryChatMemory CassandraChatMemory Neo4jChatMemory JdbcChatMemory "},{"id":2,"href":"/docs/concepts/","title":"Concepts","section":"文档","content":" AI Concepts # This section describes core concepts that Spring AI uses. We recommend reading it closely to understand the ideas behind how Spring AI is implemented.\nModels # AI models are algorithms designed to process and generate information, often mimicking human cognitive functions. By learning patterns and insights from large datasets, these models can make predictions, text, images, or other outputs, enhancing various applications across industries.\nPrompts # Prompts serve as the foundation for the language-based inputs that guide an AI model to produce specific outputs. For those familiar with ChatGPT, a prompt might seem like merely the text entered into a dialog box that is sent to the API. However, it encompasses much more than that. In many AI Models, the text for the prompt is not just a simple string.\nTell me a {adjective} joke about {content}. recent research paper StringTemplate Prompt Templates # Creating effective prompts involves establishing the context of the request and substituting parts of the request with values specific to the user’s input.\nTell me a {adjective} joke about {content}. StringTemplate Embeddings # Embeddings are numerical representations of text, images, or videos that capture relationships between inputs.\nTokens # Tokens serve as the building blocks of how an AI model works. On input, models convert words to tokens. On output, they convert tokens back to words.\nStructured Output # The output of AI models traditionally arrives as a java.lang.String, even if you ask for the reply to be in JSON. It may be a correct JSON, but it is not a JSON data structure. It is just a string. Also, asking “for JSON” as part of the prompt is not 100% accurate.\nStructured output conversion Bringing Your Data \u0026amp; APIs to the AI Model # How can you equip the AI model with information on which it has not been trained?\nRetrieval Augmented Generation (RAG) Tool Calling tool calling ETL Pipeline ChatClient - RAG Tool Calling Retrieval Augmented Generation # A technique termed Retrieval Augmented Generation (RAG) has emerged to address the challenge of incorporating relevant data into prompts for accurate AI model responses.\nETL Pipeline ChatClient - RAG Tool Calling # Large Language Models (LLMs) are frozen after training, leading to stale knowledge, and they are unable to access or modify external data.\nTool Calling Evaluating AI responses # Effectively evaluating the output of an AI system in response to user requests is very important to ensuring the accuracy and usefulness of the final application. Several emerging techniques enable the use of the pre-trained model itself for this purpose.\nEvaluation Testing "},{"id":3,"href":"/docs/getting_started/","title":"Getting Started","section":"文档","content":" Getting Started with Spring AI # This section offers jumping off points for how to get started using Spring AI. You should follow the steps in each of the following sections according to your needs.\nPrerequisites # Spring AI supports Spring Boot 3.4.x. When Spring Boot 3.5.x is released, we will support that as well.\nSpring Initializr # Head on over to start.spring.io and select the AI Models and Vector Stores that you want to use in your new applications.\nArtifact Repositories # Milestones - Use Maven Central # As of 1.0.0-M6, releases are available in Maven Central. No changes to your build file are required.\nSnapshots - Add Snapshot Repositories # To use the Snapshot (and pre 1.0.0-M6 milestone) versions, you need to add the following snapshot repositories in your build file.\n\u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-snapshots\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Snapshots\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/snapshot\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;name\u0026gt;Central Portal Snapshots\u0026lt;/name\u0026gt; \u0026lt;id\u0026gt;central-portal-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;https://central.sonatype.com/repository/maven-snapshots/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; Dependency Management # The Spring AI Bill of Materials (BOM) declares the recommended versions of all the dependencies used by a given release of Spring AI. Using the BOM from your application\u0026rsquo;s build script avoids the need for you to specify and maintain the dependency versions yourself.\nAdd the BOM to your project # \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.ai\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-ai-bom\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; Add dependencies for specific components # Each of the following sections in the documentation shows which dependencies you need to add to your project build system.\nSpring AI samples # Please refer to this page for more resources and samples related to Spring AI.\n"}]