[{"id":0,"href":"/docs/","title":"文档","section":"My New Hugo Site","content":" 文档中心 # 欢迎访问文档中心。这里包含了所有的技术文档和指南。\n"},{"id":1,"href":"/docs/api/tools/","title":"Tools","section":"文档","content":" 刀具调用 # 工具调用（也称为函数调用）是人工智能应用程序中的一种常见模式，允许模型与一组API或工具交互，以增强其功能。 工具主要用于： 尽管我们通常将工具调用称为模型功能，但实际上由客户端应用程序提供工具调用逻辑。模型只能请求工具调用并提供输入参数，而应用程序负责从输入参数执行工具调用并返回结果。该模型永远无法访问作为工具提供的任何API，这是一个关键的安全考虑事项。 SpringAI提供了方便的API来定义工具、解决来自模型的工具调用请求和执行工具调用。以下部分概述了Spring AI中的工具调用功能。\n快速入门 # 让我们看看如何开始在SpringAI中使用工具调用。我们将实现两个简单的工具：一个用于信息检索，另一个用于采取行动。信息检索工具将用于获取用户时区中的当前日期和时间。操作工具将用于设置指定时间的报警。 人工智能模型无法访问实时信息。任何假设知道当前日期或天气预报等信息的问题都不能由模型回答。然而，我们可以提供一个可以检索该信息的工具，并让模型在需要访问实时信息时调用该工具。 让我们实现一个工具，在DateTimeTools类中获取用户时区中的当前日期和时间。该工具不需要参数。Spring框架中的LocaleContextHolder可以提供用户的时区。该工具将被定义为用@tool注释的方法。为了帮助模型理解是否以及何时调用该工具，我们将提供工具功能的详细描述。\nimport java.time.LocalDateTime; import org.springframework.ai.tool.annotation.Tool; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } 接下来，让我们为模型提供该工具。在这个例子中，我们将使用ChatClient与模型交互。我们将通过tools（）方法传递DateTimeTools的实例来为模型提供工具。当模型需要知道当前日期和时间时，它将请求调用该工具。在内部，ChatClient将调用工具并将结果返回给模型，然后模型将使用工具调用结果来生成对原始问题的最终响应。\nChatModel chatModel = ... String response = ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); System.out.println(response); 输出将类似于：\nTomorrow is 2015-10-21. 您可以重新尝试询问相同的问题。这一次，不要为模型提供工具。输出将类似于：\nI am an AI and do not have access to real-time information. Please provide the current date so I can accurately determine what day tomorrow will be. 如果没有该工具，模型就不知道如何回答这个问题，因为它不能确定当前的日期和时间。 人工智能模型可用于生成实现特定目标的计划。例如，模型可以生成预订丹麦旅行的计划。然而，模型没有执行计划的能力。这就是工具的作用：它们可以用于执行模型生成的计划。 在前面的示例中，我们使用了一个工具来确定当前日期和时间。在本例中，我们将定义第二个工具，用于在特定时间设置报警。目标是从现在开始设置10分钟的警报，因此我们需要为模型提供这两个工具来完成这项任务。 我们将一如既往地将新工具添加到相同的DateTimeTools类中。新工具将采用单个参数，即ISO-8601格式的时间。然后，该工具将向控制台打印一条消息，指示已为给定时间设置报警。与前面一样，该工具被定义为用@tool注释的方法，我们也使用它来提供详细的描述，以帮助模型理解何时以及如何使用该工具。\nimport java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } @Tool(description = \u0026#34;Set a user alarm for the given time, provided in ISO-8601 format\u0026#34;) void setAlarm(String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } 接下来，让我们将这两个工具都提供给模型。我们将使用ChatClient与模型交互。我们将通过tools（）方法传递DateTimeTools的实例来为模型提供工具。当我们要求在10分钟后设置警报时，模型首先需要知道当前的日期和时间。然后，它将使用当前日期和时间来计算报警时间。最后，它将使用报警工具来设置报警。在内部，ChatClient将处理来自模型的任何工具调用请求，并将任何工具调用执行结果发送回它，以便模型可以生成最终响应。\nChatModel chatModel = ... String response = ChatClient.create(chatModel) .prompt(\u0026#34;Can you set an alarm 10 minutes from now?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); System.out.println(response); 在应用程序日志中，您可以检查警报是否已在正确的时间设置。\n信息检索 # 人工智能模型无法访问实时信息。任何假设知道当前日期或天气预报等信息的问题都不能由模型回答。然而，我们可以提供一个可以检索该信息的工具，并让模型在需要访问实时信息时调用该工具。 让我们实现一个工具，在DateTimeTools类中获取用户时区中的当前日期和时间。该工具不需要参数。Spring框架中的LocaleContextHolder可以提供用户的时区。该工具将被定义为用@tool注释的方法。为了帮助模型理解是否以及何时调用该工具，我们将提供工具功能的详细描述。\nimport java.time.LocalDateTime; import org.springframework.ai.tool.annotation.Tool; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } 接下来，让我们为模型提供该工具。在这个例子中，我们将使用ChatClient与模型交互。我们将通过tools（）方法传递DateTimeTools的实例来为模型提供工具。当模型需要知道当前日期和时间时，它将请求调用该工具。在内部，ChatClient将调用工具并将结果返回给模型，然后模型将使用工具调用结果来生成对原始问题的最终响应。\nChatModel chatModel = ... String response = ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); System.out.println(response); 输出将类似于：\nTomorrow is 2015-10-21. 您可以重新尝试询问相同的问题。这一次，不要为模型提供工具。输出将类似于：\nI am an AI and do not have access to real-time information. Please provide the current date so I can accurately determine what day tomorrow will be. 如果没有该工具，模型就不知道如何回答这个问题，因为它不能确定当前的日期和时间。\n采取行动 # 人工智能模型可用于生成实现特定目标的计划。例如，模型可以生成预订丹麦旅行的计划。然而，模型没有执行计划的能力。这就是工具的作用：它们可以用于执行模型生成的计划。 在前面的示例中，我们使用了一个工具来确定当前日期和时间。在本例中，我们将定义第二个工具，用于在特定时间设置报警。目标是从现在开始设置10分钟的警报，因此我们需要为模型提供这两个工具来完成这项任务。 我们将一如既往地将新工具添加到相同的DateTimeTools类中。新工具将采用单个参数，即ISO-8601格式的时间。然后，该工具将向控制台打印一条消息，指示已为给定时间设置报警。与前面一样，该工具被定义为用@tool注释的方法，我们也使用它来提供详细的描述，以帮助模型理解何时以及如何使用该工具。\nimport java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } @Tool(description = \u0026#34;Set a user alarm for the given time, provided in ISO-8601 format\u0026#34;) void setAlarm(String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } 接下来，让我们将这两个工具都提供给模型。我们将使用ChatClient与模型交互。我们将通过tools（）方法传递DateTimeTools的实例来为模型提供工具。当我们要求在10分钟后设置警报时，模型首先需要知道当前的日期和时间。然后，它将使用当前日期和时间来计算报警时间。最后，它将使用报警工具来设置报警。在内部，ChatClient将处理来自模型的任何工具调用请求，并将任何工具调用执行结果发送回它，以便模型可以生成最终响应。\nChatModel chatModel = ... String response = ChatClient.create(chatModel) .prompt(\u0026#34;Can you set an alarm 10 minutes from now?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); System.out.println(response); 在应用程序日志中，您可以检查警报是否已在正确的时间设置。\n概述 # SpringAI通过一组灵活的抽象来支持工具调用，这些抽象允许您以一致的方式定义、解析和执行工具。本节概述了Spring AI中工具调用的主要概念和组件。 工具是工具调用的构建块，它们由ToolCallback接口建模。Spring AI提供了从方法和函数指定ToolCallback的内置支持，但您始终可以定义自己的ToolCallbak实现来支持更多用例。 ChatModel实现透明地将工具调用请求分派到相应的ToolCallback实现，并将工具调用结果发送回模型，该模型最终将生成最终响应。它们使用ToolCallingManager接口来执行此操作，该接口负责管理工具执行生命周期。 ChatClient和ChatModel都接受ToolCallback对象的列表，以使工具可用于模型和最终将执行它们的ToolCallingManager。 除了直接传递ToolCallback对象外，还可以传递工具名称列表，该列表将使用ToolCallbickResolver接口动态解析。 下面的部分将详细介绍所有这些概念和API，包括如何定制和扩展它们以支持更多用例。\n方法作为工具 # Spring AI以两种方式提供了从方法中指定工具（即ToolCallback）的内置支持：\n声明性地，使用@Tool注释 以编程方式，使用低级MethodToolCallback实现。 通过使用@tool对方法进行注释，可以将其转换为工具。 class DateTimeTools { @Tool(description = \u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } @Tool注释允许您提供有关工具的关键信息：\nname：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。 description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。 returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。 resultConverter：用于将工具调用的结果转换为String对象以发送回AI模型的ToolCallResultConvertor实现。有关详细信息，请参见结果转换。 该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。 可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括void。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。 Spring AI将自动为@Tool注释方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。@ToolParam注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。 import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.ai.tool.annotation.ToolParam; class DateTimeTools { @Tool(description = \u0026#34;Set a user alarm for the given time\u0026#34;) void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } @ToolParam注释允许您提供有关工具参数的关键信息：\ndescription:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。 required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。 如果参数被注释为@Nullable，则它将被视为可选的，除非使用@ToolParam注释根据需要显式标记。 除了@ToolParam注释外，您还可以使用Swager的@Schema注释或Jackson的@JsonProperty注释。有关更多详细信息，请参阅JSON模式。 使用声明性规范方法时，可以在调用ChatClient时将工具类实例传递给tools（）方法。此类工具仅适用于它们添加到的特定聊天请求。 ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); 在幕后，ChatClient将从工具类实例中的每个@Tool注释方法生成一个ToolCallback，并将它们传递给模型。如果希望自己生成ToolCallback，则可以使用ToolCallbaks实用程序类。\nToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); 使用声明性规范方法时，可以将默认工具添加到ChatClient。通过将工具类实例传递给defaultTools（）方法来生成生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(new DateTimeTools()) .build(); 使用声明性规范方法时，可以将工具类实例传递给用于调用ChatModel的ToolCallingChatOptions的toolCallback（）方法。此类工具仅适用于它们添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(dateTimeTools) .build(): Prompt prompt = new Prompt(\u0026#34;What day is tomorrow?\u0026#34;, chatOptions); chatModel.call(prompt); 使用声明性规范方法时，可以通过将工具类实例传递给用于创建ChatModel的ToolCallingChatOptions实例的toolCallback（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(dateTimeTools) .build()) .build(); 通过以编程方式构建MethodToolCallback，可以将方法转换为工具。\nclass DateTimeTools { String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } MethodToolCallback。Builder允许您构建MethodToolCallback实例，并提供有关该工具的关键信息：\ntoolDefinition：定义工具名称、描述和输入架构的toolDefinition实例。可以使用ToolDefinition构建它。生成器类。必需。 toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。 toolMethod：表示工具方法的Method实例。必需。 toolObject：包含工具方法的对象实例。如果方法是静态的，则可以省略此参数。 toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。 工具定义。Builder允许您构建ToolDefinition实例，并定义工具名称、描述和输入架构： name：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。 description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。 inputSchema：工具输入参数的JSON模式。如果未提供，则将基于方法参数自动生成架构。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。 ToolMetadata。Builder允许您构建ToolMetadata实例，并定义工具的其他设置： returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。 Method method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolCallback toolCallback = MethodToolCallback.builder() .toolDefinition(ToolDefinition.builder(method) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .build()) .toolMethod(method) .toolObject(new DateTimeTools()) .build(); 该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。 可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括void。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。 如果方法是静态的，则可以省略toolObject（）方法，因为不需要它。\nclass DateTimeTools { static String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } Method method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolCallback toolCallback = MethodToolCallback.builder() .toolDefinition(ToolDefinition.builder(method) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .build()) .toolMethod(method) .build(); Spring AI将自动为方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。@ToolParam注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。\nimport java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.ToolParam; class DateTimeTools { void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } @ToolParam注释允许您提供有关工具参数的关键信息：\ndescription:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。 required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。 如果参数被注释为@Nullable，则它将被视为可选的，除非使用@ToolParam注释根据需要显式标记。 除了@ToolParam注释外，您还可以使用Swager的@Schema注释或Jackson的@JsonProperty注释。有关更多详细信息，请参阅JSON模式。 使用编程规范方法时，可以将MethodToolCallback实例传递给ChatClient的tools（）方法。 该工具仅适用于其添加到的特定聊天请求。 ToolCallback toolCallback = ... ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(toolCallback) .call() .content(); 使用编程规范方法时，可以将默认工具添加到ChatClient。通过将MethodToolCallback实例传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(toolCallback) .build(); 使用编程规范方法时，可以将MethodToolCallback实例传递给用于调用ChatModel的ToolCallingChatOptions的Toolcallback（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build(): Prompt prompt = new Prompt(\u0026#34;What day is tomorrow?\u0026#34;, chatOptions); chatModel.call(prompt); 使用编程规范方法时，可以通过将MethodToolCallback实例传递给用于创建ChatModel的ToolCallingChatOptions实例的ToolCallbark（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback toolCallback = ... ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build()) .build(); 以下类型当前不支持作为用作工具的方法的参数或返回类型：\n可选 异步类型（例如CompletableFuture、Future） 无功类型（例如Flow、Mono、Flux） 功能类型（例如功能、供应商、消费者）。 使用基于函数的工具规范方法支持函数类型。有关详细信息，请参阅“ 作为工具的功能”。 声明性规范：@Tool # 通过使用@tool对方法进行注释，可以将其转换为工具。\nclass DateTimeTools { @Tool(description = \u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } @Tool注释允许您提供有关工具的关键信息：\nname：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。 description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。 returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。 resultConverter：用于将工具调用的结果转换为String对象以发送回AI模型的ToolCallResultConvertor实现。有关详细信息，请参见结果转换。 该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。 可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括void。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。 Spring AI将自动为@Tool注释方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。@ToolParam注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。 import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.ai.tool.annotation.ToolParam; class DateTimeTools { @Tool(description = \u0026#34;Set a user alarm for the given time\u0026#34;) void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } @ToolParam注释允许您提供有关工具参数的关键信息：\ndescription:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。 required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。 如果参数被注释为@Nullable，则它将被视为可选的，除非使用@ToolParam注释根据需要显式标记。 除了@ToolParam注释外，您还可以使用Swager的@Schema注释或Jackson的@JsonProperty注释。有关更多详细信息，请参阅JSON模式。 使用声明性规范方法时，可以在调用ChatClient时将工具类实例传递给tools（）方法。此类工具仅适用于它们添加到的特定聊天请求。 ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); 在幕后，ChatClient将从工具类实例中的每个@Tool注释方法生成一个ToolCallback，并将它们传递给模型。如果希望自己生成ToolCallback，则可以使用ToolCallbaks实用程序类。\nToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); 使用声明性规范方法时，可以将默认工具添加到ChatClient。通过将工具类实例传递给defaultTools（）方法来生成生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(new DateTimeTools()) .build(); 使用声明性规范方法时，可以将工具类实例传递给用于调用ChatModel的ToolCallingChatOptions的toolCallback（）方法。此类工具仅适用于它们添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(dateTimeTools) .build(): Prompt prompt = new Prompt(\u0026#34;What day is tomorrow?\u0026#34;, chatOptions); chatModel.call(prompt); 使用声明性规范方法时，可以通过将工具类实例传递给用于创建ChatModel的ToolCallingChatOptions实例的toolCallback（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(dateTimeTools) .build()) .build(); 将工具添加到ChatClient # 使用声明性规范方法时，可以在调用ChatClient时将工具类实例传递给tools（）方法。此类工具仅适用于它们添加到的特定聊天请求。\nChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); 在幕后，ChatClient将从工具类实例中的每个@Tool注释方法生成一个ToolCallback，并将它们传递给模型。如果希望自己生成ToolCallback，则可以使用ToolCallbaks实用程序类。\nToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); 将默认工具添加到ChatClient # 使用声明性规范方法时，可以将默认工具添加到ChatClient。通过将工具类实例传递给defaultTools（）方法来生成生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(new DateTimeTools()) .build(); 将工具添加到ChatModel # 使用声明性规范方法时，可以将工具类实例传递给用于调用ChatModel的ToolCallingChatOptions的toolCallback（）方法。此类工具仅适用于它们添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(dateTimeTools) .build(): Prompt prompt = new Prompt(\u0026#34;What day is tomorrow?\u0026#34;, chatOptions); chatModel.call(prompt); 将默认工具添加到ChatModel # 使用声明性规范方法时，可以通过将工具类实例传递给用于创建ChatModel的ToolCallingChatOptions实例的toolCallback（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(dateTimeTools) .build()) .build(); 编程规范：MethodToolCallback # 通过以编程方式构建MethodToolCallback，可以将方法转换为工具。\nclass DateTimeTools { String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } MethodToolCallback。Builder允许您构建MethodToolCallback实例，并提供有关该工具的关键信息：\ntoolDefinition：定义工具名称、描述和输入架构的toolDefinition实例。可以使用ToolDefinition构建它。生成器类。必需。 toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。 toolMethod：表示工具方法的Method实例。必需。 toolObject：包含工具方法的对象实例。如果方法是静态的，则可以省略此参数。 toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。 工具定义。Builder允许您构建ToolDefinition实例，并定义工具名称、描述和输入架构： name：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。 description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。 inputSchema：工具输入参数的JSON模式。如果未提供，则将基于方法参数自动生成架构。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。 ToolMetadata。Builder允许您构建ToolMetadata实例，并定义工具的其他设置： returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。 Method method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolCallback toolCallback = MethodToolCallback.builder() .toolDefinition(ToolDefinition.builder(method) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .build()) .toolMethod(method) .toolObject(new DateTimeTools()) .build(); 该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。 可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括void。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。 如果方法是静态的，则可以省略toolObject（）方法，因为不需要它。\nclass DateTimeTools { static String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } Method method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolCallback toolCallback = MethodToolCallback.builder() .toolDefinition(ToolDefinition.builder(method) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .build()) .toolMethod(method) .build(); Spring AI将自动为方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。@ToolParam注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。\nimport java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.ToolParam; class DateTimeTools { void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } @ToolParam注释允许您提供有关工具参数的关键信息：\ndescription:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。 required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。 如果参数被注释为@Nullable，则它将被视为可选的，除非使用@ToolParam注释根据需要显式标记。 除了@ToolParam注释外，您还可以使用Swager的@Schema注释或Jackson的@JsonProperty注释。有关更多详细信息，请参阅JSON模式。 使用编程规范方法时，可以将MethodToolCallback实例传递给ChatClient的tools（）方法。 该工具仅适用于其添加到的特定聊天请求。 ToolCallback toolCallback = ... ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(toolCallback) .call() .content(); 使用编程规范方法时，可以将默认工具添加到ChatClient。通过将MethodToolCallback实例传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(toolCallback) .build(); 使用编程规范方法时，可以将MethodToolCallback实例传递给用于调用ChatModel的ToolCallingChatOptions的Toolcallback（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build(): Prompt prompt = new Prompt(\u0026#34;What day is tomorrow?\u0026#34;, chatOptions); chatModel.call(prompt); 使用编程规范方法时，可以通过将MethodToolCallback实例传递给用于创建ChatModel的ToolCallingChatOptions实例的ToolCallbark（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback toolCallback = ... ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build()) .build(); 将工具添加到ChatClient和ChatModel # 使用编程规范方法时，可以将MethodToolCallback实例传递给ChatClient的tools（）方法。 该工具仅适用于其添加到的特定聊天请求。\nToolCallback toolCallback = ... ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(toolCallback) .call() .content(); 将默认工具添加到ChatClient # 使用编程规范方法时，可以将默认工具添加到ChatClient。通过将MethodToolCallback实例传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(toolCallback) .build(); 将工具添加到ChatModel # 使用编程规范方法时，可以将MethodToolCallback实例传递给用于调用ChatModel的ToolCallingChatOptions的Toolcallback（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build(): Prompt prompt = new Prompt(\u0026#34;What day is tomorrow?\u0026#34;, chatOptions); chatModel.call(prompt); 将默认工具添加到ChatModel # 使用编程规范方法时，可以通过将MethodToolCallback实例传递给用于创建ChatModel的ToolCallingChatOptions实例的ToolCallbark（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback toolCallback = ... ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build()) .build(); 方法工具限制 # 以下类型当前不支持作为用作工具的方法的参数或返回类型：\n可选 异步类型（例如CompletableFuture、Future） 无功类型（例如Flow、Mono、Flux） 功能类型（例如功能、供应商、消费者）。 使用基于函数的工具规范方法支持函数类型。有关详细信息，请参阅“ 作为工具的功能”。 作为工具的功能 # Spring AI提供了从函数中指定工具的内置支持，可以通过编程方式使用低级FunctionToolCallback实现，也可以在运行时动态解析为@Bean。 通过以编程方式构建FunctionToolCallback，可以将函数类型（Function、Supplier、Consumer或BiFunction）转换为工具。\npublic class WeatherService implements Function\u0026lt;WeatherRequest, WeatherResponse\u0026gt; { public WeatherResponse apply(WeatherRequest request) { return new WeatherResponse(30.0, Unit.C); } } public enum Unit { C, F } public record WeatherRequest(String location, Unit unit) {} public record WeatherResponse(double temp, Unit unit) {} FunctionToolCallback。Builder允许您构建FunctionToolCallback实例，并提供有关该工具的关键信息：\nname：工具的名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一上下文中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。必需。 toolFunction：表示工具方法（Function、Supplier、Consumer或BiFunction）的函数对象。必需。 description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。 inputType：函数输入的类型。必需。 inputSchema：工具输入参数的JSON模式。如果未提供，则将基于inputType自动生成模式。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。 toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。 toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。 ToolMetadata。Builder允许您构建ToolMetadata实例，并定义工具的其他设置： returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。 ToolCallback toolCallback = FunctionToolCallback .builder(\u0026#34;currentWeather\u0026#34;, new WeatherService()) .description(\u0026#34;Get the weather in location\u0026#34;) .inputType(WeatherRequest.class) .build(); 功能输入和输出可以是Void或POJO。输入和输出POJO必须是可序列化的，因为结果将被序列化并发送回模型。函数以及输入和输出类型必须是公共的。 使用编程规范方法时，可以将FunctionToolCallback实例传递给ChatClient的tools（）方法。该工具仅适用于其添加到的特定聊天请求。\nToolCallback toolCallback = ... ChatClient.create(chatModel) .prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;) .tools(toolCallback) .call() .content(); 使用编程规范方法时，可以将默认工具添加到ChatClient。通过将FunctionToolCallback实例传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(toolCallback) .build(); 使用编程规范方法时，可以将FunctionToolCallback实例传递给ToolCallingChatOptions的toolCallbacks（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build(): Prompt prompt = new Prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;, chatOptions); chatModel.call(prompt); 使用编程规范方法时，可以通过将FunctionToolCallback实例传递给用于创建ChatModel的ToolCallingChatOptions实例的ToolCallbick（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback toolCallback = ... ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build()) .build(); 您可以将工具定义为Springbean，并让SpringAI使用ToolCallbackResolver接口（通过SpringBeanToolCallbickResolver实现）在运行时动态解析它们，而不是以编程方式指定工具。该选项允许您使用任何Function、Supplier、Consumer或BiFunctionbean作为工具。bean名称将用作工具名称，Spring Framework中的@Description注释可用于提供该工具的描述，模型使用该注释来理解何时以及如何调用该工具。如果不提供描述，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。\n@Configuration(proxyBeanMethods = false) class WeatherTools { WeatherService weatherService = new WeatherService(); @Bean @Description(\u0026#34;Get the weather in location\u0026#34;) Function\u0026lt;WeatherRequest, WeatherResponse\u0026gt; currentWeather() { return weatherService; } } 将自动生成工具输入参数的JSON模式。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。\nrecord WeatherRequest(@ToolParam(description = \u0026#34;The name of a city or a country\u0026#34;) String location, Unit unit) {} 这种工具规范方法的缺点是不能保证类型安全，因为工具解析是在运行时完成的。为了减轻这种情况，可以使用@Bean注释显式地指定工具名称，并将值存储在常量中，以便可以在聊天请求中使用它，而不是硬编码工具名称。\n@Configuration(proxyBeanMethods = false) class WeatherTools { public static final String CURRENT_WEATHER_TOOL = \u0026#34;currentWeather\u0026#34;; @Bean(CURRENT_WEATHER_TOOL) @Description(\u0026#34;Get the weather in location\u0026#34;) Function\u0026lt;WeatherRequest, WeatherResponse\u0026gt; currentWeather() { ... } } 使用动态规范方法时，可以将工具名称（即函数bean名称）传递给ChatClient的tools（）方法。 该工具仅适用于其添加到的特定聊天请求。\nChatClient.create(chatModel) .prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;) .tools(\u0026#34;currentWeather\u0026#34;) .call() .content(); 使用动态规范方法时，可以将默认工具添加到ChatClient。通过将工具名称传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(\u0026#34;currentWeather\u0026#34;) .build(); 使用动态规范方法时，可以将工具名称传递给用于调用ChatModel的ToolCallingChatOptions的toolNames（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolNames(\u0026#34;currentWeather\u0026#34;) .build(): Prompt prompt = new Prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;, chatOptions); chatModel.call(prompt); 使用动态规范方法时，可以通过将工具名称传递给用于创建ChatModel的ToolCallingChatOptions实例的toolNames（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolNames(\u0026#34;currentWeather\u0026#34;) .build()) .build(); 以下类型当前不支持作为用作工具的函数的输入或输出类型：\n基本体类型 可选 集合类型（例如列表、映射、数组、集合） 异步类型（例如CompletableFuture、Future） 无功类型（例如流量、单声道、通量）。 使用基于方法的工具规范方法支持基元类型和集合。有关详细信息，请参见作为工具的方法。 编程规范：FunctionToolCallback # 通过以编程方式构建FunctionToolCallback，可以将函数类型（Function、Supplier、Consumer或BiFunction）转换为工具。\npublic class WeatherService implements Function\u0026lt;WeatherRequest, WeatherResponse\u0026gt; { public WeatherResponse apply(WeatherRequest request) { return new WeatherResponse(30.0, Unit.C); } } public enum Unit { C, F } public record WeatherRequest(String location, Unit unit) {} public record WeatherResponse(double temp, Unit unit) {} FunctionToolCallback。Builder允许您构建FunctionToolCallback实例，并提供有关该工具的关键信息：\nname：工具的名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一上下文中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。必需。 toolFunction：表示工具方法（Function、Supplier、Consumer或BiFunction）的函数对象。必需。 description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。 inputType：函数输入的类型。必需。 inputSchema：工具输入参数的JSON模式。如果未提供，则将基于inputType自动生成模式。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。 toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。 toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。 ToolMetadata。Builder允许您构建ToolMetadata实例，并定义工具的其他设置： returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。 ToolCallback toolCallback = FunctionToolCallback .builder(\u0026#34;currentWeather\u0026#34;, new WeatherService()) .description(\u0026#34;Get the weather in location\u0026#34;) .inputType(WeatherRequest.class) .build(); 功能输入和输出可以是Void或POJO。输入和输出POJO必须是可序列化的，因为结果将被序列化并发送回模型。函数以及输入和输出类型必须是公共的。 使用编程规范方法时，可以将FunctionToolCallback实例传递给ChatClient的tools（）方法。该工具仅适用于其添加到的特定聊天请求。\nToolCallback toolCallback = ... ChatClient.create(chatModel) .prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;) .tools(toolCallback) .call() .content(); 使用编程规范方法时，可以将默认工具添加到ChatClient。通过将FunctionToolCallback实例传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(toolCallback) .build(); 使用编程规范方法时，可以将FunctionToolCallback实例传递给ToolCallingChatOptions的toolCallbacks（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build(): Prompt prompt = new Prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;, chatOptions); chatModel.call(prompt); 使用编程规范方法时，可以通过将FunctionToolCallback实例传递给用于创建ChatModel的ToolCallingChatOptions实例的ToolCallbick（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback toolCallback = ... ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build()) .build(); 将工具添加到ChatClient # 使用编程规范方法时，可以将FunctionToolCallback实例传递给ChatClient的tools（）方法。该工具仅适用于其添加到的特定聊天请求。\nToolCallback toolCallback = ... ChatClient.create(chatModel) .prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;) .tools(toolCallback) .call() .content(); 将默认工具添加到ChatClient # 使用编程规范方法时，可以将默认工具添加到ChatClient。通过将FunctionToolCallback实例传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(toolCallback) .build(); 将工具添加到ChatModel # 使用编程规范方法时，可以将FunctionToolCallback实例传递给ToolCallingChatOptions的toolCallbacks（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build(): Prompt prompt = new Prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;, chatOptions); chatModel.call(prompt); 将默认工具添加到ChatModel # 使用编程规范方法时，可以通过将FunctionToolCallback实例传递给用于创建ChatModel的ToolCallingChatOptions实例的ToolCallbick（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback toolCallback = ... ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build()) .build(); 动态规范：@Bean # 您可以将工具定义为Springbean，并让SpringAI使用ToolCallbackResolver接口（通过SpringBeanToolCallbickResolver实现）在运行时动态解析它们，而不是以编程方式指定工具。该选项允许您使用任何Function、Supplier、Consumer或BiFunctionbean作为工具。bean名称将用作工具名称，Spring Framework中的@Description注释可用于提供该工具的描述，模型使用该注释来理解何时以及如何调用该工具。如果不提供描述，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。\n@Configuration(proxyBeanMethods = false) class WeatherTools { WeatherService weatherService = new WeatherService(); @Bean @Description(\u0026#34;Get the weather in location\u0026#34;) Function\u0026lt;WeatherRequest, WeatherResponse\u0026gt; currentWeather() { return weatherService; } } 将自动生成工具输入参数的JSON模式。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。\nrecord WeatherRequest(@ToolParam(description = \u0026#34;The name of a city or a country\u0026#34;) String location, Unit unit) {} 这种工具规范方法的缺点是不能保证类型安全，因为工具解析是在运行时完成的。为了减轻这种情况，可以使用@Bean注释显式地指定工具名称，并将值存储在常量中，以便可以在聊天请求中使用它，而不是硬编码工具名称。\n@Configuration(proxyBeanMethods = false) class WeatherTools { public static final String CURRENT_WEATHER_TOOL = \u0026#34;currentWeather\u0026#34;; @Bean(CURRENT_WEATHER_TOOL) @Description(\u0026#34;Get the weather in location\u0026#34;) Function\u0026lt;WeatherRequest, WeatherResponse\u0026gt; currentWeather() { ... } } 使用动态规范方法时，可以将工具名称（即函数bean名称）传递给ChatClient的tools（）方法。 该工具仅适用于其添加到的特定聊天请求。\nChatClient.create(chatModel) .prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;) .tools(\u0026#34;currentWeather\u0026#34;) .call() .content(); 使用动态规范方法时，可以将默认工具添加到ChatClient。通过将工具名称传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(\u0026#34;currentWeather\u0026#34;) .build(); 使用动态规范方法时，可以将工具名称传递给用于调用ChatModel的ToolCallingChatOptions的toolNames（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolNames(\u0026#34;currentWeather\u0026#34;) .build(): Prompt prompt = new Prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;, chatOptions); chatModel.call(prompt); 使用动态规范方法时，可以通过将工具名称传递给用于创建ChatModel的ToolCallingChatOptions实例的toolNames（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolNames(\u0026#34;currentWeather\u0026#34;) .build()) .build(); 将工具添加到ChatClient # 使用动态规范方法时，可以将工具名称（即函数bean名称）传递给ChatClient的tools（）方法。 该工具仅适用于其添加到的特定聊天请求。\nChatClient.create(chatModel) .prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;) .tools(\u0026#34;currentWeather\u0026#34;) .call() .content(); 将默认工具添加到ChatClient # 使用动态规范方法时，可以将默认工具添加到ChatClient。通过将工具名称传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(\u0026#34;currentWeather\u0026#34;) .build(); 将工具添加到ChatModel # 使用动态规范方法时，可以将工具名称传递给用于调用ChatModel的ToolCallingChatOptions的toolNames（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolNames(\u0026#34;currentWeather\u0026#34;) .build(): Prompt prompt = new Prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;, chatOptions); chatModel.call(prompt); 将默认工具添加到ChatModel # 使用动态规范方法时，可以通过将工具名称传递给用于创建ChatModel的ToolCallingChatOptions实例的toolNames（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolNames(\u0026#34;currentWeather\u0026#34;) .build()) .build(); 功能工具限制 # 以下类型当前不支持作为用作工具的函数的输入或输出类型：\n基本体类型 可选 集合类型（例如列表、映射、数组、集合） 异步类型（例如CompletableFuture、Future） 无功类型（例如流量、单声道、通量）。 使用基于方法的工具规范方法支持基元类型和集合。有关详细信息，请参见作为工具的方法。 工具规格 # 在Spring AI中，工具通过ToolCallback接口建模。在前面的部分中，我们已经看到了如何使用Spring AI提供的内置支持从方法和函数中定义工具（请参见 方法作为工具和函数作为工具）。本节将深入研究工具规范，以及如何定制和扩展它以支持更多用例。 ToolCallback接口提供了一种定义AI模型可以调用的工具的方法，包括定义和执行逻辑。当您想要从头定义工具时，它是要实现的主界面。例如，可以从MCP客户端（使用模型上下文协议）或ChatClient（构建模块化代理应用程序）定义ToolCallback。 该接口提供以下方法：\npublic interface ToolCallback { /** * Definition used by the AI model to determine when and how to call the tool. */ ToolDefinition getToolDefinition(); /** * Metadata providing additional information on how to handle the tool. */ ToolMetadata getToolMetadata(); /** * Execute tool with the given input and return the result to send back to the AI model. */ String call(String toolInput); /** * Execute tool with the given input and context, and return the result to send back to the AI model. */ String call(String toolInput, ToolContext tooContext); } Spring AI为工具方法（MethodToolCallback）和工具函数（FunctionToolCallbak）提供了内置实现。 ToolDefinition接口为AI模型提供所需的信息，以了解工具的可用性，包括工具名称、描述和输入模式。每个ToolCallback实现都必须提供ToolDefinition实例来定义工具。 该接口提供以下方法：\npublic interface ToolDefinition { /** * The tool name. Unique within the tool set provided to a model. */ String name(); /** * The tool description, used by the AI model to determine what the tool does. */ String description(); /** * The schema of the parameters used to call the tool. */ String inputSchema(); } 工具定义。Builder允许使用默认实现（DefaultToolDefinition）构建ToolDefinitionInstance。\nToolDefinition toolDefinition = ToolDefinition.builder() .name(\u0026#34;currentWeather\u0026#34;) .description(\u0026#34;Get the weather in location\u0026#34;) .inputSchema(\u0026#34;\u0026#34;\u0026#34; { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;unit\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;enum\u0026#34;: [\u0026#34;C\u0026#34;, \u0026#34;F\u0026#34;] } }, \u0026#34;required\u0026#34;: [\u0026#34;location\u0026#34;, \u0026#34;unit\u0026#34;] } \u0026#34;\u0026#34;\u0026#34;) .build(); 从方法生成工具时，将自动为您生成ToolDefinition。如果您希望自己生成ToolDefinition，则可以使用此方便的生成器。\nMethod method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolDefinition toolDefinition = ToolDefinition.from(method); 从方法生成的ToolDefinition包括作为工具名称的方法名、作为工具描述的方法名以及方法输入参数的JSON模式。如果使用@Tool对方法进行注释，则工具名称和描述将从注释中获取（如果设置）。 如果希望显式提供部分或全部属性，则可以使用ToolDefinition。生成器以生成自定义ToolDefinition实例。\nMethod method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolDefinition toolDefinition = ToolDefinition.builder(method) .name(\u0026#34;currentDateTime\u0026#34;) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .inputSchema(JsonSchemaGenerator.generateForMethodInput(method)) .build(); 从函数构建工具时，将自动为您生成工具定义。使用FunctionToolCallback时。生成器以生成FunctionToolCallback实例，则可以提供将用于生成ToolDefinition的工具名称、描述和输入架构。有关详细信息，请参阅“ 作为工具的功能”。 当为AI模型提供工具时，模型需要知道用于调用该工具的输入类型的模式。模式用于理解如何调用工具和准备工具请求。SpringAI通过JsonSchemaGenerator类为工具生成输入类型的JSONSchema提供了内置支持。架构作为ToolDefinition的一部分提供。 JsonSchemaGenerator类在幕后用于为方法或函数的输入参数生成JSON模式，使用Methods as Tools和Functions as Tools中描述的任何策略。JSON模式生成逻辑支持一系列注释，您可以对方法和函数的输入参数使用这些注释来定制结果模式。 本节描述在为工具的输入参数生成JSON模式时可以定制的两个主要选项：描述和所需状态。 除了为工具本身提供描述外，还可以为工具的输入参数提供描述。描述可用于提供有关输入参数的关键信息，例如参数应采用何种格式、允许使用何种值等。这有助于帮助模型理解输入模式以及如何使用它。Spring AI为使用以下注释之一生成输入参数的描述提供了内置支持：\n@Spring AI的ToolParam（description=“…”） @来自Jackson的JsonClassDescription（description=“…”） @来自Jackson的JsonPropertyDescription（description=“…”） @Swagger的架构（description=“…”）。 这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。 import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.ai.tool.annotation.ToolParam; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Set a user alarm for the given time\u0026#34;) void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } 默认情况下，每个输入参数都被认为是必需的，这迫使AI模型在调用工具时为其提供值。然而，可以通过使用以下注释之一（按优先级顺序）使输入参数成为可选的：\n@Spring AI的ToolParam（必需=假） @Jackson的JsonProperty（必需=false） @Swagger的架构（必需=假） @从Spring Framework可以为Null。 这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。 class CustomerTools { @Tool(description = \u0026#34;Update customer information\u0026#34;) void updateCustomerInfo(Long id, String name, @ToolParam(required = false) String email) { System.out.println(\u0026#34;Updated info for customer with id: \u0026#34; + id); } } 工具调用的结果使用ToolCallResultConverter序列化，然后发送回AI模型。ToolCallResultConverter接口提供了一种将工具调用的结果转换为String对象的方法。 该接口提供以下方法：\n@FunctionalInterface public interface ToolCallResultConverter { /** * Given an Object returned by a tool, convert it to a String compatible with the * given class type. */ String convert(@Nullable Object result, @Nullable Type returnType); } 结果必须是可序列化类型。默认情况下，使用Jackson（DefaultToolCallResultConverter``）将结果序列化为JSON，但您可以通过提供自己的ToolCallresultConvertor实现来定制序列化过程。 Spring AI在方法和函数工具中都依赖于ToolCallResultConverter。 从具有声明性方法的方法构建工具时，可以通过设置@tool注释的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。\nclass CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;, resultConverter = CustomToolCallResultConverter.class) Customer getCustomerInfo(Long id) { return customerRepository.findById(id); } } 如果使用编程方法，则可以通过设置MethodToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。 有关详细信息，请参见作为工具的方法。 使用编程方法从函数构建工具时，可以通过设置FunctionToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。 有关详细信息，请参阅“ 作为工具的功能”。 Spring AI支持通过ToolContext API将额外的上下文信息传递给工具。此功能允许您提供额外的用户提供的数据，这些数据可以与AI模型传递的工具参数一起在工具执行中使用。 class CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;) Customer getCustomerInfo(Long id, ToolContext toolContext) { return customerRepository.findById(id, toolContext.get(\u0026#34;tenantId\u0026#34;)); } } ToolContext由用户在调用ChatClient时提供的数据填充。\nChatModel chatModel = ... String response = ChatClient.create(chatModel) .prompt(\u0026#34;Tell me more about the customer with ID 42\u0026#34;) .tools(new CustomerTools()) .toolContext(Map.of(\u0026#34;tenantId\u0026#34;, \u0026#34;acme\u0026#34;)) .call() .content(); System.out.println(response); 类似地，您可以在直接调用ChatModel时定义工具上下文数据。\nChatModel chatModel = ... ToolCallback[] customerTools = ToolCallbacks.from(new CustomerTools()); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(customerTools) .toolContext(Map.of(\u0026#34;tenantId\u0026#34;, \u0026#34;acme\u0026#34;)) .build(); Prompt prompt = new Prompt(\u0026#34;Tell me more about the customer with ID 42\u0026#34;, chatOptions); chatModel.call(prompt); 如果在默认选项和运行时选项中都设置了toolContext选项，则生成的toolContext将是这两个选项的合并， 其中运行时选项优先于默认选项。 默认情况下，工具调用的结果作为响应发送回模型。然后，模型可以使用结果来继续对话。 在某些情况下，您宁愿将结果直接返回给调用者，而不是将其发送回模型。例如，如果构建依赖于RAG工具的代理，则可能希望将结果直接返回给调用者，而不是将其发送回模型进行不必要的后处理。或者，您可能有某些工具可以结束代理的推理循环。 每个ToolCallback实现都可以定义是将工具调用的结果直接返回给调用者，还是发送回模型。默认情况下，结果被发送回模型。但您可以根据工具更改此行为。 ToolCallingManager负责管理工具执行生命周期，负责处理与工具关联的returnDirect属性。如果属性设置为true，则工具调用的结果将直接返回给调用者。否则，结果将发送回模型。 从具有声明性方法的方法构建工具时，可以通过将@tool注释的returnDirect属性设置为true来标记工具以直接将结果返回给调用方。\nclass CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;, returnDirect = true) Customer getCustomerInfo(Long id) { return customerRepository.findById(id); } } 如果使用编程方法，则可以通过ToolMetadata接口设置returnDirect属性，并将其传递给MethodToolCallback。建筑商。\nToolMetadata toolMetadata = ToolMetadata.builder() .returnDirect(true) .build(); 有关详细信息，请参见作为工具的方法。 使用编程方法从函数构建工具时，可以通过ToolMetadata接口设置returnDirect属性，并将其传递给FunctionToolCallback。建筑商。\nToolMetadata toolMetadata = ToolMetadata.builder() .returnDirect(true) .build(); 有关详细信息，请参阅“ 作为工具的功能”。\n工具回调 # ToolCallback接口提供了一种定义AI模型可以调用的工具的方法，包括定义和执行逻辑。当您想要从头定义工具时，它是要实现的主界面。例如，可以从MCP客户端（使用模型上下文协议）或ChatClient（构建模块化代理应用程序）定义ToolCallback。 该接口提供以下方法：\npublic interface ToolCallback { /** * Definition used by the AI model to determine when and how to call the tool. */ ToolDefinition getToolDefinition(); /** * Metadata providing additional information on how to handle the tool. */ ToolMetadata getToolMetadata(); /** * Execute tool with the given input and return the result to send back to the AI model. */ String call(String toolInput); /** * Execute tool with the given input and context, and return the result to send back to the AI model. */ String call(String toolInput, ToolContext tooContext); } Spring AI为工具方法（MethodToolCallback）和工具函数（FunctionToolCallbak）提供了内置实现。\n刀具定义 # ToolDefinition接口为AI模型提供所需的信息，以了解工具的可用性，包括工具名称、描述和输入模式。每个ToolCallback实现都必须提供ToolDefinition实例来定义工具。 该接口提供以下方法：\npublic interface ToolDefinition { /** * The tool name. Unique within the tool set provided to a model. */ String name(); /** * The tool description, used by the AI model to determine what the tool does. */ String description(); /** * The schema of the parameters used to call the tool. */ String inputSchema(); } 工具定义。Builder允许使用默认实现（DefaultToolDefinition）构建ToolDefinitionInstance。\nToolDefinition toolDefinition = ToolDefinition.builder() .name(\u0026#34;currentWeather\u0026#34;) .description(\u0026#34;Get the weather in location\u0026#34;) .inputSchema(\u0026#34;\u0026#34;\u0026#34; { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;unit\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;enum\u0026#34;: [\u0026#34;C\u0026#34;, \u0026#34;F\u0026#34;] } }, \u0026#34;required\u0026#34;: [\u0026#34;location\u0026#34;, \u0026#34;unit\u0026#34;] } \u0026#34;\u0026#34;\u0026#34;) .build(); 从方法生成工具时，将自动为您生成ToolDefinition。如果您希望自己生成ToolDefinition，则可以使用此方便的生成器。\nMethod method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolDefinition toolDefinition = ToolDefinition.from(method); 从方法生成的ToolDefinition包括作为工具名称的方法名、作为工具描述的方法名以及方法输入参数的JSON模式。如果使用@Tool对方法进行注释，则工具名称和描述将从注释中获取（如果设置）。 如果希望显式提供部分或全部属性，则可以使用ToolDefinition。生成器以生成自定义ToolDefinition实例。\nMethod method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolDefinition toolDefinition = ToolDefinition.builder(method) .name(\u0026#34;currentDateTime\u0026#34;) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .inputSchema(JsonSchemaGenerator.generateForMethodInput(method)) .build(); 从函数构建工具时，将自动为您生成工具定义。使用FunctionToolCallback时。生成器以生成FunctionToolCallback实例，则可以提供将用于生成ToolDefinition的工具名称、描述和输入架构。有关详细信息，请参阅“ 作为工具的功能”。\n方法工具定义 # 从方法生成工具时，将自动为您生成ToolDefinition。如果您希望自己生成ToolDefinition，则可以使用此方便的生成器。\nMethod method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolDefinition toolDefinition = ToolDefinition.from(method); 从方法生成的ToolDefinition包括作为工具名称的方法名、作为工具描述的方法名以及方法输入参数的JSON模式。如果使用@Tool对方法进行注释，则工具名称和描述将从注释中获取（如果设置）。 如果希望显式提供部分或全部属性，则可以使用ToolDefinition。生成器以生成自定义ToolDefinition实例。\nMethod method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolDefinition toolDefinition = ToolDefinition.builder(method) .name(\u0026#34;currentDateTime\u0026#34;) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .inputSchema(JsonSchemaGenerator.generateForMethodInput(method)) .build(); 功能工具定义 # 从函数构建工具时，将自动为您生成工具定义。使用FunctionToolCallback时。生成器以生成FunctionToolCallback实例，则可以提供将用于生成ToolDefinition的工具名称、描述和输入架构。有关详细信息，请参阅“ 作为工具的功能”。\nJSON架构 # 当为AI模型提供工具时，模型需要知道用于调用该工具的输入类型的模式。模式用于理解如何调用工具和准备工具请求。SpringAI通过JsonSchemaGenerator类为工具生成输入类型的JSONSchema提供了内置支持。架构作为ToolDefinition的一部分提供。 JsonSchemaGenerator类在幕后用于为方法或函数的输入参数生成JSON模式，使用Methods as Tools和Functions as Tools中描述的任何策略。JSON模式生成逻辑支持一系列注释，您可以对方法和函数的输入参数使用这些注释来定制结果模式。 本节描述在为工具的输入参数生成JSON模式时可以定制的两个主要选项：描述和所需状态。 除了为工具本身提供描述外，还可以为工具的输入参数提供描述。描述可用于提供有关输入参数的关键信息，例如参数应采用何种格式、允许使用何种值等。这有助于帮助模型理解输入模式以及如何使用它。Spring AI为使用以下注释之一生成输入参数的描述提供了内置支持：\n@Spring AI的ToolParam（description=“…”） @来自Jackson的JsonClassDescription（description=“…”） @来自Jackson的JsonPropertyDescription（description=“…”） @Swagger的架构（description=“…”）。 这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。 import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.ai.tool.annotation.ToolParam; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Set a user alarm for the given time\u0026#34;) void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } 默认情况下，每个输入参数都被认为是必需的，这迫使AI模型在调用工具时为其提供值。然而，可以通过使用以下注释之一（按优先级顺序）使输入参数成为可选的：\n@Spring AI的ToolParam（必需=假） @Jackson的JsonProperty（必需=false） @Swagger的架构（必需=假） @从Spring Framework可以为Null。 这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。 class CustomerTools { @Tool(description = \u0026#34;Update customer information\u0026#34;) void updateCustomerInfo(Long id, String name, @ToolParam(required = false) String email) { System.out.println(\u0026#34;Updated info for customer with id: \u0026#34; + id); } } 描述 # 除了为工具本身提供描述外，还可以为工具的输入参数提供描述。描述可用于提供有关输入参数的关键信息，例如参数应采用何种格式、允许使用何种值等。这有助于帮助模型理解输入模式以及如何使用它。Spring AI为使用以下注释之一生成输入参数的描述提供了内置支持：\n@Spring AI的ToolParam（description=“…”） @来自Jackson的JsonClassDescription（description=“…”） @来自Jackson的JsonPropertyDescription（description=“…”） @Swagger的架构（description=“…”）。 这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。 import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.ai.tool.annotation.ToolParam; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Set a user alarm for the given time\u0026#34;) void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } 必需/可选 # 默认情况下，每个输入参数都被认为是必需的，这迫使AI模型在调用工具时为其提供值。然而，可以通过使用以下注释之一（按优先级顺序）使输入参数成为可选的：\n@Spring AI的ToolParam（必需=假） @Jackson的JsonProperty（必需=false） @Swagger的架构（必需=假） @从Spring Framework可以为Null。 这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。 class CustomerTools { @Tool(description = \u0026#34;Update customer information\u0026#34;) void updateCustomerInfo(Long id, String name, @ToolParam(required = false) String email) { System.out.println(\u0026#34;Updated info for customer with id: \u0026#34; + id); } } 结果转换 # 工具调用的结果使用ToolCallResultConverter序列化，然后发送回AI模型。ToolCallResultConverter接口提供了一种将工具调用的结果转换为String对象的方法。 该接口提供以下方法：\n@FunctionalInterface public interface ToolCallResultConverter { /** * Given an Object returned by a tool, convert it to a String compatible with the * given class type. */ String convert(@Nullable Object result, @Nullable Type returnType); } 结果必须是可序列化类型。默认情况下，使用Jackson（DefaultToolCallResultConverter``）将结果序列化为JSON，但您可以通过提供自己的ToolCallresultConvertor实现来定制序列化过程。 Spring AI在方法和函数工具中都依赖于ToolCallResultConverter。 从具有声明性方法的方法构建工具时，可以通过设置@tool注释的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。\nclass CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;, resultConverter = CustomToolCallResultConverter.class) Customer getCustomerInfo(Long id) { return customerRepository.findById(id); } } 如果使用编程方法，则可以通过设置MethodToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。 有关详细信息，请参见作为工具的方法。 使用编程方法从函数构建工具时，可以通过设置FunctionToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。 有关详细信息，请参阅“ 作为工具的功能”。\n方法工具调用结果转换 # 从具有声明性方法的方法构建工具时，可以通过设置@tool注释的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。\nclass CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;, resultConverter = CustomToolCallResultConverter.class) Customer getCustomerInfo(Long id) { return customerRepository.findById(id); } } 如果使用编程方法，则可以通过设置MethodToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。 有关详细信息，请参见作为工具的方法。\n函数工具调用结果转换 # 使用编程方法从函数构建工具时，可以通过设置FunctionToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。 有关详细信息，请参阅“ 作为工具的功能”。\n工具上下文 # Spring AI支持通过ToolContext API将额外的上下文信息传递给工具。此功能允许您提供额外的用户提供的数据，这些数据可以与AI模型传递的工具参数一起在工具执行中使用。 class CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;) Customer getCustomerInfo(Long id, ToolContext toolContext) { return customerRepository.findById(id, toolContext.get(\u0026#34;tenantId\u0026#34;)); } } ToolContext由用户在调用ChatClient时提供的数据填充。\nChatModel chatModel = ... String response = ChatClient.create(chatModel) .prompt(\u0026#34;Tell me more about the customer with ID 42\u0026#34;) .tools(new CustomerTools()) .toolContext(Map.of(\u0026#34;tenantId\u0026#34;, \u0026#34;acme\u0026#34;)) .call() .content(); System.out.println(response); 类似地，您可以在直接调用ChatModel时定义工具上下文数据。\nChatModel chatModel = ... ToolCallback[] customerTools = ToolCallbacks.from(new CustomerTools()); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(customerTools) .toolContext(Map.of(\u0026#34;tenantId\u0026#34;, \u0026#34;acme\u0026#34;)) .build(); Prompt prompt = new Prompt(\u0026#34;Tell me more about the customer with ID 42\u0026#34;, chatOptions); chatModel.call(prompt); 如果在默认选项和运行时选项中都设置了toolContext选项，则生成的toolContext将是这两个选项的合并， 其中运行时选项优先于默认选项。\n直接退货 # 默认情况下，工具调用的结果作为响应发送回模型。然后，模型可以使用结果来继续对话。 在某些情况下，您宁愿将结果直接返回给调用者，而不是将其发送回模型。例如，如果构建依赖于RAG工具的代理，则可能希望将结果直接返回给调用者，而不是将其发送回模型进行不必要的后处理。或者，您可能有某些工具可以结束代理的推理循环。 每个ToolCallback实现都可以定义是将工具调用的结果直接返回给调用者，还是发送回模型。默认情况下，结果被发送回模型。但您可以根据工具更改此行为。 ToolCallingManager负责管理工具执行生命周期，负责处理与工具关联的returnDirect属性。如果属性设置为true，则工具调用的结果将直接返回给调用者。否则，结果将发送回模型。 从具有声明性方法的方法构建工具时，可以通过将@tool注释的returnDirect属性设置为true来标记工具以直接将结果返回给调用方。\nclass CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;, returnDirect = true) Customer getCustomerInfo(Long id) { return customerRepository.findById(id); } } 如果使用编程方法，则可以通过ToolMetadata接口设置returnDirect属性，并将其传递给MethodToolCallback。建筑商。\nToolMetadata toolMetadata = ToolMetadata.builder() .returnDirect(true) .build(); 有关详细信息，请参见作为工具的方法。 使用编程方法从函数构建工具时，可以通过ToolMetadata接口设置returnDirect属性，并将其传递给FunctionToolCallback。建筑商。\nToolMetadata toolMetadata = ToolMetadata.builder() .returnDirect(true) .build(); 有关详细信息，请参阅“ 作为工具的功能”。\n方法直接返回 # 从具有声明性方法的方法构建工具时，可以通过将@tool注释的returnDirect属性设置为true来标记工具以直接将结果返回给调用方。\nclass CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;, returnDirect = true) Customer getCustomerInfo(Long id) { return customerRepository.findById(id); } } 如果使用编程方法，则可以通过ToolMetadata接口设置returnDirect属性，并将其传递给MethodToolCallback。建筑商。\nToolMetadata toolMetadata = ToolMetadata.builder() .returnDirect(true) .build(); 有关详细信息，请参见作为工具的方法。\n函数直接返回 # 使用编程方法从函数构建工具时，可以通过ToolMetadata接口设置returnDirect属性，并将其传递给FunctionToolCallback。建筑商。\nToolMetadata toolMetadata = ToolMetadata.builder() .returnDirect(true) .build(); 有关详细信息，请参阅“ 作为工具的功能”。\n刀具执行 # 工具执行是使用提供的输入参数调用工具并返回结果的过程。工具执行由ToolCallingManager接口处理，该接口负责管理工具执行生命周期。\npublic interface ToolCallingManager { /** * Resolve the tool definitions from the model\u0026#39;s tool calling options. */ List\u0026lt;ToolDefinition\u0026gt; resolveToolDefinitions(ToolCallingChatOptions chatOptions); /** * Execute the tool calls requested by the model. */ ToolExecutionResult executeToolCalls(Prompt prompt, ChatResponse chatResponse); } 如果您正在使用任何Spring AI Spring Boot Starters，`DefaultToolCallingManager```是ToolCalling Manager接口的自动配置实现。您可以通过提供自己的ToolCallingManager``bean来定制工具执行行为。\n@Bean ToolCallingManager toolCallingManager() { return ToolCallingManager.builder().build(); } 默认情况下，Spring AI从每个ChatModel实现中为您透明地管理工具执行生命周期。但您有可能选择退出此行为，并自行控制工具的执行。本节描述这两个场景。 当使用默认行为时，Spring AI将自动拦截来自模型的任何工具调用请求，调用该工具并将结果返回给模型。所有这些都是通过使用ToolCallingManager的每个ChatModel实现为您透明地完成的。 在某些情况下，您宁愿自己控制工具执行生命周期。可以通过将ToolCallingChatOptions的internalToolExecutionEnabled属性设置为false来完成此操作。 或者，您可以实现ToolExecutionEligibilityPredicate谓词来控制工具执行合格性。 默认谓词实现如下所示：\npublic class DefaultToolExecutionEligibilityPredicate implements ToolExecutionEligibilityPredicate { @Override public boolean test(ChatOptions promptOptions, ChatResponse chatResponse) { return ToolCallingChatOptions.isInternalToolExecutionEnabled(promptOptions) \u0026amp;\u0026amp; chatResponse != null \u0026amp;\u0026amp; chatResponse.hasToolCalls(); } } 使用此选项调用ChatModel时，工具执行将委托给调用者，使您能够完全控制工具执行生命周期。您的责任是检查ChatResponse中的工具调用，并使用ToolCallingManager执行它们。 下面的示例演示了用户控制的工具执行方法的最小实现：\nChatModel chatModel = ... ToolCallingManager toolCallingManager = ToolCallingManager.builder().build(); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(new CustomerTools()) .internalToolExecutionEnabled(false) .build(); Prompt prompt = new Prompt(\u0026#34;Tell me more about the customer with ID 42\u0026#34;, chatOptions); ChatResponse chatResponse = chatModel.call(prompt); while (chatResponse.hasToolCalls()) { ToolExecutionResult toolExecutionResult = toolCallingManager.executeToolCalls(prompt, chatResponse); prompt = new Prompt(toolExecutionResult.conversationHistory(), chatOptions); chatResponse = chatModel.call(prompt); } System.out.println(chatResponse.getResult().getOutput().getText()); 当工具调用失败时，异常将作为ToolExecutionException传播，可以捕获该异常来处理错误。ToolExecutionExceptionProcessor可用于处理ToolExectionException，具有两个结果：要么生成要发送回AI模型的错误消息，要么引发要由调用方处理的异常。\n@FunctionalInterface public interface ToolExecutionExceptionProcessor { /** * Convert an exception thrown by a tool to a String that can be sent back to the AI * model or throw an exception to be handled by the caller. */ String process(ToolExecutionException exception); } 如果您正在使用任何Spring AI Spring Boot Starters，DefaultToolExecutionExceptionProcessor是ToolExectionException处理器接口的自动配置实现。默认情况下，错误消息被发送回模型。`Default`ToolExecutionExceptionProcessor构造函数允许将alwaysThrow属性设置为true或false。如果为true，则将引发异常，而不是将错误消息发送回模型。\n@Bean ToolExecutionExceptionProcessor toolExecutionExceptionProcessor() { return new DefaultToolExecutionExceptionProcessor(true); } ToolExecutionExceptionProcessor由默认ToolCallingManager（DefaultToolCalling Manager）在内部使用，以处理工具执行期间的异常。有关工具执行生命周期的更多详细信息，请参见工具执行。\n框架控制的工具执行 # 当使用默认行为时，Spring AI将自动拦截来自模型的任何工具调用请求，调用该工具并将结果返回给模型。所有这些都是通过使用ToolCallingManager的每个ChatModel实现为您透明地完成的。 用户控制的工具执行 # 在某些情况下，您宁愿自己控制工具执行生命周期。可以通过将ToolCallingChatOptions的internalToolExecutionEnabled属性设置为false来完成此操作。 或者，您可以实现ToolExecutionEligibilityPredicate谓词来控制工具执行合格性。 默认谓词实现如下所示：\npublic class DefaultToolExecutionEligibilityPredicate implements ToolExecutionEligibilityPredicate { @Override public boolean test(ChatOptions promptOptions, ChatResponse chatResponse) { return ToolCallingChatOptions.isInternalToolExecutionEnabled(promptOptions) \u0026amp;\u0026amp; chatResponse != null \u0026amp;\u0026amp; chatResponse.hasToolCalls(); } } 使用此选项调用ChatModel时，工具执行将委托给调用者，使您能够完全控制工具执行生命周期。您的责任是检查ChatResponse中的工具调用，并使用ToolCallingManager执行它们。 下面的示例演示了用户控制的工具执行方法的最小实现：\nChatModel chatModel = ... ToolCallingManager toolCallingManager = ToolCallingManager.builder().build(); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(new CustomerTools()) .internalToolExecutionEnabled(false) .build(); Prompt prompt = new Prompt(\u0026#34;Tell me more about the customer with ID 42\u0026#34;, chatOptions); ChatResponse chatResponse = chatModel.call(prompt); while (chatResponse.hasToolCalls()) { ToolExecutionResult toolExecutionResult = toolCallingManager.executeToolCalls(prompt, chatResponse); prompt = new Prompt(toolExecutionResult.conversationHistory(), chatOptions); chatResponse = chatModel.call(prompt); } System.out.println(chatResponse.getResult().getOutput().getText()); 异常处理 # 当工具调用失败时，异常将作为ToolExecutionException传播，可以捕获该异常来处理错误。ToolExecutionExceptionProcessor可用于处理ToolExectionException，具有两个结果：要么生成要发送回AI模型的错误消息，要么引发要由调用方处理的异常。\n@FunctionalInterface public interface ToolExecutionExceptionProcessor { /** * Convert an exception thrown by a tool to a String that can be sent back to the AI * model or throw an exception to be handled by the caller. */ String process(ToolExecutionException exception); } 如果您正在使用任何Spring AI Spring Boot Starters，DefaultToolExecutionExceptionProcessor是ToolExectionException处理器接口的自动配置实现。默认情况下，错误消息被发送回模型。`Default`ToolExecutionExceptionProcessor构造函数允许将alwaysThrow属性设置为true或false。如果为true，则将引发异常，而不是将错误消息发送回模型。\n@Bean ToolExecutionExceptionProcessor toolExecutionExceptionProcessor() { return new DefaultToolExecutionExceptionProcessor(true); } ToolExecutionExceptionProcessor由默认ToolCallingManager（DefaultToolCalling Manager）在内部使用，以处理工具执行期间的异常。有关工具执行生命周期的更多详细信息，请参见工具执行。\n工具分辨率 # 将工具传递到模型的主要方法是在调用ChatClient或ChatModel时提供ToolCallback， 使用 方法作为工具和功能作为工具中描述的策略之一。 然而，Spring AI还支持使用ToolCallbackResolver接口在运行时动态解析工具。\npublic interface ToolCallbackResolver { /** * Resolve the {@link ToolCallback} for the given tool name. */ @Nullable ToolCallback resolve(String toolName); } 使用此方法时：\n在客户端，将工具名称提供给ChatClient或ChatModel，而不是ToolCallback。 在服务器端，ToolCallbackResolver实现负责将工具名称解析为相应的ToolCallbak实例。 默认情况下，Spring AI依赖于DelegatingToolCallbackResolver``，后者将工具解析委托给ToolCallbakResolver实例列表： SpringBeanToolCallbackResolver从Function、Supplier、Consumer或BiFunction类型的SpringBean解析工具。有关详细信息，请参阅动态规范：@Bean。 StaticToolCallbackResolver从ToolCallbak实例的静态列表中解析工具。当使用SpringBoot自动配置时，该解析器自动配置为应用程序上下文中定义的所有ToolCallback类型的bean。 如果依赖于SpringBoot自动配置，则可以通过提供自定义ToolCallbackResolverbean来定制解析逻辑。 @Bean ToolCallbackResolver toolCallbackResolver(List\u0026lt;FunctionCallback\u0026gt; toolCallbacks) { StaticToolCallbackResolver staticToolCallbackResolver = new StaticToolCallbackResolver(toolCallbacks); return new DelegatingToolCallbackResolver(List.of(staticToolCallbackResolver)); } ToolCallbackResolver由ToolCallingManager在内部使用，以在运行时动态解析工具，支持 框架控制的工具执行和用户控制的工具运行。\n可观察性 # 工具调用的检测正在进行中。现在，您可以使用日志功能来跟踪工具调用操作。 刀具调用功能的所有主要操作都在DEBUG级别记录。您可以通过将org.springframework.ai包的日志级别设置为DEBUG来启用日志记录。\n日志记录 # 刀具调用功能的所有主要操作都在DEBUG级别记录。您可以通过将org.springframework.ai包的日志级别设置为DEBUG来启用日志记录。\n信息检索 # 该版本仍在开发中，尚不稳定。对于最新的快照版本，请使用Spring AI 1.0.0-snapshot！ 工具调用（也称为函数调用）是人工智能应用程序中的一种常见模式，允许模型与一组API或工具交互，以增强其功能。 工具主要用于：\n信息检索。此类别中的工具可用于从外部源（如数据库、web服务、文件系统或web搜索引擎）检索信息。目标是增加模型的知识，使其能够回答否则无法回答的问题。因此，它们可以用于检索增强生成（RAG）场景。例如，工具可以用于检索给定位置的当前天气、检索最新的新闻文章或查询数据库中的特定记录。 采取行动。此类别中的工具可用于在软件系统中执行操作，例如发送电子邮件、在数据库中创建新记录、提交表单或触发工作流。目标是将需要人工干预或显式编程的任务自动化。例如，工具可以用于为与聊天机器人交互的客户预订航班，在网页上填写表单，或者在代码生成场景中基于自动测试（TDD）实现Java类。 尽管我们通常将工具调用称为模型功能，但实际上由客户端应用程序提供工具调用逻辑。模型只能请求工具调用并提供输入参数，而应用程序负责从输入参数执行工具调用并返回结果。该模型永远无法访问作为工具提供的任何API，这是一个关键的安全考虑事项。 SpringAI提供了方便的API来定义工具、解决来自模型的工具调用请求和执行工具调用。以下部分概述了Spring AI中的工具调用功能。 让我们看看如何开始在SpringAI中使用工具调用。我们将实现两个简单的工具：一个用于信息检索，另一个用于采取行动。信息检索工具将用于获取用户时区中的当前日期和时间。操作工具将用于设置指定时间的报警。 人工智能模型无法访问实时信息。任何假设知道当前日期或天气预报等信息的问题都不能由模型回答。然而，我们可以提供一个可以检索该信息的工具，并让模型在需要访问实时信息时调用该工具。 让我们实现一个工具，在DateTimeTools类中获取用户时区中的当前日期和时间。该工具不需要参数。Spring框架中的LocaleContextHolder可以提供用户的时区。该工具将被定义为用@tool注释的方法。为了帮助模型理解是否以及何时调用该工具，我们将提供工具功能的详细描述。 import java.time.LocalDateTime; import org.springframework.ai.tool.annotation.Tool; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } 接下来，让我们为模型提供该工具。在这个例子中，我们将使用ChatClient与模型交互。我们将通过tools（）方法传递DateTimeTools的实例来为模型提供工具。当模型需要知道当前日期和时间时，它将请求调用该工具。在内部，ChatClient将调用工具并将结果返回给模型，然后模型将使用工具调用结果来生成对原始问题的最终响应。\nChatModel chatModel = ... String response = ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); System.out.println(response); 输出将类似于：\nTomorrow is 2015-10-21. 您可以重新尝试询问相同的问题。这一次，不要为模型提供工具。输出将类似于：\nI am an AI and do not have access to real-time information. Please provide the current date so I can accurately determine what day tomorrow will be. 如果没有该工具，模型就不知道如何回答这个问题，因为它不能确定当前的日期和时间。 人工智能模型可用于生成实现特定目标的计划。例如，模型可以生成预订丹麦旅行的计划。然而，模型没有执行计划的能力。这就是工具的作用：它们可以用于执行模型生成的计划。 在前面的示例中，我们使用了一个工具来确定当前日期和时间。在本例中，我们将定义第二个工具，用于在特定时间设置报警。目标是从现在开始设置10分钟的警报，因此我们需要为模型提供这两个工具来完成这项任务。 我们将一如既往地将新工具添加到相同的DateTimeTools类中。新工具将采用单个参数，即ISO-8601格式的时间。然后，该工具将向控制台打印一条消息，指示已为给定时间设置报警。与前面一样，该工具被定义为用@tool注释的方法，我们也使用它来提供详细的描述，以帮助模型理解何时以及如何使用该工具。\nimport java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } @Tool(description = \u0026#34;Set a user alarm for the given time, provided in ISO-8601 format\u0026#34;) void setAlarm(String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } 接下来，让我们将这两个工具都提供给模型。我们将使用ChatClient与模型交互。我们将通过tools（）方法传递DateTimeTools的实例来为模型提供工具。当我们要求在10分钟后设置警报时，模型首先需要知道当前的日期和时间。然后，它将使用当前日期和时间来计算报警时间。最后，它将使用报警工具来设置报警。在内部，ChatClient将处理来自模型的任何工具调用请求，并将任何工具调用执行结果发送回它，以便模型可以生成最终响应。\nChatModel chatModel = ... String response = ChatClient.create(chatModel) .prompt(\u0026#34;Can you set an alarm 10 minutes from now?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); System.out.println(response); 在应用程序日志中，您可以检查警报是否已在正确的时间设置。 SpringAI通过一组灵活的抽象来支持工具调用，这些抽象允许您以一致的方式定义、解析和执行工具。本节概述了Spring AI中工具调用的主要概念和组件。 工具是工具调用的构建块，它们由ToolCallback接口建模。Spring AI提供了从方法和函数指定ToolCallback的内置支持，但您始终可以定义自己的ToolCallbak实现来支持更多用例。 ChatModel实现透明地将工具调用请求分派到相应的ToolCallback实现，并将工具调用结果发送回模型，该模型最终将生成最终响应。它们使用ToolCallingManager接口来执行此操作，该接口负责管理工具执行生命周期。 ChatClient和ChatModel都接受ToolCallback对象的列表，以使工具可用于模型和最终将执行它们的ToolCallingManager。 除了直接传递ToolCallback对象外，还可以传递工具名称列表，该列表将使用ToolCallbickResolver接口动态解析。 下面的部分将详细介绍所有这些概念和API，包括如何定制和扩展它们以支持更多用例。 Spring AI以两种方式提供了从方法中指定工具（即ToolCallback）的内置支持：\n声明性地，使用@Tool注释 以编程方式，使用低级MethodToolCallback实现。 通过使用@tool对方法进行注释，可以将其转换为工具。 class DateTimeTools { @Tool(description = \u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } @Tool注释允许您提供有关工具的关键信息：\nname：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。 description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。 returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。 resultConverter：用于将工具调用的结果转换为String对象以发送回AI模型的ToolCallResultConvertor实现。有关详细信息，请参见结果转换。 该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。 可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括void。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。 Spring AI将自动为@Tool注释方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。@ToolParam注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。 import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.ai.tool.annotation.ToolParam; class DateTimeTools { @Tool(description = \u0026#34;Set a user alarm for the given time\u0026#34;) void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } @ToolParam注释允许您提供有关工具参数的关键信息：\ndescription:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。 required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。 如果参数被注释为@Nullable，则它将被视为可选的，除非使用@ToolParam注释根据需要显式标记。 除了@ToolParam注释外，您还可以使用Swager的@Schema注释或Jackson的@JsonProperty注释。有关更多详细信息，请参阅JSON模式。 使用声明性规范方法时，可以在调用ChatClient时将工具类实例传递给tools（）方法。此类工具仅适用于它们添加到的特定聊天请求。 ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); 在幕后，ChatClient将从工具类实例中的每个@Tool注释方法生成一个ToolCallback，并将它们传递给模型。如果希望自己生成ToolCallback，则可以使用ToolCallbaks实用程序类。\nToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); 使用声明性规范方法时，可以将默认工具添加到ChatClient。通过将工具类实例传递给defaultTools（）方法来生成生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(new DateTimeTools()) .build(); 使用声明性规范方法时，可以将工具类实例传递给用于调用ChatModel的ToolCallingChatOptions的toolCallback（）方法。此类工具仅适用于它们添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(dateTimeTools) .build(): Prompt prompt = new Prompt(\u0026#34;What day is tomorrow?\u0026#34;, chatOptions); chatModel.call(prompt); 使用声明性规范方法时，可以通过将工具类实例传递给用于创建ChatModel的ToolCallingChatOptions实例的toolCallback（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(dateTimeTools) .build()) .build(); 通过以编程方式构建MethodToolCallback，可以将方法转换为工具。\nclass DateTimeTools { String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } MethodToolCallback。Builder允许您构建MethodToolCallback实例，并提供有关该工具的关键信息：\ntoolDefinition：定义工具名称、描述和输入架构的toolDefinition实例。可以使用ToolDefinition构建它。生成器类。必需。 toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。 toolMethod：表示工具方法的Method实例。必需。 toolObject：包含工具方法的对象实例。如果方法是静态的，则可以省略此参数。 toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。 工具定义。Builder允许您构建ToolDefinition实例，并定义工具名称、描述和输入架构： name：工具的名称。如果未提供，将使用方法名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一个类中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。 description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。 inputSchema：工具输入参数的JSON模式。如果未提供，则将基于方法参数自动生成架构。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。 ToolMetadata。Builder允许您构建ToolMetadata实例，并定义工具的其他设置： returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。 Method method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolCallback toolCallback = MethodToolCallback.builder() .toolDefinition(ToolDefinition.builder(method) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .build()) .toolMethod(method) .toolObject(new DateTimeTools()) .build(); 该方法可以是静态的，也可以是实例的，并且它可以具有任何可见性（public、protected、package private或private）。包含该方法的类可以是顶级类或嵌套类，并且它也可以具有任何可见性（只要在计划实例化它的位置可以访问）。 可以为大多数类型（原语、POJO、枚举、列表、数组、映射等）的方法定义任意数量的参数（包括无参数）。类似地，该方法可以返回大多数类型，包括void。如果方法返回值，则返回类型必须是可序列化类型，因为结果将被序列化并发送回模型。 如果方法是静态的，则可以省略toolObject（）方法，因为不需要它。\nclass DateTimeTools { static String getCurrentDateTime() { return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString(); } } Method method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolCallback toolCallback = MethodToolCallback.builder() .toolDefinition(ToolDefinition.builder(method) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .build()) .toolMethod(method) .build(); Spring AI将自动为方法的输入参数生成JSON模式。模型使用模式来理解如何调用工具和准备工具请求。@ToolParam注释可用于提供有关输入参数的附加信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。\nimport java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.ToolParam; class DateTimeTools { void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } @ToolParam注释允许您提供有关工具参数的关键信息：\ndescription:参数的描述，模型可以使用它来更好地理解如何使用它。例如，参数应该采用什么格式，允许使用什么值，等等。 required：参数是必需的还是可选的。默认情况下，所有参数都被认为是必需的。 如果参数被注释为@Nullable，则它将被视为可选的，除非使用@ToolParam注释根据需要显式标记。 除了@ToolParam注释外，您还可以使用Swager的@Schema注释或Jackson的@JsonProperty注释。有关更多详细信息，请参阅JSON模式。 使用编程规范方法时，可以将MethodToolCallback实例传递给ChatClient的tools（）方法。 该工具仅适用于其添加到的特定聊天请求。 ToolCallback toolCallback = ... ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(toolCallback) .call() .content(); 使用编程规范方法时，可以将默认工具添加到ChatClient。通过将MethodToolCallback实例传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(toolCallback) .build(); 使用编程规范方法时，可以将MethodToolCallback实例传递给用于调用ChatModel的ToolCallingChatOptions的Toolcallback（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build(): Prompt prompt = new Prompt(\u0026#34;What day is tomorrow?\u0026#34;, chatOptions); chatModel.call(prompt); 使用编程规范方法时，可以通过将MethodToolCallback实例传递给用于创建ChatModel的ToolCallingChatOptions实例的ToolCallbark（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback toolCallback = ... ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build()) .build(); 以下类型当前不支持作为用作工具的方法的参数或返回类型：\n可选 异步类型（例如CompletableFuture、Future） 无功类型（例如Flow、Mono、Flux） 功能类型（例如功能、供应商、消费者）。 使用基于函数的工具规范方法支持函数类型。有关详细信息，请参阅“ 作为工具的功能”。 Spring AI提供了从函数中指定工具的内置支持，可以通过编程方式使用低级FunctionToolCallback实现，也可以在运行时动态解析为@Bean。 通过以编程方式构建FunctionToolCallback，可以将函数类型（Function、Supplier、Consumer或BiFunction）转换为工具。 public class WeatherService implements Function\u0026lt;WeatherRequest, WeatherResponse\u0026gt; { public WeatherResponse apply(WeatherRequest request) { return new WeatherResponse(30.0, Unit.C); } } public enum Unit { C, F } public record WeatherRequest(String location, Unit unit) {} public record WeatherResponse(double temp, Unit unit) {} FunctionToolCallback。Builder允许您构建FunctionToolCallback实例，并提供有关该工具的关键信息：\nname：工具的名称。人工智能模型在调用工具时使用这个名称来标识它。因此，不允许在同一上下文中有两个同名的工具。对于特定的聊天请求，该名称在模型可用的所有工具中都必须是唯一的。必需。 toolFunction：表示工具方法（Function、Supplier、Consumer或BiFunction）的函数对象。必需。 description:工具的描述，模型可以使用该描述来了解何时以及如何调用工具。如果未提供，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。 inputType：函数输入的类型。必需。 inputSchema：工具输入参数的JSON模式。如果未提供，则将基于inputType自动生成模式。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。 toolMetadata：toolMetadata实例，定义其他设置，例如是否应将结果直接返回到客户端，以及要使用的结果转换器。可以使用ToolMetadata构建它。生成器类。 toolCallResultConverter：用于将工具调用的结果转换为要发送回AI模型的String对象的ToolCallResaultConverter实例。如果未提供，则将使用默认转换器（DefaultToolCallResultConverter）。 ToolMetadata。Builder允许您构建ToolMetadata实例，并定义工具的其他设置： returnDirect：工具结果应该直接返回给客户端还是传递回模型。有关更多详细信息，请参阅直接退货。 ToolCallback toolCallback = FunctionToolCallback .builder(\u0026#34;currentWeather\u0026#34;, new WeatherService()) .description(\u0026#34;Get the weather in location\u0026#34;) .inputType(WeatherRequest.class) .build(); 功能输入和输出可以是Void或POJO。输入和输出POJO必须是可序列化的，因为结果将被序列化并发送回模型。函数以及输入和输出类型必须是公共的。 使用编程规范方法时，可以将FunctionToolCallback实例传递给ChatClient的tools（）方法。该工具仅适用于其添加到的特定聊天请求。\nToolCallback toolCallback = ... ChatClient.create(chatModel) .prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;) .tools(toolCallback) .call() .content(); 使用编程规范方法时，可以将默认工具添加到ChatClient。通过将FunctionToolCallback实例传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(toolCallback) .build(); 使用编程规范方法时，可以将FunctionToolCallback实例传递给ToolCallingChatOptions的toolCallbacks（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build(): Prompt prompt = new Prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;, chatOptions); chatModel.call(prompt); 使用编程规范方法时，可以通过将FunctionToolCallback实例传递给用于创建ChatModel的ToolCallingChatOptions实例的ToolCallbick（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback toolCallback = ... ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build()) .build(); 您可以将工具定义为Springbean，并让SpringAI使用ToolCallbackResolver接口（通过SpringBeanToolCallbickResolver实现）在运行时动态解析它们，而不是以编程方式指定工具。该选项允许您使用任何Function、Supplier、Consumer或BiFunctionbean作为工具。bean名称将用作工具名称，Spring Framework中的@Description注释可用于提供该工具的描述，模型使用该注释来理解何时以及如何调用该工具。如果不提供描述，则方法名称将用作工具描述。然而，强烈建议提供详细的描述，因为这对于模型理解工具的用途和如何使用它是至关重要的。未能提供良好的描述可能会导致模型在应该使用该工具时不使用该工具，或者错误地使用该工具。\n@Configuration(proxyBeanMethods = false) class WeatherTools { WeatherService weatherService = new WeatherService(); @Bean @Description(\u0026#34;Get the weather in location\u0026#34;) Function\u0026lt;WeatherRequest, WeatherResponse\u0026gt; currentWeather() { return weatherService; } } 将自动生成工具输入参数的JSON模式。您可以使用@ToolParam注释来提供有关输入参数的其他信息，例如描述或参数是必需的还是可选的。默认情况下，所有输入参数都被认为是必需的。有关更多详细信息，请参阅JSON模式。\nrecord WeatherRequest(@ToolParam(description = \u0026#34;The name of a city or a country\u0026#34;) String location, Unit unit) {} 这种工具规范方法的缺点是不能保证类型安全，因为工具解析是在运行时完成的。为了减轻这种情况，可以使用@Bean注释显式地指定工具名称，并将值存储在常量中，以便可以在聊天请求中使用它，而不是硬编码工具名称。\n@Configuration(proxyBeanMethods = false) class WeatherTools { public static final String CURRENT_WEATHER_TOOL = \u0026#34;currentWeather\u0026#34;; @Bean(CURRENT_WEATHER_TOOL) @Description(\u0026#34;Get the weather in location\u0026#34;) Function\u0026lt;WeatherRequest, WeatherResponse\u0026gt; currentWeather() { ... } } 使用动态规范方法时，可以将工具名称（即函数bean名称）传递给ChatClient的tools（）方法。 该工具仅适用于其添加到的特定聊天请求。\nChatClient.create(chatModel) .prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;) .tools(\u0026#34;currentWeather\u0026#34;) .call() .content(); 使用动态规范方法时，可以将默认工具添加到ChatClient。通过将工具名称传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(\u0026#34;currentWeather\u0026#34;) .build(); 使用动态规范方法时，可以将工具名称传递给用于调用ChatModel的ToolCallingChatOptions的toolNames（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolNames(\u0026#34;currentWeather\u0026#34;) .build(): Prompt prompt = new Prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;, chatOptions); chatModel.call(prompt); 使用动态规范方法时，可以通过将工具名称传递给用于创建ChatModel的ToolCallingChatOptions实例的toolNames（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolNames(\u0026#34;currentWeather\u0026#34;) .build()) .build(); 以下类型当前不支持作为用作工具的函数的输入或输出类型：\n基本体类型 可选 集合类型（例如列表、映射、数组、集合） 异步类型（例如CompletableFuture、Future） 无功类型（例如流量、单声道、通量）。 使用基于方法的工具规范方法支持基元类型和集合。有关详细信息，请参见作为工具的方法。 在Spring AI中，工具通过ToolCallback接口建模。在前面的部分中，我们已经看到了如何使用Spring AI提供的内置支持从方法和函数中定义工具（请参见 方法作为工具和函数作为工具）。本节将深入研究工具规范，以及如何定制和扩展它以支持更多用例。 ToolCallback接口提供了一种定义AI模型可以调用的工具的方法，包括定义和执行逻辑。当您想要从头定义工具时，它是要实现的主界面。例如，可以从MCP客户端（使用模型上下文协议）或ChatClient（构建模块化代理应用程序）定义ToolCallback。 该接口提供以下方法： public interface ToolCallback { /** * Definition used by the AI model to determine when and how to call the tool. */ ToolDefinition getToolDefinition(); /** * Metadata providing additional information on how to handle the tool. */ ToolMetadata getToolMetadata(); /** * Execute tool with the given input and return the result to send back to the AI model. */ String call(String toolInput); /** * Execute tool with the given input and context, and return the result to send back to the AI model. */ String call(String toolInput, ToolContext tooContext); } Spring AI为工具方法（MethodToolCallback）和工具函数（FunctionToolCallbak）提供了内置实现。 ToolDefinition接口为AI模型提供所需的信息，以了解工具的可用性，包括工具名称、描述和输入模式。每个ToolCallback实现都必须提供ToolDefinition实例来定义工具。 该接口提供以下方法：\npublic interface ToolDefinition { /** * The tool name. Unique within the tool set provided to a model. */ String name(); /** * The tool description, used by the AI model to determine what the tool does. */ String description(); /** * The schema of the parameters used to call the tool. */ String inputSchema(); } 工具定义。Builder允许使用默认实现（DefaultToolDefinition）构建ToolDefinitionInstance。\nToolDefinition toolDefinition = ToolDefinition.builder() .name(\u0026#34;currentWeather\u0026#34;) .description(\u0026#34;Get the weather in location\u0026#34;) .inputSchema(\u0026#34;\u0026#34;\u0026#34; { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;unit\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;enum\u0026#34;: [\u0026#34;C\u0026#34;, \u0026#34;F\u0026#34;] } }, \u0026#34;required\u0026#34;: [\u0026#34;location\u0026#34;, \u0026#34;unit\u0026#34;] } \u0026#34;\u0026#34;\u0026#34;) .build(); 从方法生成工具时，将自动为您生成ToolDefinition。如果您希望自己生成ToolDefinition，则可以使用此方便的生成器。\nMethod method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolDefinition toolDefinition = ToolDefinition.from(method); 从方法生成的ToolDefinition包括作为工具名称的方法名、作为工具描述的方法名以及方法输入参数的JSON模式。如果使用@Tool对方法进行注释，则工具名称和描述将从注释中获取（如果设置）。 如果希望显式提供部分或全部属性，则可以使用ToolDefinition。生成器以生成自定义ToolDefinition实例。\nMethod method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolDefinition toolDefinition = ToolDefinition.builder(method) .name(\u0026#34;currentDateTime\u0026#34;) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .inputSchema(JsonSchemaGenerator.generateForMethodInput(method)) .build(); 从函数构建工具时，将自动为您生成工具定义。使用FunctionToolCallback时。生成器以生成FunctionToolCallback实例，则可以提供将用于生成ToolDefinition的工具名称、描述和输入架构。有关详细信息，请参阅“ 作为工具的功能”。 当为AI模型提供工具时，模型需要知道用于调用该工具的输入类型的模式。模式用于理解如何调用工具和准备工具请求。SpringAI通过JsonSchemaGenerator类为工具生成输入类型的JSONSchema提供了内置支持。架构作为ToolDefinition的一部分提供。 JsonSchemaGenerator类在幕后用于为方法或函数的输入参数生成JSON模式，使用Methods as Tools和Functions as Tools中描述的任何策略。JSON模式生成逻辑支持一系列注释，您可以对方法和函数的输入参数使用这些注释来定制结果模式。 本节描述在为工具的输入参数生成JSON模式时可以定制的两个主要选项：描述和所需状态。 除了为工具本身提供描述外，还可以为工具的输入参数提供描述。描述可用于提供有关输入参数的关键信息，例如参数应采用何种格式、允许使用何种值等。这有助于帮助模型理解输入模式以及如何使用它。Spring AI为使用以下注释之一生成输入参数的描述提供了内置支持：\n@Spring AI的ToolParam（description=“…”） @来自Jackson的JsonClassDescription（description=“…”） @来自Jackson的JsonPropertyDescription（description=“…”） @Swagger的架构（description=“…”）。 这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。 import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.ai.tool.annotation.ToolParam; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Set a user alarm for the given time\u0026#34;) void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } 默认情况下，每个输入参数都被认为是必需的，这迫使AI模型在调用工具时为其提供值。然而，可以通过使用以下注释之一（按优先级顺序）使输入参数成为可选的：\n@Spring AI的ToolParam（必需=假） @Jackson的JsonProperty（必需=false） @Swagger的架构（必需=假） @从Spring Framework可以为Null。 这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。 class CustomerTools { @Tool(description = \u0026#34;Update customer information\u0026#34;) void updateCustomerInfo(Long id, String name, @ToolParam(required = false) String email) { System.out.println(\u0026#34;Updated info for customer with id: \u0026#34; + id); } } 工具调用的结果使用ToolCallResultConverter序列化，然后发送回AI模型。ToolCallResultConverter接口提供了一种将工具调用的结果转换为String对象的方法。 该接口提供以下方法：\n@FunctionalInterface public interface ToolCallResultConverter { /** * Given an Object returned by a tool, convert it to a String compatible with the * given class type. */ String convert(@Nullable Object result, @Nullable Type returnType); } 结果必须是可序列化类型。默认情况下，使用Jackson（DefaultToolCallResultConverter``）将结果序列化为JSON，但您可以通过提供自己的ToolCallresultConvertor实现来定制序列化过程。 Spring AI在方法和函数工具中都依赖于ToolCallResultConverter。 从具有声明性方法的方法构建工具时，可以通过设置@tool注释的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。\nclass CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;, resultConverter = CustomToolCallResultConverter.class) Customer getCustomerInfo(Long id) { return customerRepository.findById(id); } } 如果使用编程方法，则可以通过设置MethodToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。 有关详细信息，请参见作为工具的方法。 使用编程方法从函数构建工具时，可以通过设置FunctionToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。 有关详细信息，请参阅“ 作为工具的功能”。 Spring AI支持通过ToolContext API将额外的上下文信息传递给工具。此功能允许您提供额外的用户提供的数据，这些数据可以与AI模型传递的工具参数一起在工具执行中使用。 class CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;) Customer getCustomerInfo(Long id, ToolContext toolContext) { return customerRepository.findById(id, toolContext.get(\u0026#34;tenantId\u0026#34;)); } } ToolContext由用户在调用ChatClient时提供的数据填充。\nChatModel chatModel = ... String response = ChatClient.create(chatModel) .prompt(\u0026#34;Tell me more about the customer with ID 42\u0026#34;) .tools(new CustomerTools()) .toolContext(Map.of(\u0026#34;tenantId\u0026#34;, \u0026#34;acme\u0026#34;)) .call() .content(); System.out.println(response); 类似地，您可以在直接调用ChatModel时定义工具上下文数据。\nChatModel chatModel = ... ToolCallback[] customerTools = ToolCallbacks.from(new CustomerTools()); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(customerTools) .toolContext(Map.of(\u0026#34;tenantId\u0026#34;, \u0026#34;acme\u0026#34;)) .build(); Prompt prompt = new Prompt(\u0026#34;Tell me more about the customer with ID 42\u0026#34;, chatOptions); chatModel.call(prompt); 如果在默认选项和运行时选项中都设置了toolContext选项，则生成的toolContext将是这两个选项的合并， 其中运行时选项优先于默认选项。 默认情况下，工具调用的结果作为响应发送回模型。然后，模型可以使用结果来继续对话。 在某些情况下，您宁愿将结果直接返回给调用者，而不是将其发送回模型。例如，如果构建依赖于RAG工具的代理，则可能希望将结果直接返回给调用者，而不是将其发送回模型进行不必要的后处理。或者，您可能有某些工具可以结束代理的推理循环。 每个ToolCallback实现都可以定义是将工具调用的结果直接返回给调用者，还是发送回模型。默认情况下，结果被发送回模型。但您可以根据工具更改此行为。 ToolCallingManager负责管理工具执行生命周期，负责处理与工具关联的returnDirect属性。如果属性设置为true，则工具调用的结果将直接返回给调用者。否则，结果将发送回模型。 从具有声明性方法的方法构建工具时，可以通过将@tool注释的returnDirect属性设置为true来标记工具以直接将结果返回给调用方。\nclass CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;, returnDirect = true) Customer getCustomerInfo(Long id) { return customerRepository.findById(id); } } 如果使用编程方法，则可以通过ToolMetadata接口设置returnDirect属性，并将其传递给MethodToolCallback。建筑商。\nToolMetadata toolMetadata = ToolMetadata.builder() .returnDirect(true) .build(); 有关详细信息，请参见作为工具的方法。 使用编程方法从函数构建工具时，可以通过ToolMetadata接口设置returnDirect属性，并将其传递给FunctionToolCallback。建筑商。\nToolMetadata toolMetadata = ToolMetadata.builder() .returnDirect(true) .build(); 有关详细信息，请参阅“ 作为工具的功能”。 工具执行是使用提供的输入参数调用工具并返回结果的过程。工具执行由ToolCallingManager接口处理，该接口负责管理工具执行生命周期。\npublic interface ToolCallingManager { /** * Resolve the tool definitions from the model\u0026#39;s tool calling options. */ List\u0026lt;ToolDefinition\u0026gt; resolveToolDefinitions(ToolCallingChatOptions chatOptions); /** * Execute the tool calls requested by the model. */ ToolExecutionResult executeToolCalls(Prompt prompt, ChatResponse chatResponse); } 如果您正在使用任何Spring AI Spring Boot Starters，`DefaultToolCallingManager```是ToolCalling Manager接口的自动配置实现。您可以通过提供自己的ToolCallingManager``bean来定制工具执行行为。\n@Bean ToolCallingManager toolCallingManager() { return ToolCallingManager.builder().build(); } 默认情况下，Spring AI从每个ChatModel实现中为您透明地管理工具执行生命周期。但您有可能选择退出此行为，并自行控制工具的执行。本节描述这两个场景。 当使用默认行为时，Spring AI将自动拦截来自模型的任何工具调用请求，调用该工具并将结果返回给模型。所有这些都是通过使用ToolCallingManager的每个ChatModel实现为您透明地完成的。 在某些情况下，您宁愿自己控制工具执行生命周期。可以通过将ToolCallingChatOptions的internalToolExecutionEnabled属性设置为false来完成此操作。 或者，您可以实现ToolExecutionEligibilityPredicate谓词来控制工具执行合格性。 默认谓词实现如下所示：\npublic class DefaultToolExecutionEligibilityPredicate implements ToolExecutionEligibilityPredicate { @Override public boolean test(ChatOptions promptOptions, ChatResponse chatResponse) { return ToolCallingChatOptions.isInternalToolExecutionEnabled(promptOptions) \u0026amp;\u0026amp; chatResponse != null \u0026amp;\u0026amp; chatResponse.hasToolCalls(); } } 使用此选项调用ChatModel时，工具执行将委托给调用者，使您能够完全控制工具执行生命周期。您的责任是检查ChatResponse中的工具调用，并使用ToolCallingManager执行它们。 下面的示例演示了用户控制的工具执行方法的最小实现：\nChatModel chatModel = ... ToolCallingManager toolCallingManager = ToolCallingManager.builder().build(); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(new CustomerTools()) .internalToolExecutionEnabled(false) .build(); Prompt prompt = new Prompt(\u0026#34;Tell me more about the customer with ID 42\u0026#34;, chatOptions); ChatResponse chatResponse = chatModel.call(prompt); while (chatResponse.hasToolCalls()) { ToolExecutionResult toolExecutionResult = toolCallingManager.executeToolCalls(prompt, chatResponse); prompt = new Prompt(toolExecutionResult.conversationHistory(), chatOptions); chatResponse = chatModel.call(prompt); } System.out.println(chatResponse.getResult().getOutput().getText()); 当工具调用失败时，异常将作为ToolExecutionException传播，可以捕获该异常来处理错误。ToolExecutionExceptionProcessor可用于处理ToolExectionException，具有两个结果：要么生成要发送回AI模型的错误消息，要么引发要由调用方处理的异常。\n@FunctionalInterface public interface ToolExecutionExceptionProcessor { /** * Convert an exception thrown by a tool to a String that can be sent back to the AI * model or throw an exception to be handled by the caller. */ String process(ToolExecutionException exception); } 如果您正在使用任何Spring AI Spring Boot Starters，DefaultToolExecutionExceptionProcessor是ToolExectionException处理器接口的自动配置实现。默认情况下，错误消息被发送回模型。`Default`ToolExecutionExceptionProcessor构造函数允许将alwaysThrow属性设置为true或false。如果为true，则将引发异常，而不是将错误消息发送回模型。\n@Bean ToolExecutionExceptionProcessor toolExecutionExceptionProcessor() { return new DefaultToolExecutionExceptionProcessor(true); } ToolExecutionExceptionProcessor由默认ToolCallingManager（DefaultToolCalling Manager）在内部使用，以处理工具执行期间的异常。有关工具执行生命周期的更多详细信息，请参见工具执行。 将工具传递到模型的主要方法是在调用ChatClient或ChatModel时提供ToolCallback， 使用 方法作为工具和功能作为工具中描述的策略之一。 然而，Spring AI还支持使用ToolCallbackResolver接口在运行时动态解析工具。\npublic interface ToolCallbackResolver { /** * Resolve the {@link ToolCallback} for the given tool name. */ @Nullable ToolCallback resolve(String toolName); } 使用此方法时：\n在客户端，将工具名称提供给ChatClient或ChatModel，而不是ToolCallback。 在服务器端，ToolCallbackResolver实现负责将工具名称解析为相应的ToolCallbak实例。 默认情况下，Spring AI依赖于DelegatingToolCallbackResolver``，后者将工具解析委托给ToolCallbakResolver实例列表： SpringBeanToolCallbackResolver从Function、Supplier、Consumer或BiFunction类型的SpringBean解析工具。有关详细信息，请参阅动态规范：@Bean。 StaticToolCallbackResolver从ToolCallbak实例的静态列表中解析工具。当使用SpringBoot自动配置时，该解析器自动配置为应用程序上下文中定义的所有ToolCallback类型的bean。 如果依赖于SpringBoot自动配置，则可以通过提供自定义ToolCallbackResolverbean来定制解析逻辑。 @Bean ToolCallbackResolver toolCallbackResolver(List\u0026lt;FunctionCallback\u0026gt; toolCallbacks) { StaticToolCallbackResolver staticToolCallbackResolver = new StaticToolCallbackResolver(toolCallbacks); return new DelegatingToolCallbackResolver(List.of(staticToolCallbackResolver)); } ToolCallbackResolver由ToolCallingManager在内部使用，以在运行时动态解析工具，支持 框架控制的工具执行和用户控制的工具运行。 工具调用的检测正在进行中。现在，您可以使用日志功能来跟踪工具调用操作。 刀具调用功能的所有主要操作都在DEBUG级别记录。您可以通过将org.springframework.ai包的日志级别设置为DEBUG来启用日志记录。\n将工具添加到ChatClient # 使用声明性规范方法时，可以在调用ChatClient时将工具类实例传递给tools（）方法。此类工具仅适用于它们添加到的特定聊天请求。\nChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(new DateTimeTools()) .call() .content(); 在幕后，ChatClient将从工具类实例中的每个@Tool注释方法生成一个ToolCallback，并将它们传递给模型。如果希望自己生成ToolCallback，则可以使用ToolCallbaks实用程序类。\nToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); 将默认工具添加到ChatClient # 使用声明性规范方法时，可以将默认工具添加到ChatClient。通过将工具类实例传递给defaultTools（）方法来生成生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(new DateTimeTools()) .build(); 将工具添加到ChatModel # 使用声明性规范方法时，可以将工具类实例传递给用于调用ChatModel的ToolCallingChatOptions的toolCallback（）方法。此类工具仅适用于它们添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(dateTimeTools) .build(): Prompt prompt = new Prompt(\u0026#34;What day is tomorrow?\u0026#34;, chatOptions); chatModel.call(prompt); 将默认工具添加到ChatModel # 使用声明性规范方法时，可以通过将工具类实例传递给用于创建ChatModel的ToolCallingChatOptions实例的toolCallback（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools()); ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(dateTimeTools) .build()) .build(); 将工具添加到ChatClient和ChatModel # 使用编程规范方法时，可以将MethodToolCallback实例传递给ChatClient的tools（）方法。 该工具仅适用于其添加到的特定聊天请求。\nToolCallback toolCallback = ... ChatClient.create(chatModel) .prompt(\u0026#34;What day is tomorrow?\u0026#34;) .tools(toolCallback) .call() .content(); 将默认工具添加到ChatClient # 使用编程规范方法时，可以将默认工具添加到ChatClient。通过将MethodToolCallback实例传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(toolCallback) .build(); 将工具添加到ChatModel # 使用编程规范方法时，可以将MethodToolCallback实例传递给用于调用ChatModel的ToolCallingChatOptions的Toolcallback（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build(): Prompt prompt = new Prompt(\u0026#34;What day is tomorrow?\u0026#34;, chatOptions); chatModel.call(prompt); 将默认工具添加到ChatModel # 使用编程规范方法时，可以通过将MethodToolCallback实例传递给用于创建ChatModel的ToolCallingChatOptions实例的ToolCallbark（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback toolCallback = ... ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build()) .build(); 将工具添加到ChatClient # 使用编程规范方法时，可以将FunctionToolCallback实例传递给ChatClient的tools（）方法。该工具仅适用于其添加到的特定聊天请求。\nToolCallback toolCallback = ... ChatClient.create(chatModel) .prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;) .tools(toolCallback) .call() .content(); 将默认工具添加到ChatClient # 使用编程规范方法时，可以将默认工具添加到ChatClient。通过将FunctionToolCallback实例传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(toolCallback) .build(); 将工具添加到ChatModel # 使用编程规范方法时，可以将FunctionToolCallback实例传递给ToolCallingChatOptions的toolCallbacks（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ToolCallback toolCallback = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build(): Prompt prompt = new Prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;, chatOptions); chatModel.call(prompt); 将默认工具添加到ChatModel # 使用编程规范方法时，可以通过将FunctionToolCallback实例传递给用于创建ChatModel的ToolCallingChatOptions实例的ToolCallbick（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nToolCallback toolCallback = ... ChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolCallbacks(toolCallback) .build()) .build(); 将工具添加到ChatClient # 使用动态规范方法时，可以将工具名称（即函数bean名称）传递给ChatClient的tools（）方法。 该工具仅适用于其添加到的特定聊天请求。\nChatClient.create(chatModel) .prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;) .tools(\u0026#34;currentWeather\u0026#34;) .call() .content(); 将默认工具添加到ChatClient # 使用动态规范方法时，可以将默认工具添加到ChatClient。通过将工具名称传递给defaultTools（）方法来构建生成器。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = ... ChatClient chatClient = ChatClient.builder(chatModel) .defaultTools(\u0026#34;currentWeather\u0026#34;) .build(); 将工具添加到ChatModel # 使用动态规范方法时，可以将工具名称传递给用于调用ChatModel的ToolCallingChatOptions的toolNames（）方法。该工具仅适用于其添加到的特定聊天请求。\nChatModel chatModel = ... ChatOptions chatOptions = ToolCallingChatOptions.builder() .toolNames(\u0026#34;currentWeather\u0026#34;) .build(): Prompt prompt = new Prompt(\u0026#34;What\u0026#39;s the weather like in Copenhagen?\u0026#34;, chatOptions); chatModel.call(prompt); 将默认工具添加到ChatModel # 使用动态规范方法时，可以通过将工具名称传递给用于创建ChatModel的ToolCallingChatOptions实例的toolNames（）方法，在构造时将默认工具添加到ChatModel。 如果同时提供了默认工具和运行时工具，则运行时工具将完全覆盖默认工具。\nChatModel chatModel = OllamaChatModel.builder() .ollamaApi(new OllamaApi()) .defaultOptions(ToolCallingChatOptions.builder() .toolNames(\u0026#34;currentWeather\u0026#34;) .build()) .build(); 方法工具定义 # 从方法生成工具时，将自动为您生成ToolDefinition。如果您希望自己生成ToolDefinition，则可以使用此方便的生成器。\nMethod method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolDefinition toolDefinition = ToolDefinition.from(method); 从方法生成的ToolDefinition包括作为工具名称的方法名、作为工具描述的方法名以及方法输入参数的JSON模式。如果使用@Tool对方法进行注释，则工具名称和描述将从注释中获取（如果设置）。 如果希望显式提供部分或全部属性，则可以使用ToolDefinition。生成器以生成自定义ToolDefinition实例。\nMethod method = ReflectionUtils.findMethod(DateTimeTools.class, \u0026#34;getCurrentDateTime\u0026#34;); ToolDefinition toolDefinition = ToolDefinition.builder(method) .name(\u0026#34;currentDateTime\u0026#34;) .description(\u0026#34;Get the current date and time in the user\u0026#39;s timezone\u0026#34;) .inputSchema(JsonSchemaGenerator.generateForMethodInput(method)) .build(); 功能工具定义 # 从函数构建工具时，将自动为您生成工具定义。使用FunctionToolCallback时。生成器以生成FunctionToolCallback实例，则可以提供将用于生成ToolDefinition的工具名称、描述和输入架构。有关详细信息，请参阅“ 作为工具的功能”。\n描述 # 除了为工具本身提供描述外，还可以为工具的输入参数提供描述。描述可用于提供有关输入参数的关键信息，例如参数应采用何种格式、允许使用何种值等。这有助于帮助模型理解输入模式以及如何使用它。Spring AI为使用以下注释之一生成输入参数的描述提供了内置支持：\n@Spring AI的ToolParam（description=“…”） @来自Jackson的JsonClassDescription（description=“…”） @来自Jackson的JsonPropertyDescription（description=“…”） @Swagger的架构（description=“…”）。 这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。 import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import org.springframework.ai.tool.annotation.Tool; import org.springframework.ai.tool.annotation.ToolParam; import org.springframework.context.i18n.LocaleContextHolder; class DateTimeTools { @Tool(description = \u0026#34;Set a user alarm for the given time\u0026#34;) void setAlarm(@ToolParam(description = \u0026#34;Time in ISO-8601 format\u0026#34;) String time) { LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME); System.out.println(\u0026#34;Alarm set for \u0026#34; + alarmTime); } } 必需/可选 # 默认情况下，每个输入参数都被认为是必需的，这迫使AI模型在调用工具时为其提供值。然而，可以通过使用以下注释之一（按优先级顺序）使输入参数成为可选的：\n@Spring AI的ToolParam（必需=假） @Jackson的JsonProperty（必需=false） @Swagger的架构（必需=假） @从Spring Framework可以为Null。 这种方法适用于方法和函数，并且您可以对嵌套类型递归地使用它。 class CustomerTools { @Tool(description = \u0026#34;Update customer information\u0026#34;) void updateCustomerInfo(Long id, String name, @ToolParam(required = false) String email) { System.out.println(\u0026#34;Updated info for customer with id: \u0026#34; + id); } } 方法工具调用结果转换 # 从具有声明性方法的方法构建工具时，可以通过设置@tool注释的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。\nclass CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;, resultConverter = CustomToolCallResultConverter.class) Customer getCustomerInfo(Long id) { return customerRepository.findById(id); } } 如果使用编程方法，则可以通过设置MethodToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。 有关详细信息，请参见作为工具的方法。\n函数工具调用结果转换 # 使用编程方法从函数构建工具时，可以通过设置FunctionToolCallback的resultConverter（）属性来提供用于该工具的自定义ToolCallResultConvertor。建筑商。 有关详细信息，请参阅“ 作为工具的功能”。\n方法直接返回 # 从具有声明性方法的方法构建工具时，可以通过将@tool注释的returnDirect属性设置为true来标记工具以直接将结果返回给调用方。\nclass CustomerTools { @Tool(description = \u0026#34;Retrieve customer information\u0026#34;, returnDirect = true) Customer getCustomerInfo(Long id) { return customerRepository.findById(id); } } 如果使用编程方法，则可以通过ToolMetadata接口设置returnDirect属性，并将其传递给MethodToolCallback。建筑商。\nToolMetadata toolMetadata = ToolMetadata.builder() .returnDirect(true) .build(); 有关详细信息，请参见作为工具的方法。\n函数直接返回 # 使用编程方法从函数构建工具时，可以通过ToolMetadata接口设置returnDirect属性，并将其传递给FunctionToolCallback。建筑商。\nToolMetadata toolMetadata = ToolMetadata.builder() .returnDirect(true) .build(); 有关详细信息，请参阅“ 作为工具的功能”。\n"},{"id":2,"href":"/docs/concepts/","title":"Concepts","section":"文档","content":" 人工智能概念 # 本节描述Spring AI使用的核心概念。我们建议仔细阅读它，以了解Spring AI是如何实现的。\n型号 # 人工智能模型是设计用于处理和生成信息的算法，通常模仿人类的认知功能。通过从大型数据集学习模式和见解，这些模型可以做出预测、文本、图像或其他输出，增强跨行业的各种应用。 有许多不同类型的人工智能模型，每种模型都适用于特定的用例。虽然ChatGPT及其生成人工智能功能通过文本输入和输出吸引了用户，但许多模型和公司提供了不同的输入和输出。在ChatGPT之前，许多人都对文本到图像的生成模型（如Midtrivel和稳定扩散）着迷。 下表根据输入和输出类型对几个模型进行了分类： Spring AI目前支持将输入和输出处理为语言、图像和音频的模型。上一个表中的最后一行接受文本作为输入，输出数字，更常见的是嵌入文本，并表示AI模型中使用的内部数据结构。Spring AI支持嵌入，以支持更高级的用例。 将GPT等模型区分开来的是它们的预训练性质，如GPT聊天生成预训练变压器中的“P”所示。此预训练功能将AI转换为一般开发人员工具，不需要广泛的机器学习或模型训练背景。\n提示 # 提示是基于语言的输入的基础，指导人工智能模型产生特定的输出。对于熟悉ChatGPT的人来说，提示符可能看起来仅仅是输入到发送到API的对话框中的文本。然而，它包含的远不止这些。在许多AI模型中，提示的文本不仅仅是简单的字符串。 ChatGPT的API在提示中有多个文本输入，每个文本输入都被分配了一个角色。例如，有一个系统角色，它告诉模型如何行为，并设置交互的上下文。还有用户角色，通常是来自用户的输入。 制作有效的提示既是一门艺术，也是一门科学。ChatGPT是为人类对话而设计的。这与使用SQL之类的东西来“提问”有很大的不同。一个人必须与人工智能模型进行沟通，就像与另一个人交谈一样。 这种交互风格的重要性是如此之大，以至于术语“即时工程”已经成为自己的学科。有一组新兴的技术可以提高提示的有效性。在创建提示符方面投入时间可以显著提高结果输出。 共享提示已成为一种公共实践，并且正在对此主题进行积极的学术研究。作为一个例子，创建一个有效的提示可能是多么违反直觉（例如，与SQL对比），最近的一篇研究论文发现，你可以使用的最有效的提示之一是从短语“深呼吸，一步一步地工作”开始的。这应该会告诉你为什么语言如此重要。我们还没有完全理解如何最有效地使用该技术的先前迭代，如ChatGPT 3.5，更不用说正在开发的新版本了。\n提示模板 # 创建有效的提示涉及建立请求的上下文，并用特定于用户输入的值替换请求的部分。 该过程使用传统的基于文本的模板引擎来快速创建和管理。Spring AI为此使用OSS库StringTemplate。 例如，考虑简单的提示模板：\nTell me a {adjective} joke about {content}. 在SpringAI中，提示模板可以比作SpringMVC架构中的“视图”。模型对象，通常是java.util。Map，用于填充模板中的占位符。“渲染”字符串成为提供给AI模型的提示的内容。 发送到模型的提示的特定数据格式具有相当大的可变性。提示符最初是简单的字符串，现在已经发展到包括多个消息，其中每个消息中的每个字符串表示模型的不同角色。\n预埋件 # 嵌入是文本、图像或视频的数字表示，用于捕获输入之间的关系。 嵌入的工作原理是将文本、图像和视频转换为浮点数数组，称为向量。这些向量旨在捕获文本、图像和视频的含义。嵌入数组的长度称为向量的维数。 通过计算两段文本的向量表示之间的数字距离，应用程序可以确定用于生成嵌入向量的对象之间的相似性。 作为一名探索人工智能的Java开发人员，不需要理解复杂的数学理论或这些向量表示背后的特定实现。基本了解它们在人工智能系统中的作用和功能就足够了，特别是当您将人工智能功能集成到应用程序中时。 嵌入在实际应用中特别相关，如检索增强生成（RAG）模式。它们支持将数据表示为语义空间中的点，这类似于欧几里德几何的2-D空间，但具有更高的维度。这意味着，就像欧几里德几何中平面上的点如何基于它们的坐标来接近或远离一样，在语义空间中，点的接近反映了意义上的相似性。关于相似主题的句子在多维空间中的位置更近，就像图上彼此靠近的点。这种接近性有助于文本分类、语义搜索甚至产品推荐等任务，因为它允许人工智能根据相关概念在扩展的语义景观中的“位置”来识别和分组相关概念。 您可以将此语义空间视为向量。\n代币 # 代币是人工智能模型工作方式的构建块。在输入时，模型将单词转换为标记。在输出时，它们将标记转换回单词。 在英语中，一个标记大致相当于单词的75%。作为参考，莎士比亚的全部作品，总计约90万字，翻译成约120万个代币。 也许更重要的是代币=货币。在托管AI模型的上下文中，您的费用由使用的代币数量决定。输入和输出都会影响整个令牌计数。 此外，模型受到令牌限制的影响，这限制了单个API调用中处理的文本量。该阈值通常被称为“上下文窗口”。模型不处理任何超过此限制的文本。 例如，ChatGPT3具有4K代币限制，而GPT4提供不同的选项，如8K、16K和32K。人类的Claude AI模型具有100K代币限额，Meta最近的研究产生了1M代币限额模型。 要使用GPT4总结莎士比亚的作品集，您需要设计软件工程策略来分割数据，并在模型的上下文窗口限制内呈现数据。Spring AI项目可以帮助您完成这项任务。\n结构化输出 # AI模型的输出通常以java.lang.String的形式到达，即使您要求以JSON格式返回。它可能是正确的JSON，但不是JSON数据结构。它只是一个字符串。此外，在提示中询问“for JSON”不是100%准确的。 这种复杂性导致出现了一个专门的字段，涉及创建提示以产生预期的输出，然后将结果简单的字符串转换为用于应用程序集成的可用数据结构。 结构化输出转换使用精心编制的提示，通常需要与模型进行多次交互，以实现所需的格式。\n将您的数据和API引入人工智能模型 # 如何为人工智能模型配备尚未训练的信息？ 请注意，GPT 3.5/4.0数据集仅扩展到2021年9月。因此，该模型表示，它不知道在该日期之后需要知识的问题的答案。一个有趣的琐事是，该数据集约为650GB。 有三种技术可用于定制人工智能模型以合并您的数据：\n微调：这种传统的机器学习技术涉及裁剪模型并更改其内部权重。然而，对于机器学习专家来说，这是一个具有挑战性的过程，而对于GPT之类的模型，由于它们的规模，资源消耗非常大。此外，某些型号可能不提供此选项。 即时填充：一种更实用的替代方法涉及将数据嵌入到提供给模型的提示中。给定模型的令牌限制，需要技术在模型的上下文窗口中呈现相关数据。这种方法通俗地称为“填充提示符”。Spring AI库帮助您实现基于“填充提示”技术的解决方案，也称为检索增强生成（RAG）。 工具调用：该技术允许注册将大型语言模型连接到外部系统的API的工具（用户定义的服务）。SpringAI大大简化了您需要编写的代码，以支持工具调用。 检索增强生成 # 一种称为检索增强生成（RAG）的技术已经出现，以解决将相关数据合并到准确人工智能模型响应提示中的挑战。 该方法涉及批处理样式的编程模型，其中作业从文档中读取非结构化数据，对其进行转换，然后将其写入向量数据库。在高级别上，这是ETL（提取、转换和加载）管道。矢量数据库用于RAG技术的检索部分。 作为将非结构化数据加载到向量数据库的一部分，最重要的转换之一是将原始文档拆分为更小的片段。将原始文档拆分为较小的片段的过程有两个重要步骤： RAG的下一个阶段是处理用户输入。当用户的问题将由人工智能模型回答时，问题和所有“相似”的文档片段都被放在发送到人工智能模型的提示符中。这就是使用向量数据库的原因。它非常善于发现类似的内容。 ETL管道提供了有关编排从数据源提取数据并将其存储在结构化向量存储中的流的更多信息，确保数据在传递给AI模型时以最佳格式进行检索。 ChatClient-RAG解释了如何使用QuestionAnswerAdvisor在应用程序中启用RAG功能。 工具调用 # 大型语言模型（LLM）在训练后被冻结，导致知识过时，并且它们无法访问或修改外部数据。 工具调用机制解决了这些缺点。它允许您将自己的服务注册为工具，以将大型语言模型连接到外部系统的API。这些系统可以为LLM提供实时数据，并代表它们执行数据处理操作。 SpringAI大大简化了您需要编写的代码，以支持工具调用。它为您处理工具调用对话。您可以将工具作为@tool注释方法提供，并在提示选项中提供它，以使其可用于模型。此外，可以在单个提示中定义和引用多个工具。 有关如何将此功能用于不同的AI模型的更多信息，请参阅 工具调用文档。\n评估人工智能响应 # 响应用户请求有效评估人工智能系统的输出对于确保最终应用程序的准确性和有用性非常重要。有几种新兴技术能够为此目的使用预先训练的模型本身。 该评估过程涉及分析生成的响应是否与用户的意图和查询的上下文一致。相关性、一致性和事实正确性等指标用于衡量人工智能生成的响应的质量。 一种方法涉及呈现用户的请求和人工智能模型对模型的响应，查询响应是否与提供的数据一致。 此外，利用向量数据库中存储的信息作为补充数据可以加强评估过程，有助于确定响应相关性。 Spring AI项目提供了一个Evaluator API，该API目前允许访问评估模型响应的基本策略。有关更多信息，请遵循评估测试文档。\n"}]